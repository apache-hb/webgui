/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./install/share/gui.js":
/*!******************************!*\
  !*** ./install/share/gui.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{var __filename = \"/index.js\";\nvar __dirname = \"/\";\n// include: shell.js\n// include: minimum_runtime_check.js\n(function() {\n  // \"30.0.0\" -> 300000\n  function humanReadableVersionToPacked(str) {\n    str = str.split('-')[0]; // Remove any trailing part from e.g. \"12.53.3-alpha\"\n    var vers = str.split('.').slice(0, 3);\n    while(vers.length < 3) vers.push('00');\n    vers = vers.map((n, i, arr) => n.padStart(2, '0'));\n    return vers.join('');\n  }\n  // 300000 -> \"30.0.0\"\n  var packedVersionToHumanReadable = n => [n / 10000 | 0, (n / 100 | 0) % 100, n % 100].join('.');\n\n  var TARGET_NOT_SUPPORTED = 2147483647;\n\n  var currentNodeVersion = typeof process !== 'undefined' && process?.versions?.node ? humanReadableVersionToPacked(process.versions.node) : TARGET_NOT_SUPPORTED;\n  if (currentNodeVersion < 160000) {\n    throw new Error(`This emscripten-generated code requires node v${ packedVersionToHumanReadable(160000) } (detected v${packedVersionToHumanReadable(currentNodeVersion)})`);\n  }\n\n  var currentSafariVersion = typeof navigator !== 'undefined' && navigator?.userAgent?.includes(\"Safari/\") && navigator.userAgent.match(/Version\\/(\\d+\\.?\\d*\\.?\\d*)/) ? humanReadableVersionToPacked(navigator.userAgent.match(/Version\\/(\\d+\\.?\\d*\\.?\\d*)/)[1]) : TARGET_NOT_SUPPORTED;\n  if (currentSafariVersion < 150000) {\n    throw new Error(`This emscripten-generated code requires Safari v${ packedVersionToHumanReadable(150000) } (detected v${currentSafariVersion})`);\n  }\n\n  var currentFirefoxVersion = typeof navigator !== 'undefined' && navigator?.userAgent?.match(/Firefox\\/(\\d+(?:\\.\\d+)?)/) ? parseFloat(navigator.userAgent.match(/Firefox\\/(\\d+(?:\\.\\d+)?)/)[1]) : TARGET_NOT_SUPPORTED;\n  if (currentFirefoxVersion < 79) {\n    throw new Error(`This emscripten-generated code requires Firefox v79 (detected v${currentFirefoxVersion})`);\n  }\n\n  var currentChromeVersion = typeof navigator !== 'undefined' && navigator?.userAgent?.match(/Chrome\\/(\\d+(?:\\.\\d+)?)/) ? parseFloat(navigator.userAgent.match(/Chrome\\/(\\d+(?:\\.\\d+)?)/)[1]) : TARGET_NOT_SUPPORTED;\n  if (currentChromeVersion < 85) {\n    throw new Error(`This emscripten-generated code requires Chrome v85 (detected v${currentChromeVersion})`);\n  }\n})();\n\n// end include: minimum_runtime_check.js\n// The Module object: Our interface to the outside world. We import\n// and export values on it. There are various ways Module can be used:\n// 1. Not defined. We create it here\n// 2. A function parameter, function(moduleArg) => Promise<Module>\n// 3. pre-run appended it, var Module = {}; ..generated code..\n// 4. External script tag defines var Module.\n// We need to check if Module already exists (e.g. case 3 above).\n// Substitution will be replaced with actual code on later stage of the build,\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\n// Note that if you want to run closure, and also to use Module\n// after the generated code, you will need to define   var Module = {};\n// before the code. Then that object will be used in the code, and you\n// can continue to use Module afterwards as well.\nvar Module = typeof Module != 'undefined' ? Module : {};\n\n// Determine the runtime environment we are in. You can customize this by\n// setting the ENVIRONMENT setting at compile time (see settings.js).\n\n// Attempt to auto-detect the environment\nvar ENVIRONMENT_IS_WEB = !!globalThis.window;\nvar ENVIRONMENT_IS_WORKER = !!globalThis.WorkerGlobalScope;\n// N.b. Electron.js environment is simultaneously a NODE-environment, but\n// also a web environment.\nvar ENVIRONMENT_IS_NODE = globalThis.process?.versions?.node && globalThis.process?.type != 'renderer';\nvar ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\n\n// --pre-jses are emitted after the Module integration code, so that they can\n// refer to Module (if they choose; they can also define Module)\n\n\nvar arguments_ = [];\nvar thisProgram = './this.program';\nvar quit_ = (status, toThrow) => {\n  throw toThrow;\n};\n\n// In MODULARIZE mode _scriptName needs to be captured already at the very top of the page immediately when the page is parsed, so it is generated there\n// before the page load. In non-MODULARIZE modes generate it here.\nvar _scriptName = globalThis.document?.currentScript?.src;\n\nif (true) { // Node\n  _scriptName = __filename;\n} else\n// removed by dead control flow\n{}\n\n// `/` should be present at the end if `scriptDirectory` is not empty\nvar scriptDirectory = '';\nfunction locateFile(path) {\n  if (Module['locateFile']) {\n    return Module['locateFile'](path, scriptDirectory);\n  }\n  return scriptDirectory + path;\n}\n\n// Hooks that are implemented differently in different runtime environments.\nvar readAsync, readBinary;\n\nif (ENVIRONMENT_IS_NODE) {\n  const isNode = globalThis.process?.versions?.node && globalThis.process?.type != 'renderer';\n  if (!isNode) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\n\n  // These modules will usually be used on Node.js. Load them eagerly to avoid\n  // the complexity of lazy-loading.\n  var fs = __webpack_require__(/*! fs */ \"?d872\");\n\n  scriptDirectory = __dirname + '/';\n\n// include: node_shell_read.js\nreadBinary = (filename) => {\n  // We need to re-wrap `file://` strings to URLs.\n  filename = isFileURI(filename) ? new URL(filename) : filename;\n  var ret = fs.readFileSync(filename);\n  assert(Buffer.isBuffer(ret));\n  return ret;\n};\n\nreadAsync = async (filename, binary = true) => {\n  // See the comment in the `readBinary` function.\n  filename = isFileURI(filename) ? new URL(filename) : filename;\n  var ret = fs.readFileSync(filename, binary ? undefined : 'utf8');\n  assert(binary ? Buffer.isBuffer(ret) : typeof ret == 'string');\n  return ret;\n};\n// end include: node_shell_read.js\n  if (process.argv.length > 1) {\n    thisProgram = process.argv[1].replace(/\\\\/g, '/');\n  }\n\n  arguments_ = process.argv.slice(2);\n\n  // MODULARIZE will export the module in the proper place outside, we don't need to export here\n  if (true) {\n    module['exports'] = Module;\n  }\n\n  quit_ = (status, toThrow) => {\n    process.exitCode = status;\n    throw toThrow;\n  };\n\n} else\nif (ENVIRONMENT_IS_SHELL) {\n\n} else\n\n// Note that this includes Node.js workers when relevant (pthreads is enabled).\n// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\n// ENVIRONMENT_IS_NODE.\nif (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n  try {\n    scriptDirectory = new URL('.', _scriptName).href; // includes trailing slash\n  } catch {\n    // Must be a `blob:` or `data:` URL (e.g. `blob:http://site.com/etc/etc`), we cannot\n    // infer anything from them.\n  }\n\n  if (!(globalThis.window || globalThis.WorkerGlobalScope)) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\n\n  {\n// include: web_or_worker_shell_read.js\nif (ENVIRONMENT_IS_WORKER) {\n    readBinary = (url) => {\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, false);\n      xhr.responseType = 'arraybuffer';\n      xhr.send(null);\n      return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));\n    };\n  }\n\n  readAsync = async (url) => {\n    // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.\n    // See https://github.com/github/fetch/pull/92#issuecomment-140665932\n    // Cordova or Electron apps are typically loaded from a file:// url.\n    // So use XHR on webview if URL is a file URL.\n    if (isFileURI(url)) {\n      return new Promise((resolve, reject) => {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', url, true);\n        xhr.responseType = 'arraybuffer';\n        xhr.onload = () => {\n          if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\n            resolve(xhr.response);\n            return;\n          }\n          reject(xhr.status);\n        };\n        xhr.onerror = reject;\n        xhr.send(null);\n      });\n    }\n    var response = await fetch(url, { credentials: 'same-origin' });\n    if (response.ok) {\n      return response.arrayBuffer();\n    }\n    throw new Error(response.status + ' : ' + response.url);\n  };\n// end include: web_or_worker_shell_read.js\n  }\n} else\n{\n  throw new Error('environment detection error');\n}\n\nvar out = console.log.bind(console);\nvar err = console.error.bind(console);\n\nvar IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';\nvar PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';\nvar WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';\nvar FETCHFS = 'FETCHFS is no longer included by default; build with -lfetchfs.js';\nvar ICASEFS = 'ICASEFS is no longer included by default; build with -licasefs.js';\nvar JSFILEFS = 'JSFILEFS is no longer included by default; build with -ljsfilefs.js';\nvar OPFS = 'OPFS is no longer included by default; build with -lopfs.js';\n\nvar NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';\n\n// perform assertions in shell.js after we set up out() and err(), as otherwise\n// if an assertion fails it cannot print the message\n\nassert(!ENVIRONMENT_IS_SHELL, 'shell environment detected but not enabled at build time.  Add `shell` to `-sENVIRONMENT` to enable.');\n\n// end include: shell.js\n\n// include: preamble.js\n// === Preamble library stuff ===\n\n// Documentation for the public APIs defined in this file must be updated in:\n//    site/source/docs/api_reference/preamble.js.rst\n// A prebuilt local version of the documentation is available at:\n//    site/build/text/docs/api_reference/preamble.js.txt\n// You can also build docs locally as HTML or other formats in site/\n// An online HTML version (which may be of a different version of Emscripten)\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\nvar wasmBinary;\n\nif (!globalThis.WebAssembly) {\n  err('no native wasm support detected');\n}\n\n// Wasm globals\n\n//========================================\n// Runtime essentials\n//========================================\n\n// whether we are quitting the application. no code should run after this.\n// set in exit() and abort()\nvar ABORT = false;\n\n// set by exit() and abort().  Passed to 'onExit' handler.\n// NOTE: This is also used as the process return code code in shell environments\n// but only when noExitRuntime is false.\nvar EXITSTATUS;\n\n// In STRICT mode, we only define assert() when ASSERTIONS is set.  i.e. we\n// don't define it at all in release modes.  This matches the behaviour of\n// MINIMAL_RUNTIME.\n// TODO(sbc): Make this the default even without STRICT enabled.\n/** @type {function(*, string=)} */\nfunction assert(condition, text) {\n  if (!condition) {\n    abort('Assertion failed' + (text ? ': ' + text : ''));\n  }\n}\n\n// We used to include malloc/free by default in the past. Show a helpful error in\n// builds with assertions.\n\n/**\n * Indicates whether filename is delivered via file protocol (as opposed to http/https)\n * @noinline\n */\nvar isFileURI = (filename) => filename.startsWith('file://');\n\n// include: runtime_common.js\n// include: runtime_stack_check.js\n// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\nfunction writeStackCookie() {\n  var max = _emscripten_stack_get_end();\n  assert((max & 3) == 0);\n  // If the stack ends at address zero we write our cookies 4 bytes into the\n  // stack.  This prevents interference with SAFE_HEAP and ASAN which also\n  // monitor writes to address zero.\n  if (max == 0) {\n    max += 4;\n  }\n  // The stack grow downwards towards _emscripten_stack_get_end.\n  // We write cookies to the final two words in the stack and detect if they are\n  // ever overwritten.\n  HEAPU32[((max)>>2)] = 0x02135467;\n  HEAPU32[(((max)+(4))>>2)] = 0x89BACDFE;\n  // Also test the global address 0 for integrity.\n  HEAPU32[((0)>>2)] = 1668509029;\n}\n\nfunction checkStackCookie() {\n  if (ABORT) return;\n  var max = _emscripten_stack_get_end();\n  // See writeStackCookie().\n  if (max == 0) {\n    max += 4;\n  }\n  var cookie1 = HEAPU32[((max)>>2)];\n  var cookie2 = HEAPU32[(((max)+(4))>>2)];\n  if (cookie1 != 0x02135467 || cookie2 != 0x89BACDFE) {\n    abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);\n  }\n  // Also test the global address 0 for integrity.\n  if (HEAPU32[((0)>>2)] != 0x63736d65 /* 'emsc' */) {\n    abort('Runtime error: The application has corrupted its heap memory area (address zero)!');\n  }\n}\n// end include: runtime_stack_check.js\n// include: runtime_exceptions.js\n// end include: runtime_exceptions.js\n// include: runtime_debug.js\nvar runtimeDebug = true; // Switch to false at runtime to disable logging at the right times\n\n// Used by XXXXX_DEBUG settings to output debug messages.\nfunction dbg(...args) {\n  if (!runtimeDebug && typeof runtimeDebug != 'undefined') return;\n  // TODO(sbc): Make this configurable somehow.  Its not always convenient for\n  // logging to show up as warnings.\n  console.warn(...args);\n}\n\n// Endianness check\n(() => {\n  var h16 = new Int16Array(1);\n  var h8 = new Int8Array(h16.buffer);\n  h16[0] = 0x6373;\n  if (h8[0] !== 0x73 || h8[1] !== 0x63) abort('Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)');\n})();\n\nfunction consumedModuleProp(prop) {\n  if (!Object.getOwnPropertyDescriptor(Module, prop)) {\n    Object.defineProperty(Module, prop, {\n      configurable: true,\n      set() {\n        abort(`Attempt to set \\`Module.${prop}\\` after it has already been processed.  This can happen, for example, when code is injected via '--post-js' rather than '--pre-js'`);\n\n      }\n    });\n  }\n}\n\nfunction makeInvalidEarlyAccess(name) {\n  return () => assert(false, `call to '${name}' via reference taken before Wasm module initialization`);\n\n}\n\nfunction ignoredModuleProp(prop) {\n  if (Object.getOwnPropertyDescriptor(Module, prop)) {\n    abort(`\\`Module.${prop}\\` was supplied but \\`${prop}\\` not included in INCOMING_MODULE_JS_API`);\n  }\n}\n\n// forcing the filesystem exports a few things by default\nfunction isExportedByForceFilesystem(name) {\n  return name === 'FS_createPath' ||\n         name === 'FS_createDataFile' ||\n         name === 'FS_createPreloadedFile' ||\n         name === 'FS_preloadFile' ||\n         name === 'FS_unlink' ||\n         name === 'addRunDependency' ||\n         // The old FS has some functionality that WasmFS lacks.\n         name === 'FS_createLazyFile' ||\n         name === 'FS_createDevice' ||\n         name === 'removeRunDependency';\n}\n\n/**\n * Intercept access to a symbols in the global symbol.  This enables us to give\n * informative warnings/errors when folks attempt to use symbols they did not\n * include in their build, or no symbols that no longer exist.\n *\n * We don't define this in MODULARIZE mode since in that mode emscripten symbols\n * are never placed in the global scope.\n */\nfunction hookGlobalSymbolAccess(sym, func) {\n  if (!Object.getOwnPropertyDescriptor(globalThis, sym)) {\n    Object.defineProperty(globalThis, sym, {\n      configurable: true,\n      get() {\n        func();\n        return undefined;\n      }\n    });\n  }\n}\n\nfunction missingGlobal(sym, msg) {\n  hookGlobalSymbolAccess(sym, () => {\n    warnOnce(`\\`${sym}\\` is no longer defined by emscripten. ${msg}`);\n  });\n}\n\nmissingGlobal('buffer', 'Please use HEAP8.buffer or wasmMemory.buffer');\nmissingGlobal('asm', 'Please use wasmExports instead');\n\nfunction missingLibrarySymbol(sym) {\n  hookGlobalSymbolAccess(sym, () => {\n    // Can't `abort()` here because it would break code that does runtime\n    // checks.  e.g. `if (typeof SDL === 'undefined')`.\n    var msg = `\\`${sym}\\` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line`;\n    // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in\n    // library.js, which means $name for a JS name with no prefix, or name\n    // for a JS name like _name.\n    var librarySymbol = sym;\n    if (!librarySymbol.startsWith('_')) {\n      librarySymbol = '$' + sym;\n    }\n    msg += ` (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='${librarySymbol}')`;\n    if (isExportedByForceFilesystem(sym)) {\n      msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\n    }\n    warnOnce(msg);\n  });\n\n  // Any symbol that is not included from the JS library is also (by definition)\n  // not exported on the Module object.\n  unexportedRuntimeSymbol(sym);\n}\n\nfunction unexportedRuntimeSymbol(sym) {\n  if (!Object.getOwnPropertyDescriptor(Module, sym)) {\n    Object.defineProperty(Module, sym, {\n      configurable: true,\n      get() {\n        var msg = `'${sym}' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)`;\n        if (isExportedByForceFilesystem(sym)) {\n          msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\n        }\n        abort(msg);\n      },\n    });\n  }\n}\n\n// end include: runtime_debug.js\n// Memory management\nvar\n/** @type {!Int8Array} */\n  HEAP8,\n/** @type {!Uint8Array} */\n  HEAPU8,\n/** @type {!Int16Array} */\n  HEAP16,\n/** @type {!Uint16Array} */\n  HEAPU16,\n/** @type {!Int32Array} */\n  HEAP32,\n/** @type {!Uint32Array} */\n  HEAPU32,\n/** @type {!Float32Array} */\n  HEAPF32,\n/** @type {!Float64Array} */\n  HEAPF64;\n\n// BigInt64Array type is not correctly defined in closure\nvar\n/** not-@type {!BigInt64Array} */\n  HEAP64,\n/* BigUint64Array type is not correctly defined in closure\n/** not-@type {!BigUint64Array} */\n  HEAPU64;\n\nvar runtimeInitialized = false;\n\n\n\nfunction updateMemoryViews() {\n  var b = wasmMemory.buffer;\n  HEAP8 = new Int8Array(b);\n  HEAP16 = new Int16Array(b);\n  HEAPU8 = new Uint8Array(b);\n  HEAPU16 = new Uint16Array(b);\n  HEAP32 = new Int32Array(b);\n  HEAPU32 = new Uint32Array(b);\n  HEAPF32 = new Float32Array(b);\n  HEAPF64 = new Float64Array(b);\n  HEAP64 = new BigInt64Array(b);\n  HEAPU64 = new BigUint64Array(b);\n}\n\n// include: memoryprofiler.js\n// end include: memoryprofiler.js\n// end include: runtime_common.js\nassert(globalThis.Int32Array && globalThis.Float64Array && Int32Array.prototype.subarray && Int32Array.prototype.set,\n       'JS engine does not provide full typed array support');\n\nfunction preRun() {\n  if (Module['preRun']) {\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n    while (Module['preRun'].length) {\n      addOnPreRun(Module['preRun'].shift());\n    }\n  }\n  consumedModuleProp('preRun');\n  // Begin ATPRERUNS hooks\n  callRuntimeCallbacks(onPreRuns);\n  // End ATPRERUNS hooks\n}\n\nfunction initRuntime() {\n  assert(!runtimeInitialized);\n  runtimeInitialized = true;\n\n  checkStackCookie();\n\n  // Begin ATINITS hooks\n  if (!Module['noFSInit'] && !FS.initialized) FS.init();\nTTY.init();\n  // End ATINITS hooks\n\n  wasmExports['__wasm_call_ctors']();\n\n  // Begin ATPOSTCTORS hooks\n  FS.ignorePermissions = false;\n  // End ATPOSTCTORS hooks\n}\n\nfunction preMain() {\n  checkStackCookie();\n  // No ATMAINS hooks\n}\n\nfunction postRun() {\n  checkStackCookie();\n   // PThreads reuse the runtime from the main thread.\n\n  if (Module['postRun']) {\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n    while (Module['postRun'].length) {\n      addOnPostRun(Module['postRun'].shift());\n    }\n  }\n  consumedModuleProp('postRun');\n\n  // Begin ATPOSTRUNS hooks\n  callRuntimeCallbacks(onPostRuns);\n  // End ATPOSTRUNS hooks\n}\n\n/** @param {string|number=} what */\nfunction abort(what) {\n  Module['onAbort']?.(what);\n\n  what = 'Aborted(' + what + ')';\n  // TODO(sbc): Should we remove printing and leave it up to whoever\n  // catches the exception?\n  err(what);\n\n  ABORT = true;\n\n  // Use a wasm runtime error, because a JS error might be seen as a foreign\n  // exception, which means we'd run destructors on it. We need the error to\n  // simply make the program stop.\n  // FIXME This approach does not work in Wasm EH because it currently does not assume\n  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from\n  // a trap or not based on a hidden field within the object. So at the moment\n  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that\n  // allows this in the wasm spec.\n\n  // Suppress closure compiler warning here. Closure compiler's builtin extern\n  // definition for WebAssembly.RuntimeError claims it takes no arguments even\n  // though it can.\n  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.\n  /** @suppress {checkTypes} */\n  var e = new WebAssembly.RuntimeError(what);\n\n  // Throw the error whether or not MODULARIZE is set because abort is used\n  // in code paths apart from instantiation where an exception is expected\n  // to be thrown when abort is called.\n  throw e;\n}\n\nfunction createExportWrapper(name, nargs) {\n  return (...args) => {\n    assert(runtimeInitialized, `native function \\`${name}\\` called before runtime initialization`);\n    var f = wasmExports[name];\n    assert(f, `exported native function \\`${name}\\` not found`);\n    // Only assert for too many arguments. Too few can be valid since the missing arguments will be zero filled.\n    assert(args.length <= nargs, `native function \\`${name}\\` called with ${args.length} args but expects ${nargs}`);\n    return f(...args);\n  };\n}\n\nvar wasmBinaryFile;\n\nfunction findWasmBinary() {\n  return locateFile('gui.wasm');\n}\n\nfunction getBinarySync(file) {\n  if (file == wasmBinaryFile && wasmBinary) {\n    return new Uint8Array(wasmBinary);\n  }\n  if (readBinary) {\n    return readBinary(file);\n  }\n  // Throwing a plain string here, even though it not normally adviables since\n  // this gets turning into an `abort` in instantiateArrayBuffer.\n  throw 'both async and sync fetching of the wasm failed';\n}\n\nasync function getWasmBinary(binaryFile) {\n  // If we don't have the binary yet, load it asynchronously using readAsync.\n  if (!wasmBinary) {\n    // Fetch the binary using readAsync\n    try {\n      var response = await readAsync(binaryFile);\n      return new Uint8Array(response);\n    } catch {\n      // Fall back to getBinarySync below;\n    }\n  }\n\n  // Otherwise, getBinarySync should be able to get it synchronously\n  return getBinarySync(binaryFile);\n}\n\nasync function instantiateArrayBuffer(binaryFile, imports) {\n  try {\n    var binary = await getWasmBinary(binaryFile);\n    var instance = await WebAssembly.instantiate(binary, imports);\n    return instance;\n  } catch (reason) {\n    err(`failed to asynchronously prepare wasm: ${reason}`);\n\n    // Warn on some common problems.\n    if (isFileURI(binaryFile)) {\n      err(`warning: Loading from a file URI (${binaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`);\n    }\n    abort(reason);\n  }\n}\n\nasync function instantiateAsync(binary, binaryFile, imports) {\n  if (!binary\n      // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.\n      && !isFileURI(binaryFile)\n      // Avoid instantiateStreaming() on Node.js environment for now, as while\n      // Node.js v18.1.0 implements it, it does not have a full fetch()\n      // implementation yet.\n      //\n      // Reference:\n      //   https://github.com/emscripten-core/emscripten/pull/16917\n      && !ENVIRONMENT_IS_NODE\n     ) {\n    try {\n      var response = fetch(binaryFile, { credentials: 'same-origin' });\n      var instantiationResult = await WebAssembly.instantiateStreaming(response, imports);\n      return instantiationResult;\n    } catch (reason) {\n      // We expect the most common failure cause to be a bad MIME type for the binary,\n      // in which case falling back to ArrayBuffer instantiation should work.\n      err(`wasm streaming compile failed: ${reason}`);\n      err('falling back to ArrayBuffer instantiation');\n      // fall back of instantiateArrayBuffer below\n    };\n  }\n  return instantiateArrayBuffer(binaryFile, imports);\n}\n\nfunction getWasmImports() {\n  // prepare imports\n  var imports = {\n    'env': wasmImports,\n    'wasi_snapshot_preview1': wasmImports,\n  };\n  return imports;\n}\n\n// Create the wasm instance.\n// Receives the wasm imports, returns the exports.\nasync function createWasm() {\n  // Load the wasm module and create an instance of using native support in the JS engine.\n  // handle a generated wasm instance, receiving its exports and\n  // performing other necessary setup\n  /** @param {WebAssembly.Module=} module*/\n  function receiveInstance(instance, module) {\n    wasmExports = instance.exports;\n\n    assignWasmExports(wasmExports);\n\n    updateMemoryViews();\n\n    removeRunDependency('wasm-instantiate');\n    return wasmExports;\n  }\n  addRunDependency('wasm-instantiate');\n\n  // Prefer streaming instantiation if available.\n  // Async compilation can be confusing when an error on the page overwrites Module\n  // (for example, if the order of elements is wrong, and the one defining Module is\n  // later), so we save Module and check it later.\n  var trueModule = Module;\n  function receiveInstantiationResult(result) {\n    // 'result' is a ResultObject object which has both the module and instance.\n    // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\n    trueModule = null;\n    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\n    // When the regression is fixed, can restore the above PTHREADS-enabled path.\n    return receiveInstance(result['instance']);\n  }\n\n  var info = getWasmImports();\n\n  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n  // to manually instantiate the Wasm module themselves. This allows pages to\n  // run the instantiation parallel to any other async startup actions they are\n  // performing.\n  // Also pthreads and wasm workers initialize the wasm instance through this\n  // path.\n  if (Module['instantiateWasm']) {\n    return new Promise((resolve, reject) => {\n      try {\n        Module['instantiateWasm'](info, (inst, mod) => {\n          resolve(receiveInstance(inst, mod));\n        });\n      } catch(e) {\n        err(`Module.instantiateWasm callback failed with error: ${e}`);\n        reject(e);\n      }\n    });\n  }\n\n  wasmBinaryFile ??= findWasmBinary();\n  var result = await instantiateAsync(wasmBinary, wasmBinaryFile, info);\n  var exports = receiveInstantiationResult(result);\n  return exports;\n}\n\n// end include: preamble.js\n\n// Begin JS library code\n\n\n  class ExitStatus {\n      name = 'ExitStatus';\n      constructor(status) {\n        this.message = `Program terminated with exit(${status})`;\n        this.status = status;\n      }\n    }\n\n  var callRuntimeCallbacks = (callbacks) => {\n      while (callbacks.length > 0) {\n        // Pass the module as the first argument.\n        callbacks.shift()(Module);\n      }\n    };\n  var onPostRuns = [];\n  var addOnPostRun = (cb) => onPostRuns.push(cb);\n\n  var onPreRuns = [];\n  var addOnPreRun = (cb) => onPreRuns.push(cb);\n\n  var runDependencies = 0;\n  \n  \n  var dependenciesFulfilled = null;\n  \n  var runDependencyTracking = {\n  };\n  \n  var runDependencyWatcher = null;\n  var removeRunDependency = (id) => {\n      runDependencies--;\n  \n      Module['monitorRunDependencies']?.(runDependencies);\n  \n      assert(id, 'removeRunDependency requires an ID');\n      assert(runDependencyTracking[id]);\n      delete runDependencyTracking[id];\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback(); // can add another dependenciesFulfilled\n        }\n      }\n    };\n  \n  \n  var addRunDependency = (id) => {\n      runDependencies++;\n  \n      Module['monitorRunDependencies']?.(runDependencies);\n  \n      assert(id, 'addRunDependency requires an ID')\n      assert(!runDependencyTracking[id]);\n      runDependencyTracking[id] = 1;\n      if (runDependencyWatcher === null && globalThis.setInterval) {\n        // Check for missing dependencies every few seconds\n        runDependencyWatcher = setInterval(() => {\n          if (ABORT) {\n            clearInterval(runDependencyWatcher);\n            runDependencyWatcher = null;\n            return;\n          }\n          var shown = false;\n          for (var dep in runDependencyTracking) {\n            if (!shown) {\n              shown = true;\n              err('still waiting on run dependencies:');\n            }\n            err(`dependency: ${dep}`);\n          }\n          if (shown) {\n            err('(end of list)');\n          }\n        }, 10000);\n        // Prevent this timer from keeping the runtime alive if nothing\n        // else is.\n        runDependencyWatcher.unref?.()\n      }\n    };\n\n\n  \n    /**\n     * @param {number} ptr\n     * @param {string} type\n     */\n  function getValue(ptr, type = 'i8') {\n    if (type.endsWith('*')) type = '*';\n    switch (type) {\n      case 'i1': return HEAP8[ptr];\n      case 'i8': return HEAP8[ptr];\n      case 'i16': return HEAP16[((ptr)>>1)];\n      case 'i32': return HEAP32[((ptr)>>2)];\n      case 'i64': return HEAP64[((ptr)>>3)];\n      case 'float': return HEAPF32[((ptr)>>2)];\n      case 'double': return HEAPF64[((ptr)>>3)];\n      case '*': return HEAPU32[((ptr)>>2)];\n      default: abort(`invalid type for getValue: ${type}`);\n    }\n  }\n\n  var noExitRuntime = true;\n\n  var ptrToString = (ptr) => {\n      assert(typeof ptr === 'number', `ptrToString expects a number, got ${typeof ptr}`);\n      // Convert to 32-bit unsigned value\n      ptr >>>= 0;\n      return '0x' + ptr.toString(16).padStart(8, '0');\n    };\n\n\n  \n    /**\n     * @param {number} ptr\n     * @param {number} value\n     * @param {string} type\n     */\n  function setValue(ptr, value, type = 'i8') {\n    if (type.endsWith('*')) type = '*';\n    switch (type) {\n      case 'i1': HEAP8[ptr] = value; break;\n      case 'i8': HEAP8[ptr] = value; break;\n      case 'i16': HEAP16[((ptr)>>1)] = value; break;\n      case 'i32': HEAP32[((ptr)>>2)] = value; break;\n      case 'i64': HEAP64[((ptr)>>3)] = BigInt(value); break;\n      case 'float': HEAPF32[((ptr)>>2)] = value; break;\n      case 'double': HEAPF64[((ptr)>>3)] = value; break;\n      case '*': HEAPU32[((ptr)>>2)] = value; break;\n      default: abort(`invalid type for setValue: ${type}`);\n    }\n  }\n\n  var stackRestore = (val) => __emscripten_stack_restore(val);\n\n  var stackSave = () => _emscripten_stack_get_current();\n\n  var warnOnce = (text) => {\n      warnOnce.shown ||= {};\n      if (!warnOnce.shown[text]) {\n        warnOnce.shown[text] = 1;\n        if (ENVIRONMENT_IS_NODE) text = 'warning: ' + text;\n        err(text);\n      }\n    };\n\n  \n\n  var UTF8Decoder = globalThis.TextDecoder && new TextDecoder();\n  \n  var findStringEnd = (heapOrArray, idx, maxBytesToRead, ignoreNul) => {\n      var maxIdx = idx + maxBytesToRead;\n      if (ignoreNul) return maxIdx;\n      // TextDecoder needs to know the byte length in advance, it doesn't stop on\n      // null terminator by itself.\n      // As a tiny code save trick, compare idx against maxIdx using a negation,\n      // so that maxBytesToRead=undefined/NaN means Infinity.\n      while (heapOrArray[idx] && !(idx >= maxIdx)) ++idx;\n      return idx;\n    };\n  \n  \n    /**\n     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given\n     * array that contains uint8 values, returns a copy of that string as a\n     * Javascript String object.\n     * heapOrArray is either a regular array, or a JavaScript typed array view.\n     * @param {number=} idx\n     * @param {number=} maxBytesToRead\n     * @param {boolean=} ignoreNul - If true, the function will not stop on a NUL character.\n     * @return {string}\n     */\n  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead, ignoreNul) => {\n  \n      var endPtr = findStringEnd(heapOrArray, idx, maxBytesToRead, ignoreNul);\n  \n      // When using conditional TextDecoder, skip it for short strings as the overhead of the native call is not worth it.\n      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n      }\n      var str = '';\n      while (idx < endPtr) {\n        // For UTF8 byte structure, see:\n        // http://en.wikipedia.org/wiki/UTF-8#Description\n        // https://www.ietf.org/rfc/rfc2279.txt\n        // https://tools.ietf.org/html/rfc3629\n        var u0 = heapOrArray[idx++];\n        if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\n        var u1 = heapOrArray[idx++] & 63;\n        if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\n        var u2 = heapOrArray[idx++] & 63;\n        if ((u0 & 0xF0) == 0xE0) {\n          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\n        } else {\n          if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte ' + ptrToString(u0) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');\n          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\n        }\n  \n        if (u0 < 0x10000) {\n          str += String.fromCharCode(u0);\n        } else {\n          var ch = u0 - 0x10000;\n          str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\n        }\n      }\n      return str;\n    };\n  \n    /**\n     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the\n     * emscripten HEAP, returns a copy of that string as a Javascript String object.\n     *\n     * @param {number} ptr\n     * @param {number=} maxBytesToRead - An optional length that specifies the\n     *   maximum number of bytes to read. You can omit this parameter to scan the\n     *   string until the first 0 byte. If maxBytesToRead is passed, and the string\n     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the\n     *   string will cut short at that byte index.\n     * @param {boolean=} ignoreNul - If true, the function will not stop on a NUL character.\n     * @return {string}\n     */\n  var UTF8ToString = (ptr, maxBytesToRead, ignoreNul) => {\n      assert(typeof ptr == 'number', `UTF8ToString expects a number (got ${typeof ptr})`);\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead, ignoreNul) : '';\n    };\n  var ___assert_fail = (condition, filename, line, func) =>\n      abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);\n\n  var syscallGetVarargI = () => {\n      assert(SYSCALLS.varargs != undefined);\n      // the `+` prepended here is necessary to convince the JSCompiler that varargs is indeed a number.\n      var ret = HEAP32[((+SYSCALLS.varargs)>>2)];\n      SYSCALLS.varargs += 4;\n      return ret;\n    };\n  var syscallGetVarargP = syscallGetVarargI;\n  \n  \n  var PATH = {\n  isAbs:(path) => path.charAt(0) === '/',\n  splitPath:(filename) => {\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },\n  normalizeArray:(parts, allowAboveRoot) => {\n        // if the path tries to go above the root, `up` ends up > 0\n        var up = 0;\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n          if (last === '.') {\n            parts.splice(i, 1);\n          } else if (last === '..') {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        }\n        // if the path is allowed to go above the root, restore leading ..s\n        if (allowAboveRoot) {\n          for (; up; up--) {\n            parts.unshift('..');\n          }\n        }\n        return parts;\n      },\n  normalize:(path) => {\n        var isAbsolute = PATH.isAbs(path),\n            trailingSlash = path.slice(-1) === '/';\n        // Normalize the path\n        path = PATH.normalizeArray(path.split('/').filter((p) => !!p), !isAbsolute).join('/');\n        if (!path && !isAbsolute) {\n          path = '.';\n        }\n        if (path && trailingSlash) {\n          path += '/';\n        }\n        return (isAbsolute ? '/' : '') + path;\n      },\n  dirname:(path) => {\n        var result = PATH.splitPath(path),\n            root = result[0],\n            dir = result[1];\n        if (!root && !dir) {\n          // No dirname whatsoever\n          return '.';\n        }\n        if (dir) {\n          // It has a dirname, strip trailing slash\n          dir = dir.slice(0, -1);\n        }\n        return root + dir;\n      },\n  basename:(path) => path && path.match(/([^\\/]+|\\/)\\/*$/)[1],\n  join:(...paths) => PATH.normalize(paths.join('/')),\n  join2:(l, r) => PATH.normalize(l + '/' + r),\n  };\n  \n  var initRandomFill = () => {\n      // This block is not needed on v19+ since crypto.getRandomValues is builtin\n      if (ENVIRONMENT_IS_NODE) {\n        var nodeCrypto = __webpack_require__(/*! crypto */ \"?df81\");\n        return (view) => nodeCrypto.randomFillSync(view);\n      }\n  \n      return (view) => crypto.getRandomValues(view);\n    };\n  var randomFill = (view) => {\n      // Lazily init on the first invocation.\n      (randomFill = initRandomFill())(view);\n    };\n  \n  \n  \n  var PATH_FS = {\n  resolve:(...args) => {\n        var resolvedPath = '',\n          resolvedAbsolute = false;\n        for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n          var path = (i >= 0) ? args[i] : FS.cwd();\n          // Skip empty and invalid entries\n          if (typeof path != 'string') {\n            throw new TypeError('Arguments to path.resolve must be strings');\n          } else if (!path) {\n            return ''; // an invalid portion invalidates the whole thing\n          }\n          resolvedPath = path + '/' + resolvedPath;\n          resolvedAbsolute = PATH.isAbs(path);\n        }\n        // At this point the path should be resolved to a full absolute path, but\n        // handle relative paths to be safe (might happen when process.cwd() fails)\n        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter((p) => !!p), !resolvedAbsolute).join('/');\n        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n      },\n  relative:(from, to) => {\n        from = PATH_FS.resolve(from).slice(1);\n        to = PATH_FS.resolve(to).slice(1);\n        function trim(arr) {\n          var start = 0;\n          for (; start < arr.length; start++) {\n            if (arr[start] !== '') break;\n          }\n          var end = arr.length - 1;\n          for (; end >= 0; end--) {\n            if (arr[end] !== '') break;\n          }\n          if (start > end) return [];\n          return arr.slice(start, end - start + 1);\n        }\n        var fromParts = trim(from.split('/'));\n        var toParts = trim(to.split('/'));\n        var length = Math.min(fromParts.length, toParts.length);\n        var samePartsLength = length;\n        for (var i = 0; i < length; i++) {\n          if (fromParts[i] !== toParts[i]) {\n            samePartsLength = i;\n            break;\n          }\n        }\n        var outputParts = [];\n        for (var i = samePartsLength; i < fromParts.length; i++) {\n          outputParts.push('..');\n        }\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\n        return outputParts.join('/');\n      },\n  };\n  \n  \n  \n  var FS_stdin_getChar_buffer = [];\n  \n  var lengthBytesUTF8 = (str) => {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\n        // unit, not a Unicode code point of the character! So decode\n        // UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var c = str.charCodeAt(i); // possibly a lead surrogate\n        if (c <= 0x7F) {\n          len++;\n        } else if (c <= 0x7FF) {\n          len += 2;\n        } else if (c >= 0xD800 && c <= 0xDFFF) {\n          len += 4; ++i;\n        } else {\n          len += 3;\n        }\n      }\n      return len;\n    };\n  \n  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\n      assert(typeof str === 'string', `stringToUTF8Array expects a string (got ${typeof str})`);\n      // Parameter maxBytesToWrite is not optional. Negative values, 0, null,\n      // undefined and false each don't write out any bytes.\n      if (!(maxBytesToWrite > 0))\n        return 0;\n  \n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n      for (var i = 0; i < str.length; ++i) {\n        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description\n        // and https://www.ietf.org/rfc/rfc2279.txt\n        // and https://tools.ietf.org/html/rfc3629\n        var u = str.codePointAt(i);\n        if (u <= 0x7F) {\n          if (outIdx >= endIdx) break;\n          heap[outIdx++] = u;\n        } else if (u <= 0x7FF) {\n          if (outIdx + 1 >= endIdx) break;\n          heap[outIdx++] = 0xC0 | (u >> 6);\n          heap[outIdx++] = 0x80 | (u & 63);\n        } else if (u <= 0xFFFF) {\n          if (outIdx + 2 >= endIdx) break;\n          heap[outIdx++] = 0xE0 | (u >> 12);\n          heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n          heap[outIdx++] = 0x80 | (u & 63);\n        } else {\n          if (outIdx + 3 >= endIdx) break;\n          if (u > 0x10FFFF) warnOnce('Invalid Unicode code point ' + ptrToString(u) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).');\n          heap[outIdx++] = 0xF0 | (u >> 18);\n          heap[outIdx++] = 0x80 | ((u >> 12) & 63);\n          heap[outIdx++] = 0x80 | ((u >> 6) & 63);\n          heap[outIdx++] = 0x80 | (u & 63);\n          // Gotcha: if codePoint is over 0xFFFF, it is represented as a surrogate pair in UTF-16.\n          // We need to manually skip over the second code unit for correct iteration.\n          i++;\n        }\n      }\n      // Null-terminate the pointer to the buffer.\n      heap[outIdx] = 0;\n      return outIdx - startIdx;\n    };\n  /** @type {function(string, boolean=, number=)} */\n  var intArrayFromString = (stringy, dontAddNull, length) => {\n      var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;\n      var u8array = new Array(len);\n      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n      if (dontAddNull) u8array.length = numBytesWritten;\n      return u8array;\n    };\n  var FS_stdin_getChar = () => {\n      if (!FS_stdin_getChar_buffer.length) {\n        var result = null;\n        if (ENVIRONMENT_IS_NODE) {\n          // we will read data by chunks of BUFSIZE\n          var BUFSIZE = 256;\n          var buf = Buffer.alloc(BUFSIZE);\n          var bytesRead = 0;\n  \n          // For some reason we must suppress a closure warning here, even though\n          // fd definitely exists on process.stdin, and is even the proper way to\n          // get the fd of stdin,\n          // https://github.com/nodejs/help/issues/2136#issuecomment-523649904\n          // This started to happen after moving this logic out of library_tty.js,\n          // so it is related to the surrounding code in some unclear manner.\n          /** @suppress {missingProperties} */\n          var fd = process.stdin.fd;\n  \n          try {\n            bytesRead = fs.readSync(fd, buf, 0, BUFSIZE);\n          } catch(e) {\n            // Cross-platform differences: on Windows, reading EOF throws an\n            // exception, but on other OSes, reading EOF returns 0. Uniformize\n            // behavior by treating the EOF exception to return 0.\n            if (e.toString().includes('EOF')) bytesRead = 0;\n            else throw e;\n          }\n  \n          if (bytesRead > 0) {\n            result = buf.slice(0, bytesRead).toString('utf-8');\n          }\n        } else\n        if (globalThis.window?.prompt) {\n          // Browser.\n          result = window.prompt('Input: ');  // returns null on cancel\n          if (result !== null) {\n            result += '\\n';\n          }\n        } else\n        {}\n        if (!result) {\n          return null;\n        }\n        FS_stdin_getChar_buffer = intArrayFromString(result, true);\n      }\n      return FS_stdin_getChar_buffer.shift();\n    };\n  var TTY = {\n  ttys:[],\n  init() {\n        // https://github.com/emscripten-core/emscripten/pull/1555\n        // if (ENVIRONMENT_IS_NODE) {\n        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY\n        //   // device, it always assumes it's a TTY device. because of this, we're forcing\n        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible\n        //   // with text files until FS.init can be refactored.\n        //   process.stdin.setEncoding('utf8');\n        // }\n      },\n  shutdown() {\n        // https://github.com/emscripten-core/emscripten/pull/1555\n        // if (ENVIRONMENT_IS_NODE) {\n        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?\n        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation\n        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?\n        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle\n        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call\n        //   process.stdin.pause();\n        // }\n      },\n  register(dev, ops) {\n        TTY.ttys[dev] = { input: [], output: [], ops: ops };\n        FS.registerDevice(dev, TTY.stream_ops);\n      },\n  stream_ops:{\n  open(stream) {\n          var tty = TTY.ttys[stream.node.rdev];\n          if (!tty) {\n            throw new FS.ErrnoError(43);\n          }\n          stream.tty = tty;\n          stream.seekable = false;\n        },\n  close(stream) {\n          // flush any pending line data\n          stream.tty.ops.fsync(stream.tty);\n        },\n  fsync(stream) {\n          stream.tty.ops.fsync(stream.tty);\n        },\n  read(stream, buffer, offset, length, pos /* ignored */) {\n          if (!stream.tty || !stream.tty.ops.get_char) {\n            throw new FS.ErrnoError(60);\n          }\n          var bytesRead = 0;\n          for (var i = 0; i < length; i++) {\n            var result;\n            try {\n              result = stream.tty.ops.get_char(stream.tty);\n            } catch (e) {\n              throw new FS.ErrnoError(29);\n            }\n            if (result === undefined && bytesRead === 0) {\n              throw new FS.ErrnoError(6);\n            }\n            if (result === null || result === undefined) break;\n            bytesRead++;\n            buffer[offset+i] = result;\n          }\n          if (bytesRead) {\n            stream.node.atime = Date.now();\n          }\n          return bytesRead;\n        },\n  write(stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.put_char) {\n            throw new FS.ErrnoError(60);\n          }\n          try {\n            for (var i = 0; i < length; i++) {\n              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);\n            }\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n          if (length) {\n            stream.node.mtime = stream.node.ctime = Date.now();\n          }\n          return i;\n        },\n  },\n  default_tty_ops:{\n  get_char(tty) {\n          return FS_stdin_getChar();\n        },\n  put_char(tty, val) {\n          if (val === null || val === 10) {\n            out(UTF8ArrayToString(tty.output));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.\n          }\n        },\n  fsync(tty) {\n          if (tty.output?.length > 0) {\n            out(UTF8ArrayToString(tty.output));\n            tty.output = [];\n          }\n        },\n  ioctl_tcgets(tty) {\n          // typical setting\n          return {\n            c_iflag: 25856,\n            c_oflag: 5,\n            c_cflag: 191,\n            c_lflag: 35387,\n            c_cc: [\n              0x03, 0x1c, 0x7f, 0x15, 0x04, 0x00, 0x01, 0x00, 0x11, 0x13, 0x1a, 0x00,\n              0x12, 0x0f, 0x17, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n            ]\n          };\n        },\n  ioctl_tcsets(tty, optional_actions, data) {\n          // currently just ignore\n          return 0;\n        },\n  ioctl_tiocgwinsz(tty) {\n          return [24, 80];\n        },\n  },\n  default_tty1_ops:{\n  put_char(tty, val) {\n          if (val === null || val === 10) {\n            err(UTF8ArrayToString(tty.output));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },\n  fsync(tty) {\n          if (tty.output?.length > 0) {\n            err(UTF8ArrayToString(tty.output));\n            tty.output = [];\n          }\n        },\n  },\n  };\n  \n  \n  var mmapAlloc = (size) => {\n      abort('internal error: mmapAlloc called but `emscripten_builtin_memalign` native symbol not exported');\n    };\n  var MEMFS = {\n  ops_table:null,\n  mount(mount) {\n        return MEMFS.createNode(null, '/', 16895, 0);\n      },\n  createNode(parent, name, mode, dev) {\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n          // no supported\n          throw new FS.ErrnoError(63);\n        }\n        MEMFS.ops_table ||= {\n          dir: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n              lookup: MEMFS.node_ops.lookup,\n              mknod: MEMFS.node_ops.mknod,\n              rename: MEMFS.node_ops.rename,\n              unlink: MEMFS.node_ops.unlink,\n              rmdir: MEMFS.node_ops.rmdir,\n              readdir: MEMFS.node_ops.readdir,\n              symlink: MEMFS.node_ops.symlink\n            },\n            stream: {\n              llseek: MEMFS.stream_ops.llseek\n            }\n          },\n          file: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr\n            },\n            stream: {\n              llseek: MEMFS.stream_ops.llseek,\n              read: MEMFS.stream_ops.read,\n              write: MEMFS.stream_ops.write,\n              mmap: MEMFS.stream_ops.mmap,\n              msync: MEMFS.stream_ops.msync\n            }\n          },\n          link: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n              readlink: MEMFS.node_ops.readlink\n            },\n            stream: {}\n          },\n          chrdev: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr\n            },\n            stream: FS.chrdev_stream_ops\n          }\n        };\n        var node = FS.createNode(parent, name, mode, dev);\n        if (FS.isDir(node.mode)) {\n          node.node_ops = MEMFS.ops_table.dir.node;\n          node.stream_ops = MEMFS.ops_table.dir.stream;\n          node.contents = {};\n        } else if (FS.isFile(node.mode)) {\n          node.node_ops = MEMFS.ops_table.file.node;\n          node.stream_ops = MEMFS.ops_table.file.stream;\n          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.\n          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred\n          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size\n          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.\n          node.contents = null; \n        } else if (FS.isLink(node.mode)) {\n          node.node_ops = MEMFS.ops_table.link.node;\n          node.stream_ops = MEMFS.ops_table.link.stream;\n        } else if (FS.isChrdev(node.mode)) {\n          node.node_ops = MEMFS.ops_table.chrdev.node;\n          node.stream_ops = MEMFS.ops_table.chrdev.stream;\n        }\n        node.atime = node.mtime = node.ctime = Date.now();\n        // add the new node to the parent\n        if (parent) {\n          parent.contents[name] = node;\n          parent.atime = parent.mtime = parent.ctime = node.atime;\n        }\n        return node;\n      },\n  getFileDataAsTypedArray(node) {\n        if (!node.contents) return new Uint8Array(0);\n        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.\n        return new Uint8Array(node.contents);\n      },\n  expandFileStorage(node, newCapacity) {\n        var prevCapacity = node.contents ? node.contents.length : 0;\n        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.\n        // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.\n        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to\n        // avoid overshooting the allocation cap by a very large margin.\n        var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);\n        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.\n        var oldContents = node.contents;\n        node.contents = new Uint8Array(newCapacity); // Allocate new storage.\n        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.\n      },\n  resizeFileStorage(node, newSize) {\n        if (node.usedBytes == newSize) return;\n        if (newSize == 0) {\n          node.contents = null; // Fully decommit when requesting a resize to zero.\n          node.usedBytes = 0;\n        } else {\n          var oldContents = node.contents;\n          node.contents = new Uint8Array(newSize); // Allocate new storage.\n          if (oldContents) {\n            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.\n          }\n          node.usedBytes = newSize;\n        }\n      },\n  node_ops:{\n  getattr(node) {\n          var attr = {};\n          // device numbers reuse inode numbers.\n          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n          attr.ino = node.id;\n          attr.mode = node.mode;\n          attr.nlink = 1;\n          attr.uid = 0;\n          attr.gid = 0;\n          attr.rdev = node.rdev;\n          if (FS.isDir(node.mode)) {\n            attr.size = 4096;\n          } else if (FS.isFile(node.mode)) {\n            attr.size = node.usedBytes;\n          } else if (FS.isLink(node.mode)) {\n            attr.size = node.link.length;\n          } else {\n            attr.size = 0;\n          }\n          attr.atime = new Date(node.atime);\n          attr.mtime = new Date(node.mtime);\n          attr.ctime = new Date(node.ctime);\n          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),\n          //       but this is not required by the standard.\n          attr.blksize = 4096;\n          attr.blocks = Math.ceil(attr.size / attr.blksize);\n          return attr;\n        },\n  setattr(node, attr) {\n          for (const key of [\"mode\", \"atime\", \"mtime\", \"ctime\"]) {\n            if (attr[key] != null) {\n              node[key] = attr[key];\n            }\n          }\n          if (attr.size !== undefined) {\n            MEMFS.resizeFileStorage(node, attr.size);\n          }\n        },\n  lookup(parent, name) {\n          throw new FS.ErrnoError(44);\n        },\n  mknod(parent, name, mode, dev) {\n          return MEMFS.createNode(parent, name, mode, dev);\n        },\n  rename(old_node, new_dir, new_name) {\n          var new_node;\n          try {\n            new_node = FS.lookupNode(new_dir, new_name);\n          } catch (e) {}\n          if (new_node) {\n            if (FS.isDir(old_node.mode)) {\n              // if we're overwriting a directory at new_name, make sure it's empty.\n              for (var i in new_node.contents) {\n                throw new FS.ErrnoError(55);\n              }\n            }\n            FS.hashRemoveNode(new_node);\n          }\n          // do the internal rewiring\n          delete old_node.parent.contents[old_node.name];\n          new_dir.contents[new_name] = old_node;\n          old_node.name = new_name;\n          new_dir.ctime = new_dir.mtime = old_node.parent.ctime = old_node.parent.mtime = Date.now();\n        },\n  unlink(parent, name) {\n          delete parent.contents[name];\n          parent.ctime = parent.mtime = Date.now();\n        },\n  rmdir(parent, name) {\n          var node = FS.lookupNode(parent, name);\n          for (var i in node.contents) {\n            throw new FS.ErrnoError(55);\n          }\n          delete parent.contents[name];\n          parent.ctime = parent.mtime = Date.now();\n        },\n  readdir(node) {\n          return ['.', '..', ...Object.keys(node.contents)];\n        },\n  symlink(parent, newname, oldpath) {\n          var node = MEMFS.createNode(parent, newname, 0o777 | 40960, 0);\n          node.link = oldpath;\n          return node;\n        },\n  readlink(node) {\n          if (!FS.isLink(node.mode)) {\n            throw new FS.ErrnoError(28);\n          }\n          return node.link;\n        },\n  },\n  stream_ops:{\n  read(stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= stream.node.usedBytes) return 0;\n          var size = Math.min(stream.node.usedBytes - position, length);\n          assert(size >= 0);\n          if (size > 8 && contents.subarray) { // non-trivial, and typed array\n            buffer.set(contents.subarray(position, position + size), offset);\n          } else {\n            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\n          }\n          return size;\n        },\n  write(stream, buffer, offset, length, position, canOwn) {\n          // The data buffer should be a typed array view\n          assert(!(buffer instanceof ArrayBuffer));\n  \n          if (!length) return 0;\n          var node = stream.node;\n          node.mtime = node.ctime = Date.now();\n  \n          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?\n            if (canOwn) {\n              assert(position === 0, 'canOwn must imply no weird position inside the file');\n              node.contents = buffer.subarray(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.\n              node.contents = buffer.slice(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?\n              node.contents.set(buffer.subarray(offset, offset + length), position);\n              return length;\n            }\n          }\n  \n          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.\n          MEMFS.expandFileStorage(node, position+length);\n          if (node.contents.subarray && buffer.subarray) {\n            // Use typed array write which is available.\n            node.contents.set(buffer.subarray(offset, offset + length), position);\n          } else {\n            for (var i = 0; i < length; i++) {\n             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.\n            }\n          }\n          node.usedBytes = Math.max(node.usedBytes, position + length);\n          return length;\n        },\n  llseek(stream, offset, whence) {\n          var position = offset;\n          if (whence === 1) {\n            position += stream.position;\n          } else if (whence === 2) {\n            if (FS.isFile(stream.node.mode)) {\n              position += stream.node.usedBytes;\n            }\n          }\n          if (position < 0) {\n            throw new FS.ErrnoError(28);\n          }\n          return position;\n        },\n  mmap(stream, length, position, prot, flags) {\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(43);\n          }\n          var ptr;\n          var allocated;\n          var contents = stream.node.contents;\n          // Only make a new copy when MAP_PRIVATE is specified.\n          if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {\n            // We can't emulate MAP_SHARED when the file is not backed by the\n            // buffer we're mapping to (e.g. the HEAP buffer).\n            allocated = false;\n            ptr = contents.byteOffset;\n          } else {\n            allocated = true;\n            ptr = mmapAlloc(length);\n            if (!ptr) {\n              throw new FS.ErrnoError(48);\n            }\n            if (contents) {\n              // Try to avoid unnecessary slices.\n              if (position > 0 || position + length < contents.length) {\n                if (contents.subarray) {\n                  contents = contents.subarray(position, position + length);\n                } else {\n                  contents = Array.prototype.slice.call(contents, position, position + length);\n                }\n              }\n              HEAP8.set(contents, ptr);\n            }\n          }\n          return { ptr, allocated };\n        },\n  msync(stream, buffer, offset, length, mmapFlags) {\n          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n          // should we check if bytesWritten and length are the same?\n          return 0;\n        },\n  },\n  };\n  \n  var FS_modeStringToFlags = (str) => {\n      var flagModes = {\n        'r': 0,\n        'r+': 2,\n        'w': 512 | 64 | 1,\n        'w+': 512 | 64 | 2,\n        'a': 1024 | 64 | 1,\n        'a+': 1024 | 64 | 2,\n      };\n      var flags = flagModes[str];\n      if (typeof flags == 'undefined') {\n        throw new Error(`Unknown file open mode: ${str}`);\n      }\n      return flags;\n    };\n  \n  var FS_getMode = (canRead, canWrite) => {\n      var mode = 0;\n      if (canRead) mode |= 292 | 73;\n      if (canWrite) mode |= 146;\n      return mode;\n    };\n  \n  \n  \n  \n  var strError = (errno) => UTF8ToString(_strerror(errno));\n  \n  var ERRNO_CODES = {\n      'EPERM': 63,\n      'ENOENT': 44,\n      'ESRCH': 71,\n      'EINTR': 27,\n      'EIO': 29,\n      'ENXIO': 60,\n      'E2BIG': 1,\n      'ENOEXEC': 45,\n      'EBADF': 8,\n      'ECHILD': 12,\n      'EAGAIN': 6,\n      'EWOULDBLOCK': 6,\n      'ENOMEM': 48,\n      'EACCES': 2,\n      'EFAULT': 21,\n      'ENOTBLK': 105,\n      'EBUSY': 10,\n      'EEXIST': 20,\n      'EXDEV': 75,\n      'ENODEV': 43,\n      'ENOTDIR': 54,\n      'EISDIR': 31,\n      'EINVAL': 28,\n      'ENFILE': 41,\n      'EMFILE': 33,\n      'ENOTTY': 59,\n      'ETXTBSY': 74,\n      'EFBIG': 22,\n      'ENOSPC': 51,\n      'ESPIPE': 70,\n      'EROFS': 69,\n      'EMLINK': 34,\n      'EPIPE': 64,\n      'EDOM': 18,\n      'ERANGE': 68,\n      'ENOMSG': 49,\n      'EIDRM': 24,\n      'ECHRNG': 106,\n      'EL2NSYNC': 156,\n      'EL3HLT': 107,\n      'EL3RST': 108,\n      'ELNRNG': 109,\n      'EUNATCH': 110,\n      'ENOCSI': 111,\n      'EL2HLT': 112,\n      'EDEADLK': 16,\n      'ENOLCK': 46,\n      'EBADE': 113,\n      'EBADR': 114,\n      'EXFULL': 115,\n      'ENOANO': 104,\n      'EBADRQC': 103,\n      'EBADSLT': 102,\n      'EDEADLOCK': 16,\n      'EBFONT': 101,\n      'ENOSTR': 100,\n      'ENODATA': 116,\n      'ETIME': 117,\n      'ENOSR': 118,\n      'ENONET': 119,\n      'ENOPKG': 120,\n      'EREMOTE': 121,\n      'ENOLINK': 47,\n      'EADV': 122,\n      'ESRMNT': 123,\n      'ECOMM': 124,\n      'EPROTO': 65,\n      'EMULTIHOP': 36,\n      'EDOTDOT': 125,\n      'EBADMSG': 9,\n      'ENOTUNIQ': 126,\n      'EBADFD': 127,\n      'EREMCHG': 128,\n      'ELIBACC': 129,\n      'ELIBBAD': 130,\n      'ELIBSCN': 131,\n      'ELIBMAX': 132,\n      'ELIBEXEC': 133,\n      'ENOSYS': 52,\n      'ENOTEMPTY': 55,\n      'ENAMETOOLONG': 37,\n      'ELOOP': 32,\n      'EOPNOTSUPP': 138,\n      'EPFNOSUPPORT': 139,\n      'ECONNRESET': 15,\n      'ENOBUFS': 42,\n      'EAFNOSUPPORT': 5,\n      'EPROTOTYPE': 67,\n      'ENOTSOCK': 57,\n      'ENOPROTOOPT': 50,\n      'ESHUTDOWN': 140,\n      'ECONNREFUSED': 14,\n      'EADDRINUSE': 3,\n      'ECONNABORTED': 13,\n      'ENETUNREACH': 40,\n      'ENETDOWN': 38,\n      'ETIMEDOUT': 73,\n      'EHOSTDOWN': 142,\n      'EHOSTUNREACH': 23,\n      'EINPROGRESS': 26,\n      'EALREADY': 7,\n      'EDESTADDRREQ': 17,\n      'EMSGSIZE': 35,\n      'EPROTONOSUPPORT': 66,\n      'ESOCKTNOSUPPORT': 137,\n      'EADDRNOTAVAIL': 4,\n      'ENETRESET': 39,\n      'EISCONN': 30,\n      'ENOTCONN': 53,\n      'ETOOMANYREFS': 141,\n      'EUSERS': 136,\n      'EDQUOT': 19,\n      'ESTALE': 72,\n      'ENOTSUP': 138,\n      'ENOMEDIUM': 148,\n      'EILSEQ': 25,\n      'EOVERFLOW': 61,\n      'ECANCELED': 11,\n      'ENOTRECOVERABLE': 56,\n      'EOWNERDEAD': 62,\n      'ESTRPIPE': 135,\n    };\n  \n  var asyncLoad = async (url) => {\n      var arrayBuffer = await readAsync(url);\n      assert(arrayBuffer, `Loading data file \"${url}\" failed (no arrayBuffer).`);\n      return new Uint8Array(arrayBuffer);\n    };\n  \n  \n  var FS_createDataFile = (...args) => FS.createDataFile(...args);\n  \n  var getUniqueRunDependency = (id) => {\n      var orig = id;\n      while (1) {\n        if (!runDependencyTracking[id]) return id;\n        id = orig + Math.random();\n      }\n    };\n  \n  \n  \n  var preloadPlugins = [];\n  var FS_handledByPreloadPlugin = async (byteArray, fullname) => {\n      // Ensure plugins are ready.\n      if (typeof Browser != 'undefined') Browser.init();\n  \n      for (var plugin of preloadPlugins) {\n        if (plugin['canHandle'](fullname)) {\n          assert(plugin['handle'].constructor.name === 'AsyncFunction', 'Filesystem plugin handlers must be async functions (See #24914)')\n          return plugin['handle'](byteArray, fullname);\n        }\n      }\n      // In no plugin handled this file then return the original/unmodified\n      // byteArray.\n      return byteArray;\n    };\n  var FS_preloadFile = async (parent, name, url, canRead, canWrite, dontCreateFile, canOwn, preFinish) => {\n      // TODO we should allow people to just pass in a complete filename instead\n      // of parent and name being that we just join them anyways\n      var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\n      var dep = getUniqueRunDependency(`cp ${fullname}`); // might have several active requests for the same fullname\n      addRunDependency(dep);\n  \n      try {\n        var byteArray = url;\n        if (typeof url == 'string') {\n          byteArray = await asyncLoad(url);\n        }\n  \n        byteArray = await FS_handledByPreloadPlugin(byteArray, fullname);\n        preFinish?.();\n        if (!dontCreateFile) {\n          FS_createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n        }\n      } finally {\n        removeRunDependency(dep);\n      }\n    };\n  var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {\n      FS_preloadFile(parent, name, url, canRead, canWrite, dontCreateFile, canOwn, preFinish).then(onload).catch(onerror);\n    };\n  var FS = {\n  root:null,\n  mounts:[],\n  devices:{\n  },\n  streams:[],\n  nextInode:1,\n  nameTable:null,\n  currentPath:\"/\",\n  initialized:false,\n  ignorePermissions:true,\n  filesystems:null,\n  syncFSRequests:0,\n  readFiles:{\n  },\n  ErrnoError:class extends Error {\n        name = 'ErrnoError';\n        // We set the `name` property to be able to identify `FS.ErrnoError`\n        // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.\n        // - when using PROXYFS, an error can come from an underlying FS\n        // as different FS objects have their own FS.ErrnoError each,\n        // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.\n        // we'll use the reliable test `err.name == \"ErrnoError\"` instead\n        constructor(errno) {\n          super(runtimeInitialized ? strError(errno) : '');\n          this.errno = errno;\n          for (var key in ERRNO_CODES) {\n            if (ERRNO_CODES[key] === errno) {\n              this.code = key;\n              break;\n            }\n          }\n        }\n      },\n  FSStream:class {\n        shared = {};\n        get object() {\n          return this.node;\n        }\n        set object(val) {\n          this.node = val;\n        }\n        get isRead() {\n          return (this.flags & 2097155) !== 1;\n        }\n        get isWrite() {\n          return (this.flags & 2097155) !== 0;\n        }\n        get isAppend() {\n          return (this.flags & 1024);\n        }\n        get flags() {\n          return this.shared.flags;\n        }\n        set flags(val) {\n          this.shared.flags = val;\n        }\n        get position() {\n          return this.shared.position;\n        }\n        set position(val) {\n          this.shared.position = val;\n        }\n      },\n  FSNode:class {\n        node_ops = {};\n        stream_ops = {};\n        readMode = 292 | 73;\n        writeMode = 146;\n        mounted = null;\n        constructor(parent, name, mode, rdev) {\n          if (!parent) {\n            parent = this;  // root node sets parent to itself\n          }\n          this.parent = parent;\n          this.mount = parent.mount;\n          this.id = FS.nextInode++;\n          this.name = name;\n          this.mode = mode;\n          this.rdev = rdev;\n          this.atime = this.mtime = this.ctime = Date.now();\n        }\n        get read() {\n          return (this.mode & this.readMode) === this.readMode;\n        }\n        set read(val) {\n          val ? this.mode |= this.readMode : this.mode &= ~this.readMode;\n        }\n        get write() {\n          return (this.mode & this.writeMode) === this.writeMode;\n        }\n        set write(val) {\n          val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;\n        }\n        get isFolder() {\n          return FS.isDir(this.mode);\n        }\n        get isDevice() {\n          return FS.isChrdev(this.mode);\n        }\n      },\n  lookupPath(path, opts = {}) {\n        if (!path) {\n          throw new FS.ErrnoError(44);\n        }\n        opts.follow_mount ??= true\n  \n        if (!PATH.isAbs(path)) {\n          path = FS.cwd() + '/' + path;\n        }\n  \n        // limit max consecutive symlinks to 40 (SYMLOOP_MAX).\n        linkloop: for (var nlinks = 0; nlinks < 40; nlinks++) {\n          // split the absolute path\n          var parts = path.split('/').filter((p) => !!p);\n  \n          // start at the root\n          var current = FS.root;\n          var current_path = '/';\n  \n          for (var i = 0; i < parts.length; i++) {\n            var islast = (i === parts.length-1);\n            if (islast && opts.parent) {\n              // stop resolving\n              break;\n            }\n  \n            if (parts[i] === '.') {\n              continue;\n            }\n  \n            if (parts[i] === '..') {\n              current_path = PATH.dirname(current_path);\n              if (FS.isRoot(current)) {\n                path = current_path + '/' + parts.slice(i + 1).join('/');\n                // We're making progress here, don't let many consecutive ..'s\n                // lead to ELOOP\n                nlinks--;\n                continue linkloop;\n              } else {\n                current = current.parent;\n              }\n              continue;\n            }\n  \n            current_path = PATH.join2(current_path, parts[i]);\n            try {\n              current = FS.lookupNode(current, parts[i]);\n            } catch (e) {\n              // if noent_okay is true, suppress a ENOENT in the last component\n              // and return an object with an undefined node. This is needed for\n              // resolving symlinks in the path when creating a file.\n              if ((e?.errno === 44) && islast && opts.noent_okay) {\n                return { path: current_path };\n              }\n              throw e;\n            }\n  \n            // jump to the mount's root node if this is a mountpoint\n            if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {\n              current = current.mounted.root;\n            }\n  \n            // by default, lookupPath will not follow a symlink if it is the final path component.\n            // setting opts.follow = true will override this behavior.\n            if (FS.isLink(current.mode) && (!islast || opts.follow)) {\n              if (!current.node_ops.readlink) {\n                throw new FS.ErrnoError(52);\n              }\n              var link = current.node_ops.readlink(current);\n              if (!PATH.isAbs(link)) {\n                link = PATH.dirname(current_path) + '/' + link;\n              }\n              path = link + '/' + parts.slice(i + 1).join('/');\n              continue linkloop;\n            }\n          }\n          return { path: current_path, node: current };\n        }\n        throw new FS.ErrnoError(32);\n      },\n  getPath(node) {\n        var path;\n        while (true) {\n          if (FS.isRoot(node)) {\n            var mount = node.mount.mountpoint;\n            if (!path) return mount;\n            return mount[mount.length-1] !== '/' ? `${mount}/${path}` : mount + path;\n          }\n          path = path ? `${node.name}/${path}` : node.name;\n          node = node.parent;\n        }\n      },\n  hashName(parentid, name) {\n        var hash = 0;\n  \n        for (var i = 0; i < name.length; i++) {\n          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;\n        }\n        return ((parentid + hash) >>> 0) % FS.nameTable.length;\n      },\n  hashAddNode(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        node.name_next = FS.nameTable[hash];\n        FS.nameTable[hash] = node;\n      },\n  hashRemoveNode(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        if (FS.nameTable[hash] === node) {\n          FS.nameTable[hash] = node.name_next;\n        } else {\n          var current = FS.nameTable[hash];\n          while (current) {\n            if (current.name_next === node) {\n              current.name_next = node.name_next;\n              break;\n            }\n            current = current.name_next;\n          }\n        }\n      },\n  lookupNode(parent, name) {\n        var errCode = FS.mayLookup(parent);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        var hash = FS.hashName(parent.id, name);\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n          var nodeName = node.name;\n          if (node.parent.id === parent.id && nodeName === name) {\n            return node;\n          }\n        }\n        // if we failed to find it in the cache, call into the VFS\n        return FS.lookup(parent, name);\n      },\n  createNode(parent, name, mode, rdev) {\n        assert(typeof parent == 'object')\n        var node = new FS.FSNode(parent, name, mode, rdev);\n  \n        FS.hashAddNode(node);\n  \n        return node;\n      },\n  destroyNode(node) {\n        FS.hashRemoveNode(node);\n      },\n  isRoot(node) {\n        return node === node.parent;\n      },\n  isMountpoint(node) {\n        return !!node.mounted;\n      },\n  isFile(mode) {\n        return (mode & 61440) === 32768;\n      },\n  isDir(mode) {\n        return (mode & 61440) === 16384;\n      },\n  isLink(mode) {\n        return (mode & 61440) === 40960;\n      },\n  isChrdev(mode) {\n        return (mode & 61440) === 8192;\n      },\n  isBlkdev(mode) {\n        return (mode & 61440) === 24576;\n      },\n  isFIFO(mode) {\n        return (mode & 61440) === 4096;\n      },\n  isSocket(mode) {\n        return (mode & 49152) === 49152;\n      },\n  flagsToPermissionString(flag) {\n        var perms = ['r', 'w', 'rw'][flag & 3];\n        if ((flag & 512)) {\n          perms += 'w';\n        }\n        return perms;\n      },\n  nodePermissions(node, perms) {\n        if (FS.ignorePermissions) {\n          return 0;\n        }\n        // return 0 if any user, group or owner bits are set.\n        if (perms.includes('r') && !(node.mode & 292)) {\n          return 2;\n        } else if (perms.includes('w') && !(node.mode & 146)) {\n          return 2;\n        } else if (perms.includes('x') && !(node.mode & 73)) {\n          return 2;\n        }\n        return 0;\n      },\n  mayLookup(dir) {\n        if (!FS.isDir(dir.mode)) return 54;\n        var errCode = FS.nodePermissions(dir, 'x');\n        if (errCode) return errCode;\n        if (!dir.node_ops.lookup) return 2;\n        return 0;\n      },\n  mayCreate(dir, name) {\n        if (!FS.isDir(dir.mode)) {\n          return 54;\n        }\n        try {\n          var node = FS.lookupNode(dir, name);\n          return 20;\n        } catch (e) {\n        }\n        return FS.nodePermissions(dir, 'wx');\n      },\n  mayDelete(dir, name, isdir) {\n        var node;\n        try {\n          node = FS.lookupNode(dir, name);\n        } catch (e) {\n          return e.errno;\n        }\n        var errCode = FS.nodePermissions(dir, 'wx');\n        if (errCode) {\n          return errCode;\n        }\n        if (isdir) {\n          if (!FS.isDir(node.mode)) {\n            return 54;\n          }\n          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n            return 10;\n          }\n        } else {\n          if (FS.isDir(node.mode)) {\n            return 31;\n          }\n        }\n        return 0;\n      },\n  mayOpen(node, flags) {\n        if (!node) {\n          return 44;\n        }\n        if (FS.isLink(node.mode)) {\n          return 32;\n        } else if (FS.isDir(node.mode)) {\n          if (FS.flagsToPermissionString(flags) !== 'r' // opening for write\n              || (flags & (512 | 64))) { // TODO: check for O_SEARCH? (== search for dir only)\n            return 31;\n          }\n        }\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n      },\n  checkOpExists(op, err) {\n        if (!op) {\n          throw new FS.ErrnoError(err);\n        }\n        return op;\n      },\n  MAX_OPEN_FDS:4096,\n  nextfd() {\n        for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {\n          if (!FS.streams[fd]) {\n            return fd;\n          }\n        }\n        throw new FS.ErrnoError(33);\n      },\n  getStreamChecked(fd) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(8);\n        }\n        return stream;\n      },\n  getStream:(fd) => FS.streams[fd],\n  createStream(stream, fd = -1) {\n        assert(fd >= -1);\n  \n        // clone it, so we can return an instance of FSStream\n        stream = Object.assign(new FS.FSStream(), stream);\n        if (fd == -1) {\n          fd = FS.nextfd();\n        }\n        stream.fd = fd;\n        FS.streams[fd] = stream;\n        return stream;\n      },\n  closeStream(fd) {\n        FS.streams[fd] = null;\n      },\n  dupStream(origStream, fd = -1) {\n        var stream = FS.createStream(origStream, fd);\n        stream.stream_ops?.dup?.(stream);\n        return stream;\n      },\n  doSetAttr(stream, node, attr) {\n        var setattr = stream?.stream_ops.setattr;\n        var arg = setattr ? stream : node;\n        setattr ??= node.node_ops.setattr;\n        FS.checkOpExists(setattr, 63)\n        setattr(arg, attr);\n      },\n  chrdev_stream_ops:{\n  open(stream) {\n          var device = FS.getDevice(stream.node.rdev);\n          // override node's stream ops with the device's\n          stream.stream_ops = device.stream_ops;\n          // forward the open call\n          stream.stream_ops.open?.(stream);\n        },\n  llseek() {\n          throw new FS.ErrnoError(70);\n        },\n  },\n  major:(dev) => ((dev) >> 8),\n  minor:(dev) => ((dev) & 0xff),\n  makedev:(ma, mi) => ((ma) << 8 | (mi)),\n  registerDevice(dev, ops) {\n        FS.devices[dev] = { stream_ops: ops };\n      },\n  getDevice:(dev) => FS.devices[dev],\n  getMounts(mount) {\n        var mounts = [];\n        var check = [mount];\n  \n        while (check.length) {\n          var m = check.pop();\n  \n          mounts.push(m);\n  \n          check.push(...m.mounts);\n        }\n  \n        return mounts;\n      },\n  syncfs(populate, callback) {\n        if (typeof populate == 'function') {\n          callback = populate;\n          populate = false;\n        }\n  \n        FS.syncFSRequests++;\n  \n        if (FS.syncFSRequests > 1) {\n          err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);\n        }\n  \n        var mounts = FS.getMounts(FS.root.mount);\n        var completed = 0;\n  \n        function doCallback(errCode) {\n          assert(FS.syncFSRequests > 0);\n          FS.syncFSRequests--;\n          return callback(errCode);\n        }\n  \n        function done(errCode) {\n          if (errCode) {\n            if (!done.errored) {\n              done.errored = true;\n              return doCallback(errCode);\n            }\n            return;\n          }\n          if (++completed >= mounts.length) {\n            doCallback(null);\n          }\n        };\n  \n        // sync all mounts\n        mounts.forEach((mount) => {\n          if (!mount.type.syncfs) {\n            return done(null);\n          }\n          mount.type.syncfs(mount, populate, done);\n        });\n      },\n  mount(type, opts, mountpoint) {\n        if (typeof type == 'string') {\n          // The filesystem was not included, and instead we have an error\n          // message stored in the variable.\n          throw type;\n        }\n        var root = mountpoint === '/';\n        var pseudo = !mountpoint;\n        var node;\n  \n        if (root && FS.root) {\n          throw new FS.ErrnoError(10);\n        } else if (!root && !pseudo) {\n          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n  \n          mountpoint = lookup.path;  // use the absolute path\n          node = lookup.node;\n  \n          if (FS.isMountpoint(node)) {\n            throw new FS.ErrnoError(10);\n          }\n  \n          if (!FS.isDir(node.mode)) {\n            throw new FS.ErrnoError(54);\n          }\n        }\n  \n        var mount = {\n          type,\n          opts,\n          mountpoint,\n          mounts: []\n        };\n  \n        // create a root node for the fs\n        var mountRoot = type.mount(mount);\n        mountRoot.mount = mount;\n        mount.root = mountRoot;\n  \n        if (root) {\n          FS.root = mountRoot;\n        } else if (node) {\n          // set as a mountpoint\n          node.mounted = mount;\n  \n          // add the new mount to the current mount's children\n          if (node.mount) {\n            node.mount.mounts.push(mount);\n          }\n        }\n  \n        return mountRoot;\n      },\n  unmount(mountpoint) {\n        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });\n  \n        if (!FS.isMountpoint(lookup.node)) {\n          throw new FS.ErrnoError(28);\n        }\n  \n        // destroy the nodes for this mount, and all its child mounts\n        var node = lookup.node;\n        var mount = node.mounted;\n        var mounts = FS.getMounts(mount);\n  \n        Object.keys(FS.nameTable).forEach((hash) => {\n          var current = FS.nameTable[hash];\n  \n          while (current) {\n            var next = current.name_next;\n  \n            if (mounts.includes(current.mount)) {\n              FS.destroyNode(current);\n            }\n  \n            current = next;\n          }\n        });\n  \n        // no longer a mountpoint\n        node.mounted = null;\n  \n        // remove this mount from the child mounts\n        var idx = node.mount.mounts.indexOf(mount);\n        assert(idx !== -1);\n        node.mount.mounts.splice(idx, 1);\n      },\n  lookup(parent, name) {\n        return parent.node_ops.lookup(parent, name);\n      },\n  mknod(path, mode, dev) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        if (!name) {\n          throw new FS.ErrnoError(28);\n        }\n        if (name === '.' || name === '..') {\n          throw new FS.ErrnoError(20);\n        }\n        var errCode = FS.mayCreate(parent, name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.mknod) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.mknod(parent, name, mode, dev);\n      },\n  statfs(path) {\n        return FS.statfsNode(FS.lookupPath(path, {follow: true}).node);\n      },\n  statfsStream(stream) {\n        // We keep a separate statfsStream function because noderawfs overrides\n        // it. In noderawfs, stream.node is sometimes null. Instead, we need to\n        // look at stream.path.\n        return FS.statfsNode(stream.node);\n      },\n  statfsNode(node) {\n        // NOTE: None of the defaults here are true. We're just returning safe and\n        //       sane values. Currently nodefs and rawfs replace these defaults,\n        //       other file systems leave them alone.\n        var rtn = {\n          bsize: 4096,\n          frsize: 4096,\n          blocks: 1e6,\n          bfree: 5e5,\n          bavail: 5e5,\n          files: FS.nextInode,\n          ffree: FS.nextInode - 1,\n          fsid: 42,\n          flags: 2,\n          namelen: 255,\n        };\n  \n        if (node.node_ops.statfs) {\n          Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root));\n        }\n        return rtn;\n      },\n  create(path, mode = 0o666) {\n        mode &= 4095;\n        mode |= 32768;\n        return FS.mknod(path, mode, 0);\n      },\n  mkdir(path, mode = 0o777) {\n        mode &= 511 | 512;\n        mode |= 16384;\n        return FS.mknod(path, mode, 0);\n      },\n  mkdirTree(path, mode) {\n        var dirs = path.split('/');\n        var d = '';\n        for (var dir of dirs) {\n          if (!dir) continue;\n          if (d || PATH.isAbs(path)) d += '/';\n          d += dir;\n          try {\n            FS.mkdir(d, mode);\n          } catch(e) {\n            if (e.errno != 20) throw e;\n          }\n        }\n      },\n  mkdev(path, mode, dev) {\n        if (typeof dev == 'undefined') {\n          dev = mode;\n          mode = 0o666;\n        }\n        mode |= 8192;\n        return FS.mknod(path, mode, dev);\n      },\n  symlink(oldpath, newpath) {\n        if (!PATH_FS.resolve(oldpath)) {\n          throw new FS.ErrnoError(44);\n        }\n        var lookup = FS.lookupPath(newpath, { parent: true });\n        var parent = lookup.node;\n        if (!parent) {\n          throw new FS.ErrnoError(44);\n        }\n        var newname = PATH.basename(newpath);\n        var errCode = FS.mayCreate(parent, newname);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.symlink) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.symlink(parent, newname, oldpath);\n      },\n  rename(old_path, new_path) {\n        var old_dirname = PATH.dirname(old_path);\n        var new_dirname = PATH.dirname(new_path);\n        var old_name = PATH.basename(old_path);\n        var new_name = PATH.basename(new_path);\n        // parents must exist\n        var lookup, old_dir, new_dir;\n  \n        // let the errors from non existent directories percolate up\n        lookup = FS.lookupPath(old_path, { parent: true });\n        old_dir = lookup.node;\n        lookup = FS.lookupPath(new_path, { parent: true });\n        new_dir = lookup.node;\n  \n        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\n        // need to be part of the same mount\n        if (old_dir.mount !== new_dir.mount) {\n          throw new FS.ErrnoError(75);\n        }\n        // source must exist\n        var old_node = FS.lookupNode(old_dir, old_name);\n        // old path should not be an ancestor of the new path\n        var relative = PATH_FS.relative(old_path, new_dirname);\n        if (relative.charAt(0) !== '.') {\n          throw new FS.ErrnoError(28);\n        }\n        // new path should not be an ancestor of the old path\n        relative = PATH_FS.relative(new_path, old_dirname);\n        if (relative.charAt(0) !== '.') {\n          throw new FS.ErrnoError(55);\n        }\n        // see if the new path already exists\n        var new_node;\n        try {\n          new_node = FS.lookupNode(new_dir, new_name);\n        } catch (e) {\n          // not fatal\n        }\n        // early out if nothing needs to change\n        if (old_node === new_node) {\n          return;\n        }\n        // we'll need to delete the old entry\n        var isdir = FS.isDir(old_node.mode);\n        var errCode = FS.mayDelete(old_dir, old_name, isdir);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        // need delete permissions if we'll be overwriting.\n        // need create permissions if new doesn't already exist.\n        errCode = new_node ?\n          FS.mayDelete(new_dir, new_name, isdir) :\n          FS.mayCreate(new_dir, new_name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!old_dir.node_ops.rename) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {\n          throw new FS.ErrnoError(10);\n        }\n        // if we are going to change the parent, check write permissions\n        if (new_dir !== old_dir) {\n          errCode = FS.nodePermissions(old_dir, 'w');\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n        // remove the node from the lookup hash\n        FS.hashRemoveNode(old_node);\n        // do the underlying fs rename\n        try {\n          old_dir.node_ops.rename(old_node, new_dir, new_name);\n          // update old node (we do this here to avoid each backend\n          // needing to)\n          old_node.parent = new_dir;\n        } catch (e) {\n          throw e;\n        } finally {\n          // add the node back to the hash (in case node_ops.rename\n          // changed its name)\n          FS.hashAddNode(old_node);\n        }\n      },\n  rmdir(path) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, true);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.rmdir) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        parent.node_ops.rmdir(parent, name);\n        FS.destroyNode(node);\n      },\n  readdir(path) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        var node = lookup.node;\n        var readdir = FS.checkOpExists(node.node_ops.readdir, 54);\n        return readdir(node);\n      },\n  unlink(path) {\n        var lookup = FS.lookupPath(path, { parent: true });\n        var parent = lookup.node;\n        if (!parent) {\n          throw new FS.ErrnoError(44);\n        }\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, false);\n        if (errCode) {\n          // According to POSIX, we should map EISDIR to EPERM, but\n          // we instead do what Linux does (and we must, as we use\n          // the musl linux libc).\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.unlink) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        parent.node_ops.unlink(parent, name);\n        FS.destroyNode(node);\n      },\n  readlink(path) {\n        var lookup = FS.lookupPath(path);\n        var link = lookup.node;\n        if (!link) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!link.node_ops.readlink) {\n          throw new FS.ErrnoError(28);\n        }\n        return link.node_ops.readlink(link);\n      },\n  stat(path, dontFollow) {\n        var lookup = FS.lookupPath(path, { follow: !dontFollow });\n        var node = lookup.node;\n        var getattr = FS.checkOpExists(node.node_ops.getattr, 63);\n        return getattr(node);\n      },\n  fstat(fd) {\n        var stream = FS.getStreamChecked(fd);\n        var node = stream.node;\n        var getattr = stream.stream_ops.getattr;\n        var arg = getattr ? stream : node;\n        getattr ??= node.node_ops.getattr;\n        FS.checkOpExists(getattr, 63)\n        return getattr(arg);\n      },\n  lstat(path) {\n        return FS.stat(path, true);\n      },\n  doChmod(stream, node, mode, dontFollow) {\n        FS.doSetAttr(stream, node, {\n          mode: (mode & 4095) | (node.mode & ~4095),\n          ctime: Date.now(),\n          dontFollow\n        });\n      },\n  chmod(path, mode, dontFollow) {\n        var node;\n        if (typeof path == 'string') {\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        FS.doChmod(null, node, mode, dontFollow);\n      },\n  lchmod(path, mode) {\n        FS.chmod(path, mode, true);\n      },\n  fchmod(fd, mode) {\n        var stream = FS.getStreamChecked(fd);\n        FS.doChmod(stream, stream.node, mode, false);\n      },\n  doChown(stream, node, dontFollow) {\n        FS.doSetAttr(stream, node, {\n          timestamp: Date.now(),\n          dontFollow\n          // we ignore the uid / gid for now\n        });\n      },\n  chown(path, uid, gid, dontFollow) {\n        var node;\n        if (typeof path == 'string') {\n          var lookup = FS.lookupPath(path, { follow: !dontFollow });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        FS.doChown(null, node, dontFollow);\n      },\n  lchown(path, uid, gid) {\n        FS.chown(path, uid, gid, true);\n      },\n  fchown(fd, uid, gid) {\n        var stream = FS.getStreamChecked(fd);\n        FS.doChown(stream, stream.node, false);\n      },\n  doTruncate(stream, node, len) {\n        if (FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!FS.isFile(node.mode)) {\n          throw new FS.ErrnoError(28);\n        }\n        var errCode = FS.nodePermissions(node, 'w');\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        FS.doSetAttr(stream, node, {\n          size: len,\n          timestamp: Date.now()\n        });\n      },\n  truncate(path, len) {\n        if (len < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        var node;\n        if (typeof path == 'string') {\n          var lookup = FS.lookupPath(path, { follow: true });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        FS.doTruncate(null, node, len);\n      },\n  ftruncate(fd, len) {\n        var stream = FS.getStreamChecked(fd);\n        if (len < 0 || (stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(28);\n        }\n        FS.doTruncate(stream, stream.node, len);\n      },\n  utime(path, atime, mtime) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        var node = lookup.node;\n        var setattr = FS.checkOpExists(node.node_ops.setattr, 63);\n        setattr(node, {\n          atime: atime,\n          mtime: mtime\n        });\n      },\n  open(path, flags, mode = 0o666) {\n        if (path === \"\") {\n          throw new FS.ErrnoError(44);\n        }\n        flags = typeof flags == 'string' ? FS_modeStringToFlags(flags) : flags;\n        if ((flags & 64)) {\n          mode = (mode & 4095) | 32768;\n        } else {\n          mode = 0;\n        }\n        var node;\n        var isDirPath;\n        if (typeof path == 'object') {\n          node = path;\n        } else {\n          isDirPath = path.endsWith(\"/\");\n          // noent_okay makes it so that if the final component of the path\n          // doesn't exist, lookupPath returns `node: undefined`. `path` will be\n          // updated to point to the target of all symlinks.\n          var lookup = FS.lookupPath(path, {\n            follow: !(flags & 131072),\n            noent_okay: true\n          });\n          node = lookup.node;\n          path = lookup.path;\n        }\n        // perhaps we need to create the node\n        var created = false;\n        if ((flags & 64)) {\n          if (node) {\n            // if O_CREAT and O_EXCL are set, error out if the node already exists\n            if ((flags & 128)) {\n              throw new FS.ErrnoError(20);\n            }\n          } else if (isDirPath) {\n            throw new FS.ErrnoError(31);\n          } else {\n            // node doesn't exist, try to create it\n            // Ignore the permission bits here to ensure we can `open` this new\n            // file below. We use chmod below the apply the permissions once the\n            // file is open.\n            node = FS.mknod(path, mode | 0o777, 0);\n            created = true;\n          }\n        }\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n        // can't truncate a device\n        if (FS.isChrdev(node.mode)) {\n          flags &= ~512;\n        }\n        // if asked only for a directory, then this must be one\n        if ((flags & 65536) && !FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n        // check permissions, if this is not a file we just created now (it is ok to\n        // create and write to a file with read-only permissions; it is read-only\n        // for later use)\n        if (!created) {\n          var errCode = FS.mayOpen(node, flags);\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n        // do truncation if necessary\n        if ((flags & 512) && !created) {\n          FS.truncate(node, 0);\n        }\n        // we've already handled these, don't pass down to the underlying vfs\n        flags &= ~(128 | 512 | 131072);\n  \n        // register the stream with the filesystem\n        var stream = FS.createStream({\n          node,\n          path: FS.getPath(node),  // we want the absolute path to the node\n          flags,\n          seekable: true,\n          position: 0,\n          stream_ops: node.stream_ops,\n          // used by the file family libc calls (fopen, fwrite, ferror, etc.)\n          ungotten: [],\n          error: false\n        });\n        // call the new stream's open function\n        if (stream.stream_ops.open) {\n          stream.stream_ops.open(stream);\n        }\n        if (created) {\n          FS.chmod(node, mode & 0o777);\n        }\n        if (Module['logReadFiles'] && !(flags & 1)) {\n          if (!(path in FS.readFiles)) {\n            FS.readFiles[path] = 1;\n          }\n        }\n        return stream;\n      },\n  close(stream) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (stream.getdents) stream.getdents = null; // free readdir state\n        try {\n          if (stream.stream_ops.close) {\n            stream.stream_ops.close(stream);\n          }\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.closeStream(stream.fd);\n        }\n        stream.fd = null;\n      },\n  isClosed(stream) {\n        return stream.fd === null;\n      },\n  llseek(stream, offset, whence) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (!stream.seekable || !stream.stream_ops.llseek) {\n          throw new FS.ErrnoError(70);\n        }\n        if (whence != 0 && whence != 1 && whence != 2) {\n          throw new FS.ErrnoError(28);\n        }\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\n        stream.ungotten = [];\n        return stream.position;\n      },\n  read(stream, buffer, offset, length, position) {\n        assert(offset >= 0);\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.read) {\n          throw new FS.ErrnoError(28);\n        }\n        var seeking = typeof position != 'undefined';\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n        if (!seeking) stream.position += bytesRead;\n        return bytesRead;\n      },\n  write(stream, buffer, offset, length, position, canOwn) {\n        assert(offset >= 0);\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.write) {\n          throw new FS.ErrnoError(28);\n        }\n        if (stream.seekable && stream.flags & 1024) {\n          // seek to the end before writing in append mode\n          FS.llseek(stream, 0, 2);\n        }\n        var seeking = typeof position != 'undefined';\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\n        if (!seeking) stream.position += bytesWritten;\n        return bytesWritten;\n      },\n  mmap(stream, length, position, prot, flags) {\n        // User requests writing to file (prot & PROT_WRITE != 0).\n        // Checking if we have permissions to write to the file unless\n        // MAP_PRIVATE flag is set. According to POSIX spec it is possible\n        // to write to file opened in read-only mode with MAP_PRIVATE flag,\n        // as all modifications will be visible only in the memory of\n        // the current process.\n        if ((prot & 2) !== 0\n            && (flags & 2) === 0\n            && (stream.flags & 2097155) !== 2) {\n          throw new FS.ErrnoError(2);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(2);\n        }\n        if (!stream.stream_ops.mmap) {\n          throw new FS.ErrnoError(43);\n        }\n        if (!length) {\n          throw new FS.ErrnoError(28);\n        }\n        return stream.stream_ops.mmap(stream, length, position, prot, flags);\n      },\n  msync(stream, buffer, offset, length, mmapFlags) {\n        assert(offset >= 0);\n        if (!stream.stream_ops.msync) {\n          return 0;\n        }\n        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n      },\n  ioctl(stream, cmd, arg) {\n        if (!stream.stream_ops.ioctl) {\n          throw new FS.ErrnoError(59);\n        }\n        return stream.stream_ops.ioctl(stream, cmd, arg);\n      },\n  readFile(path, opts = {}) {\n        opts.flags = opts.flags || 0;\n        opts.encoding = opts.encoding || 'binary';\n        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {\n          abort(`Invalid encoding type \"${opts.encoding}\"`);\n        }\n        var stream = FS.open(path, opts.flags);\n        var stat = FS.stat(path);\n        var length = stat.size;\n        var buf = new Uint8Array(length);\n        FS.read(stream, buf, 0, length, 0);\n        if (opts.encoding === 'utf8') {\n          buf = UTF8ArrayToString(buf);\n        }\n        FS.close(stream);\n        return buf;\n      },\n  writeFile(path, data, opts = {}) {\n        opts.flags = opts.flags || 577;\n        var stream = FS.open(path, opts.flags, opts.mode);\n        if (typeof data == 'string') {\n          data = new Uint8Array(intArrayFromString(data, true));\n        }\n        if (ArrayBuffer.isView(data)) {\n          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\n        } else {\n          abort('Unsupported data type');\n        }\n        FS.close(stream);\n      },\n  cwd:() => FS.currentPath,\n  chdir(path) {\n        var lookup = FS.lookupPath(path, { follow: true });\n        if (lookup.node === null) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!FS.isDir(lookup.node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n        var errCode = FS.nodePermissions(lookup.node, 'x');\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        FS.currentPath = lookup.path;\n      },\n  createDefaultDirectories() {\n        FS.mkdir('/tmp');\n        FS.mkdir('/home');\n        FS.mkdir('/home/web_user');\n      },\n  createDefaultDevices() {\n        // create /dev\n        FS.mkdir('/dev');\n        // setup /dev/null\n        FS.registerDevice(FS.makedev(1, 3), {\n          read: () => 0,\n          write: (stream, buffer, offset, length, pos) => length,\n          llseek: () => 0,\n        });\n        FS.mkdev('/dev/null', FS.makedev(1, 3));\n        // setup /dev/tty and /dev/tty1\n        // stderr needs to print output using err() rather than out()\n        // so we register a second tty just for it.\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n        FS.mkdev('/dev/tty', FS.makedev(5, 0));\n        FS.mkdev('/dev/tty1', FS.makedev(6, 0));\n        // setup /dev/[u]random\n        // use a buffer to avoid overhead of individual crypto calls per byte\n        var randomBuffer = new Uint8Array(1024), randomLeft = 0;\n        var randomByte = () => {\n          if (randomLeft === 0) {\n            randomFill(randomBuffer);\n            randomLeft = randomBuffer.byteLength;\n          }\n          return randomBuffer[--randomLeft];\n        };\n        FS.createDevice('/dev', 'random', randomByte);\n        FS.createDevice('/dev', 'urandom', randomByte);\n        // we're not going to emulate the actual shm device,\n        // just create the tmp dirs that reside in it commonly\n        FS.mkdir('/dev/shm');\n        FS.mkdir('/dev/shm/tmp');\n      },\n  createSpecialDirectories() {\n        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the\n        // name of the stream for fd 6 (see test_unistd_ttyname)\n        FS.mkdir('/proc');\n        var proc_self = FS.mkdir('/proc/self');\n        FS.mkdir('/proc/self/fd');\n        FS.mount({\n          mount() {\n            var node = FS.createNode(proc_self, 'fd', 16895, 73);\n            node.stream_ops = {\n              llseek: MEMFS.stream_ops.llseek,\n            };\n            node.node_ops = {\n              lookup(parent, name) {\n                var fd = +name;\n                var stream = FS.getStreamChecked(fd);\n                var ret = {\n                  parent: null,\n                  mount: { mountpoint: 'fake' },\n                  node_ops: { readlink: () => stream.path },\n                  id: fd + 1,\n                };\n                ret.parent = ret; // make it look like a simple root node\n                return ret;\n              },\n              readdir() {\n                return Array.from(FS.streams.entries())\n                  .filter(([k, v]) => v)\n                  .map(([k, v]) => k.toString());\n              }\n            };\n            return node;\n          }\n        }, {}, '/proc/self/fd');\n      },\n  createStandardStreams(input, output, error) {\n        // TODO deprecate the old functionality of a single\n        // input / output callback and that utilizes FS.createDevice\n        // and instead require a unique set of stream ops\n  \n        // by default, we symlink the standard streams to the\n        // default tty devices. however, if the standard streams\n        // have been overwritten we create a unique device for\n        // them instead.\n        if (input) {\n          FS.createDevice('/dev', 'stdin', input);\n        } else {\n          FS.symlink('/dev/tty', '/dev/stdin');\n        }\n        if (output) {\n          FS.createDevice('/dev', 'stdout', null, output);\n        } else {\n          FS.symlink('/dev/tty', '/dev/stdout');\n        }\n        if (error) {\n          FS.createDevice('/dev', 'stderr', null, error);\n        } else {\n          FS.symlink('/dev/tty1', '/dev/stderr');\n        }\n  \n        // open default streams for the stdin, stdout and stderr devices\n        var stdin = FS.open('/dev/stdin', 0);\n        var stdout = FS.open('/dev/stdout', 1);\n        var stderr = FS.open('/dev/stderr', 1);\n        assert(stdin.fd === 0, `invalid handle for stdin (${stdin.fd})`);\n        assert(stdout.fd === 1, `invalid handle for stdout (${stdout.fd})`);\n        assert(stderr.fd === 2, `invalid handle for stderr (${stderr.fd})`);\n      },\n  staticInit() {\n        FS.nameTable = new Array(4096);\n  \n        FS.mount(MEMFS, {}, '/');\n  \n        FS.createDefaultDirectories();\n        FS.createDefaultDevices();\n        FS.createSpecialDirectories();\n  \n        FS.filesystems = {\n          'MEMFS': MEMFS,\n        };\n      },\n  init(input, output, error) {\n        assert(!FS.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');\n        FS.initialized = true;\n  \n        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here\n        input ??= Module['stdin'];\n        output ??= Module['stdout'];\n        error ??= Module['stderr'];\n  \n        FS.createStandardStreams(input, output, error);\n      },\n  quit() {\n        FS.initialized = false;\n        // force-flush all streams, so we get musl std streams printed out\n        _fflush(0);\n        // close all of our streams\n        for (var stream of FS.streams) {\n          if (stream) {\n            FS.close(stream);\n          }\n        }\n      },\n  findObject(path, dontResolveLastLink) {\n        var ret = FS.analyzePath(path, dontResolveLastLink);\n        if (!ret.exists) {\n          return null;\n        }\n        return ret.object;\n      },\n  analyzePath(path, dontResolveLastLink) {\n        // operate from within the context of the symlink's target\n        try {\n          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n          path = lookup.path;\n        } catch (e) {\n        }\n        var ret = {\n          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,\n          parentExists: false, parentPath: null, parentObject: null\n        };\n        try {\n          var lookup = FS.lookupPath(path, { parent: true });\n          ret.parentExists = true;\n          ret.parentPath = lookup.path;\n          ret.parentObject = lookup.node;\n          ret.name = PATH.basename(path);\n          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });\n          ret.exists = true;\n          ret.path = lookup.path;\n          ret.object = lookup.node;\n          ret.name = lookup.node.name;\n          ret.isRoot = lookup.path === '/';\n        } catch (e) {\n          ret.error = e.errno;\n        };\n        return ret;\n      },\n  createPath(parent, path, canRead, canWrite) {\n        parent = typeof parent == 'string' ? parent : FS.getPath(parent);\n        var parts = path.split('/').reverse();\n        while (parts.length) {\n          var part = parts.pop();\n          if (!part) continue;\n          var current = PATH.join2(parent, part);\n          try {\n            FS.mkdir(current);\n          } catch (e) {\n            if (e.errno != 20) throw e;\n          }\n          parent = current;\n        }\n        return current;\n      },\n  createFile(parent, name, properties, canRead, canWrite) {\n        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);\n        var mode = FS_getMode(canRead, canWrite);\n        return FS.create(path, mode);\n      },\n  createDataFile(parent, name, data, canRead, canWrite, canOwn) {\n        var path = name;\n        if (parent) {\n          parent = typeof parent == 'string' ? parent : FS.getPath(parent);\n          path = name ? PATH.join2(parent, name) : parent;\n        }\n        var mode = FS_getMode(canRead, canWrite);\n        var node = FS.create(path, mode);\n        if (data) {\n          if (typeof data == 'string') {\n            var arr = new Array(data.length);\n            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\n            data = arr;\n          }\n          // make sure we can write to the file\n          FS.chmod(node, mode | 146);\n          var stream = FS.open(node, 577);\n          FS.write(stream, data, 0, data.length, 0, canOwn);\n          FS.close(stream);\n          FS.chmod(node, mode);\n        }\n      },\n  createDevice(parent, name, input, output) {\n        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);\n        var mode = FS_getMode(!!input, !!output);\n        FS.createDevice.major ??= 64;\n        var dev = FS.makedev(FS.createDevice.major++, 0);\n        // Create a fake device that a set of stream ops to emulate\n        // the old behavior.\n        FS.registerDevice(dev, {\n          open(stream) {\n            stream.seekable = false;\n          },\n          close(stream) {\n            // flush any pending line data\n            if (output?.buffer?.length) {\n              output(10);\n            }\n          },\n          read(stream, buffer, offset, length, pos /* ignored */) {\n            var bytesRead = 0;\n            for (var i = 0; i < length; i++) {\n              var result;\n              try {\n                result = input();\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n              if (result === undefined && bytesRead === 0) {\n                throw new FS.ErrnoError(6);\n              }\n              if (result === null || result === undefined) break;\n              bytesRead++;\n              buffer[offset+i] = result;\n            }\n            if (bytesRead) {\n              stream.node.atime = Date.now();\n            }\n            return bytesRead;\n          },\n          write(stream, buffer, offset, length, pos) {\n            for (var i = 0; i < length; i++) {\n              try {\n                output(buffer[offset+i]);\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n            }\n            if (length) {\n              stream.node.mtime = stream.node.ctime = Date.now();\n            }\n            return i;\n          }\n        });\n        return FS.mkdev(path, mode, dev);\n      },\n  forceLoadFile(obj) {\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n        if (globalThis.XMLHttpRequest) {\n          abort(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\n        } else { // Command-line.\n          try {\n            obj.contents = readBinary(obj.url);\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n        }\n      },\n  createLazyFile(parent, name, url, canRead, canWrite) {\n        // Lazy chunked Uint8Array (implements get and length from Uint8Array).\n        // Actual getting is abstracted away for eventual reuse.\n        class LazyUint8Array {\n          lengthKnown = false;\n          chunks = []; // Loaded chunks. Index is the chunk number\n          get(idx) {\n            if (idx > this.length-1 || idx < 0) {\n              return undefined;\n            }\n            var chunkOffset = idx % this.chunkSize;\n            var chunkNum = (idx / this.chunkSize)|0;\n            return this.getter(chunkNum)[chunkOffset];\n          }\n          setDataGetter(getter) {\n            this.getter = getter;\n          }\n          cacheLength() {\n            // Find length\n            var xhr = new XMLHttpRequest();\n            xhr.open('HEAD', url, false);\n            xhr.send(null);\n            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) abort(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n            var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\n            var header;\n            var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\n            var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\n  \n            var chunkSize = 1024*1024; // Chunk size in bytes\n  \n            if (!hasByteServing) chunkSize = datalength;\n  \n            // Function to get a range from the remote URL.\n            var doXHR = (from, to) => {\n              if (from > to) abort(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\n              if (to > datalength-1) abort(\"only \" + datalength + \" bytes available! programmer error!\");\n  \n              // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.\n              var xhr = new XMLHttpRequest();\n              xhr.open('GET', url, false);\n              if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\n  \n              // Some hints to the browser that we want binary data.\n              xhr.responseType = 'arraybuffer';\n              if (xhr.overrideMimeType) {\n                xhr.overrideMimeType('text/plain; charset=x-user-defined');\n              }\n  \n              xhr.send(null);\n              if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) abort(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n              if (xhr.response !== undefined) {\n                return new Uint8Array(/** @type{Array<number>} */(xhr.response || []));\n              }\n              return intArrayFromString(xhr.responseText || '', true);\n            };\n            var lazyArray = this;\n            lazyArray.setDataGetter((chunkNum) => {\n              var start = chunkNum * chunkSize;\n              var end = (chunkNum+1) * chunkSize - 1; // including this byte\n              end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block\n              if (typeof lazyArray.chunks[chunkNum] == 'undefined') {\n                lazyArray.chunks[chunkNum] = doXHR(start, end);\n              }\n              if (typeof lazyArray.chunks[chunkNum] == 'undefined') abort('doXHR failed!');\n              return lazyArray.chunks[chunkNum];\n            });\n  \n            if (usesGzip || !datalength) {\n              // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length\n              chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file\n              datalength = this.getter(0).length;\n              chunkSize = datalength;\n              out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\n            }\n  \n            this._length = datalength;\n            this._chunkSize = chunkSize;\n            this.lengthKnown = true;\n          }\n          get length() {\n            if (!this.lengthKnown) {\n              this.cacheLength();\n            }\n            return this._length;\n          }\n          get chunkSize() {\n            if (!this.lengthKnown) {\n              this.cacheLength();\n            }\n            return this._chunkSize;\n          }\n        }\n  \n        if (globalThis.XMLHttpRequest) {\n          if (!ENVIRONMENT_IS_WORKER) abort('Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc');\n          var lazyArray = new LazyUint8Array();\n          var properties = { isDevice: false, contents: lazyArray };\n        } else {\n          var properties = { isDevice: false, url: url };\n        }\n  \n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\n        // This is a total hack, but I want to get this lazy file code out of the\n        // core of MEMFS. If we want to keep this lazy file concept I feel it should\n        // be its own thin LAZYFS proxying calls to MEMFS.\n        if (properties.contents) {\n          node.contents = properties.contents;\n        } else if (properties.url) {\n          node.contents = null;\n          node.url = properties.url;\n        }\n        // Add a function that defers querying the file size until it is asked the first time.\n        Object.defineProperties(node, {\n          usedBytes: {\n            get: function() { return this.contents.length; }\n          }\n        });\n        // override each stream op with one that tries to force load the lazy file first\n        var stream_ops = {};\n        var keys = Object.keys(node.stream_ops);\n        keys.forEach((key) => {\n          var fn = node.stream_ops[key];\n          stream_ops[key] = (...args) => {\n            FS.forceLoadFile(node);\n            return fn(...args);\n          };\n        });\n        function writeChunks(stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= contents.length)\n            return 0;\n          var size = Math.min(contents.length - position, length);\n          assert(size >= 0);\n          if (contents.slice) { // normal array\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents[position + i];\n            }\n          } else {\n            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR\n              buffer[offset + i] = contents.get(position + i);\n            }\n          }\n          return size;\n        }\n        // use a custom read function\n        stream_ops.read = (stream, buffer, offset, length, position) => {\n          FS.forceLoadFile(node);\n          return writeChunks(stream, buffer, offset, length, position)\n        };\n        // use a custom mmap function\n        stream_ops.mmap = (stream, length, position, prot, flags) => {\n          FS.forceLoadFile(node);\n          var ptr = mmapAlloc(length);\n          if (!ptr) {\n            throw new FS.ErrnoError(48);\n          }\n          writeChunks(stream, HEAP8, ptr, length, position);\n          return { ptr, allocated: true };\n        };\n        node.stream_ops = stream_ops;\n        return node;\n      },\n  absolutePath() {\n        abort('FS.absolutePath has been removed; use PATH_FS.resolve instead');\n      },\n  createFolder() {\n        abort('FS.createFolder has been removed; use FS.mkdir instead');\n      },\n  createLink() {\n        abort('FS.createLink has been removed; use FS.symlink instead');\n      },\n  joinPath() {\n        abort('FS.joinPath has been removed; use PATH.join instead');\n      },\n  mmapAlloc() {\n        abort('FS.mmapAlloc has been replaced by the top level function mmapAlloc');\n      },\n  standardizePath() {\n        abort('FS.standardizePath has been removed; use PATH.normalize instead');\n      },\n  };\n  \n  var SYSCALLS = {\n  DEFAULT_POLLMASK:5,\n  calculateAt(dirfd, path, allowEmpty) {\n        if (PATH.isAbs(path)) {\n          return path;\n        }\n        // relative path\n        var dir;\n        if (dirfd === -100) {\n          dir = FS.cwd();\n        } else {\n          var dirstream = SYSCALLS.getStreamFromFD(dirfd);\n          dir = dirstream.path;\n        }\n        if (path.length == 0) {\n          if (!allowEmpty) {\n            throw new FS.ErrnoError(44);// removed by dead control flow\n\n          }\n          return dir;\n        }\n        return dir + '/' + path;\n      },\n  writeStat(buf, stat) {\n        HEAPU32[((buf)>>2)] = stat.dev;\n        HEAPU32[(((buf)+(4))>>2)] = stat.mode;\n        HEAPU32[(((buf)+(8))>>2)] = stat.nlink;\n        HEAPU32[(((buf)+(12))>>2)] = stat.uid;\n        HEAPU32[(((buf)+(16))>>2)] = stat.gid;\n        HEAPU32[(((buf)+(20))>>2)] = stat.rdev;\n        HEAP64[(((buf)+(24))>>3)] = BigInt(stat.size);\n        HEAP32[(((buf)+(32))>>2)] = 4096;\n        HEAP32[(((buf)+(36))>>2)] = stat.blocks;\n        var atime = stat.atime.getTime();\n        var mtime = stat.mtime.getTime();\n        var ctime = stat.ctime.getTime();\n        HEAP64[(((buf)+(40))>>3)] = BigInt(Math.floor(atime / 1000));\n        HEAPU32[(((buf)+(48))>>2)] = (atime % 1000) * 1000 * 1000;\n        HEAP64[(((buf)+(56))>>3)] = BigInt(Math.floor(mtime / 1000));\n        HEAPU32[(((buf)+(64))>>2)] = (mtime % 1000) * 1000 * 1000;\n        HEAP64[(((buf)+(72))>>3)] = BigInt(Math.floor(ctime / 1000));\n        HEAPU32[(((buf)+(80))>>2)] = (ctime % 1000) * 1000 * 1000;\n        HEAP64[(((buf)+(88))>>3)] = BigInt(stat.ino);\n        return 0;\n      },\n  writeStatFs(buf, stats) {\n        HEAPU32[(((buf)+(4))>>2)] = stats.bsize;\n        HEAPU32[(((buf)+(60))>>2)] = stats.bsize;\n        HEAP64[(((buf)+(8))>>3)] = BigInt(stats.blocks);\n        HEAP64[(((buf)+(16))>>3)] = BigInt(stats.bfree);\n        HEAP64[(((buf)+(24))>>3)] = BigInt(stats.bavail);\n        HEAP64[(((buf)+(32))>>3)] = BigInt(stats.files);\n        HEAP64[(((buf)+(40))>>3)] = BigInt(stats.ffree);\n        HEAPU32[(((buf)+(48))>>2)] = stats.fsid;\n        HEAPU32[(((buf)+(64))>>2)] = stats.flags;  // ST_NOSUID\n        HEAPU32[(((buf)+(56))>>2)] = stats.namelen;\n      },\n  doMsync(addr, stream, len, flags, offset) {\n        if (!FS.isFile(stream.node.mode)) {\n          throw new FS.ErrnoError(43);\n        }\n        if (flags & 2) {\n          // MAP_PRIVATE calls need not to be synced back to underlying fs\n          return 0;\n        }\n        var buffer = HEAPU8.slice(addr, addr + len);\n        FS.msync(stream, buffer, offset, len, flags);\n      },\n  getStreamFromFD(fd) {\n        var stream = FS.getStreamChecked(fd);\n        return stream;\n      },\n  varargs:undefined,\n  getStr(ptr) {\n        var ret = UTF8ToString(ptr);\n        return ret;\n      },\n  };\n  function ___syscall_fcntl64(fd, cmd, varargs) {\n  SYSCALLS.varargs = varargs;\n  try {\n  \n      var stream = SYSCALLS.getStreamFromFD(fd);\n      switch (cmd) {\n        case 0: {\n          var arg = syscallGetVarargI();\n          if (arg < 0) {\n            return -28;\n          }\n          while (FS.streams[arg]) {\n            arg++;\n          }\n          var newStream;\n          newStream = FS.dupStream(stream, arg);\n          return newStream.fd;\n        }\n        case 1:\n        case 2:\n          return 0;  // FD_CLOEXEC makes no sense for a single process.\n        case 3:\n          return stream.flags;\n        case 4: {\n          var arg = syscallGetVarargI();\n          stream.flags |= arg;\n          return 0;\n        }\n        case 12: {\n          var arg = syscallGetVarargP();\n          var offset = 0;\n          // We're always unlocked.\n          HEAP16[(((arg)+(offset))>>1)] = 2;\n          return 0;\n        }\n        case 13:\n        case 14:\n          // Pretend that the locking is successful. These are process-level locks,\n          // and Emscripten programs are a single process. If we supported linking a\n          // filesystem between programs, we'd need to do more here.\n          // See https://github.com/emscripten-core/emscripten/issues/23697\n          return 0;\n      }\n      return -28;\n    } catch (e) {\n    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n    return -e.errno;\n  }\n  }\n\n  \n  function ___syscall_ioctl(fd, op, varargs) {\n  SYSCALLS.varargs = varargs;\n  try {\n  \n      var stream = SYSCALLS.getStreamFromFD(fd);\n      switch (op) {\n        case 21509: {\n          if (!stream.tty) return -59;\n          return 0;\n        }\n        case 21505: {\n          if (!stream.tty) return -59;\n          if (stream.tty.ops.ioctl_tcgets) {\n            var termios = stream.tty.ops.ioctl_tcgets(stream);\n            var argp = syscallGetVarargP();\n            HEAP32[((argp)>>2)] = termios.c_iflag || 0;\n            HEAP32[(((argp)+(4))>>2)] = termios.c_oflag || 0;\n            HEAP32[(((argp)+(8))>>2)] = termios.c_cflag || 0;\n            HEAP32[(((argp)+(12))>>2)] = termios.c_lflag || 0;\n            for (var i = 0; i < 32; i++) {\n              HEAP8[(argp + i)+(17)] = termios.c_cc[i] || 0;\n            }\n            return 0;\n          }\n          return 0;\n        }\n        case 21510:\n        case 21511:\n        case 21512: {\n          if (!stream.tty) return -59;\n          return 0; // no-op, not actually adjusting terminal settings\n        }\n        case 21506:\n        case 21507:\n        case 21508: {\n          if (!stream.tty) return -59;\n          if (stream.tty.ops.ioctl_tcsets) {\n            var argp = syscallGetVarargP();\n            var c_iflag = HEAP32[((argp)>>2)];\n            var c_oflag = HEAP32[(((argp)+(4))>>2)];\n            var c_cflag = HEAP32[(((argp)+(8))>>2)];\n            var c_lflag = HEAP32[(((argp)+(12))>>2)];\n            var c_cc = []\n            for (var i = 0; i < 32; i++) {\n              c_cc.push(HEAP8[(argp + i)+(17)]);\n            }\n            return stream.tty.ops.ioctl_tcsets(stream.tty, op, { c_iflag, c_oflag, c_cflag, c_lflag, c_cc });\n          }\n          return 0; // no-op, not actually adjusting terminal settings\n        }\n        case 21519: {\n          if (!stream.tty) return -59;\n          var argp = syscallGetVarargP();\n          HEAP32[((argp)>>2)] = 0;\n          return 0;\n        }\n        case 21520: {\n          if (!stream.tty) return -59;\n          return -28; // not supported\n        }\n        case 21537:\n        case 21531: {\n          var argp = syscallGetVarargP();\n          return FS.ioctl(stream, op, argp);\n        }\n        case 21523: {\n          // TODO: in theory we should write to the winsize struct that gets\n          // passed in, but for now musl doesn't read anything on it\n          if (!stream.tty) return -59;\n          if (stream.tty.ops.ioctl_tiocgwinsz) {\n            var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);\n            var argp = syscallGetVarargP();\n            HEAP16[((argp)>>1)] = winsize[0];\n            HEAP16[(((argp)+(2))>>1)] = winsize[1];\n          }\n          return 0;\n        }\n        case 21524: {\n          // TODO: technically, this ioctl call should change the window size.\n          // but, since emscripten doesn't have any concept of a terminal window\n          // yet, we'll just silently throw it away as we do TIOCGWINSZ\n          if (!stream.tty) return -59;\n          return 0;\n        }\n        case 21515: {\n          if (!stream.tty) return -59;\n          return 0;\n        }\n        default: return -28; // not supported\n      }\n    } catch (e) {\n    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n    return -e.errno;\n  }\n  }\n\n  \n  function ___syscall_openat(dirfd, path, flags, varargs) {\n  SYSCALLS.varargs = varargs;\n  try {\n  \n      path = SYSCALLS.getStr(path);\n      path = SYSCALLS.calculateAt(dirfd, path);\n      var mode = varargs ? syscallGetVarargI() : 0;\n      return FS.open(path, flags, mode).fd;\n    } catch (e) {\n    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n    return -e.errno;\n  }\n  }\n\n  var __abort_js = () =>\n      abort('native code called abort()');\n\n  var _emscripten_err = (str) => err(UTF8ToString(str));\n\n  var maybeCStringToJsString = (cString) => {\n      // \"cString > 2\" checks if the input is a number, and isn't of the special\n      // values we accept here, EMSCRIPTEN_EVENT_TARGET_* (which map to 0, 1, 2).\n      // In other words, if cString > 2 then it's a pointer to a valid place in\n      // memory, and points to a C string.\n      return cString > 2 ? UTF8ToString(cString) : cString;\n    };\n  \n  /** @type {Object} */\n  var specialHTMLTargets = [0, typeof document != 'undefined' ? document : 0, typeof window != 'undefined' ? window : 0];\n  var findEventTarget = (target) => {\n      target = maybeCStringToJsString(target);\n      var domElement = specialHTMLTargets[target] || (typeof document != 'undefined' ? document.querySelector(target) : null);\n      return domElement;\n    };\n  \n  var getBoundingClientRect = (e) => specialHTMLTargets.indexOf(e) < 0 ? e.getBoundingClientRect() : {'left':0,'top':0};\n  var _emscripten_get_element_css_size = (target, width, height) => {\n      target = findEventTarget(target);\n      if (!target) return -4;\n  \n      var rect = getBoundingClientRect(target);\n      HEAPF64[((width)>>3)] = rect.width;\n      HEAPF64[((height)>>3)] = rect.height;\n  \n      return 0;\n    };\n\n  var abortOnCannotGrowMemory = (requestedSize) => {\n      abort(`Cannot enlarge memory arrays to size ${requestedSize} bytes (OOM). Either (1) compile with -sINITIAL_MEMORY=X with X higher than the current value ${HEAP8.length}, (2) compile with -sALLOW_MEMORY_GROWTH which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with -sABORTING_MALLOC=0`);\n    };\n  var _emscripten_resize_heap = (requestedSize) => {\n      var oldSize = HEAPU8.length;\n      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\n      requestedSize >>>= 0;\n      abortOnCannotGrowMemory(requestedSize);\n    };\n\n  var onExits = [];\n  var addOnExit = (cb) => onExits.push(cb);\n  var JSEvents = {\n  memcpy(target, src, size) {\n        HEAP8.set(HEAP8.subarray(src, src + size), target);\n      },\n  removeAllEventListeners() {\n        while (JSEvents.eventHandlers.length) {\n          JSEvents._removeHandler(JSEvents.eventHandlers.length - 1);\n        }\n        JSEvents.deferredCalls = [];\n      },\n  inEventHandler:0,\n  deferredCalls:[],\n  deferCall(targetFunction, precedence, argsList) {\n        function arraysHaveEqualContent(arrA, arrB) {\n          if (arrA.length != arrB.length) return false;\n  \n          for (var i in arrA) {\n            if (arrA[i] != arrB[i]) return false;\n          }\n          return true;\n        }\n        // Test if the given call was already queued, and if so, don't add it again.\n        for (var call of JSEvents.deferredCalls) {\n          if (call.targetFunction == targetFunction && arraysHaveEqualContent(call.argsList, argsList)) {\n            return;\n          }\n        }\n        JSEvents.deferredCalls.push({\n          targetFunction,\n          precedence,\n          argsList\n        });\n  \n        JSEvents.deferredCalls.sort((x,y) => x.precedence < y.precedence);\n      },\n  removeDeferredCalls(targetFunction) {\n        JSEvents.deferredCalls = JSEvents.deferredCalls.filter((call) => call.targetFunction != targetFunction);\n      },\n  canPerformEventHandlerRequests() {\n        if (navigator.userActivation) {\n          // Verify against transient activation status from UserActivation API\n          // whether it is possible to perform a request here without needing to defer. See\n          // https://developer.mozilla.org/en-US/docs/Web/Security/User_activation#transient_activation\n          // and https://caniuse.com/mdn-api_useractivation\n          // At the time of writing, Firefox does not support this API: https://bugzil.la/1791079\n          return navigator.userActivation.isActive;\n        }\n  \n        return JSEvents.inEventHandler && JSEvents.currentEventHandler.allowsDeferredCalls;\n      },\n  runDeferredCalls() {\n        if (!JSEvents.canPerformEventHandlerRequests()) {\n          return;\n        }\n        var deferredCalls = JSEvents.deferredCalls;\n        JSEvents.deferredCalls = [];\n        for (var call of deferredCalls) {\n          call.targetFunction(...call.argsList);\n        }\n      },\n  eventHandlers:[],\n  removeAllHandlersOnTarget:(target, eventTypeString) => {\n        for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {\n          if (JSEvents.eventHandlers[i].target == target &&\n            (!eventTypeString || eventTypeString == JSEvents.eventHandlers[i].eventTypeString)) {\n             JSEvents._removeHandler(i--);\n           }\n        }\n      },\n  _removeHandler(i) {\n        var h = JSEvents.eventHandlers[i];\n        h.target.removeEventListener(h.eventTypeString, h.eventListenerFunc, h.useCapture);\n        JSEvents.eventHandlers.splice(i, 1);\n      },\n  registerOrRemoveHandler(eventHandler) {\n        if (!eventHandler.target) {\n          err('registerOrRemoveHandler: the target element for event handler registration does not exist, when processing the following event handler registration:');\n          console.dir(eventHandler);\n          return -4;\n        }\n        if (eventHandler.callbackfunc) {\n          eventHandler.eventListenerFunc = function(event) {\n            // Increment nesting count for the event handler.\n            ++JSEvents.inEventHandler;\n            JSEvents.currentEventHandler = eventHandler;\n            // Process any old deferred calls the user has placed.\n            JSEvents.runDeferredCalls();\n            // Process the actual event, calls back to user C code handler.\n            eventHandler.handlerFunc(event);\n            // Process any new deferred calls that were placed right now from this event handler.\n            JSEvents.runDeferredCalls();\n            // Out of event handler - restore nesting count.\n            --JSEvents.inEventHandler;\n          };\n  \n          eventHandler.target.addEventListener(eventHandler.eventTypeString,\n                                               eventHandler.eventListenerFunc,\n                                               eventHandler.useCapture);\n          JSEvents.eventHandlers.push(eventHandler);\n        } else {\n          for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {\n            if (JSEvents.eventHandlers[i].target == eventHandler.target\n             && JSEvents.eventHandlers[i].eventTypeString == eventHandler.eventTypeString) {\n               JSEvents._removeHandler(i--);\n             }\n          }\n        }\n        return 0;\n      },\n  getNodeNameForTarget(target) {\n        if (!target) return '';\n        if (target == window) return '#window';\n        if (target == screen) return '#screen';\n        return target?.nodeName || '';\n      },\n  fullscreenEnabled() {\n        return document.fullscreenEnabled\n        // Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitFullscreenEnabled.\n        // TODO: If Safari at some point ships with unprefixed version, update the version check above.\n        || document.webkitFullscreenEnabled\n         ;\n      },\n  };\n  \n  \n  \n  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    };\n  \n  function getFullscreenElement() {\n      return document.fullscreenElement || document.mozFullScreenElement ||\n             document.webkitFullscreenElement || document.webkitCurrentFullScreenElement ||\n             document.msFullscreenElement;\n    }\n  var fillFullscreenChangeEventData = (eventStruct) => {\n      var fullscreenElement = getFullscreenElement();\n      var isFullscreen = !!fullscreenElement;\n      // Assigning a boolean to HEAP32 with expected type coercion.\n      /** @suppress{checkTypes} */\n      HEAP8[eventStruct] = isFullscreen;\n      HEAP8[(eventStruct)+(1)] = JSEvents.fullscreenEnabled();\n      // If transitioning to fullscreen, report info about the element that is now fullscreen.\n      // If transitioning to windowed mode, report info about the element that just was fullscreen.\n      var reportedElement = isFullscreen ? fullscreenElement : JSEvents.previousFullscreenElement;\n      var nodeName = JSEvents.getNodeNameForTarget(reportedElement);\n      var id = reportedElement?.id || '';\n      stringToUTF8(nodeName, eventStruct + 2, 128);\n      stringToUTF8(id, eventStruct + 130, 128);\n      HEAP32[(((eventStruct)+(260))>>2)] = reportedElement ? reportedElement.clientWidth : 0;\n      HEAP32[(((eventStruct)+(264))>>2)] = reportedElement ? reportedElement.clientHeight : 0;\n      HEAP32[(((eventStruct)+(268))>>2)] = screen.width;\n      HEAP32[(((eventStruct)+(272))>>2)] = screen.height;\n      if (isFullscreen) {\n        JSEvents.previousFullscreenElement = fullscreenElement;\n      }\n    };\n  \n  \n  var wasmTableMirror = [];\n  \n  \n  var getWasmTableEntry = (funcPtr) => {\n      var func = wasmTableMirror[funcPtr];\n      if (!func) {\n        /** @suppress {checkTypes} */\n        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n      }\n      /** @suppress {checkTypes} */\n      assert(wasmTable.get(funcPtr) == func, 'JavaScript-side Wasm function table mirror is out of date!');\n      return func;\n    };\n  var registerFullscreenChangeEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {\n      JSEvents.fullscreenChangeEvent ||= _malloc(276);\n  \n      var fullscreenChangeEventhandlerFunc = (e = event) => {\n        var fullscreenChangeEvent = JSEvents.fullscreenChangeEvent;\n  \n        fillFullscreenChangeEventData(fullscreenChangeEvent);\n  \n        if (getWasmTableEntry(callbackfunc)(eventTypeId, fullscreenChangeEvent, userData)) e.preventDefault();\n      };\n  \n      var eventHandler = {\n        target,\n        eventTypeString,\n        callbackfunc,\n        handlerFunc: fullscreenChangeEventhandlerFunc,\n        useCapture\n      };\n      return JSEvents.registerOrRemoveHandler(eventHandler);\n    };\n  \n  var _emscripten_set_fullscreenchange_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) => {\n      if (!JSEvents.fullscreenEnabled()) return -1;\n      target = findEventTarget(target);\n      if (!target) return -4;\n  \n      // As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.\n      registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, 19, \"webkitfullscreenchange\", targetThread);\n  \n      return registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, 19, \"fullscreenchange\", targetThread);\n    };\n\n  \n  var handleException = (e) => {\n      // Certain exception types we do not treat as errors since they are used for\n      // internal control flow.\n      // 1. ExitStatus, which is thrown by exit()\n      // 2. \"unwind\", which is thrown by emscripten_unwind_to_js_event_loop() and others\n      //    that wish to return to JS event loop.\n      if (e instanceof ExitStatus || e == 'unwind') {\n        return EXITSTATUS;\n      }\n      checkStackCookie();\n      if (e instanceof WebAssembly.RuntimeError) {\n        if (_emscripten_stack_get_current() <= 0) {\n          err('Stack overflow detected.  You can try increasing -sSTACK_SIZE (currently set to 65536)');\n        }\n      }\n      quit_(1, e);\n    };\n  \n  \n  var runtimeKeepaliveCounter = 0;\n  var keepRuntimeAlive = () => noExitRuntime || runtimeKeepaliveCounter > 0;\n  var _proc_exit = (code) => {\n      EXITSTATUS = code;\n      if (!keepRuntimeAlive()) {\n        Module['onExit']?.(code);\n        ABORT = true;\n      }\n      quit_(code, new ExitStatus(code));\n    };\n  \n  \n  /** @param {boolean|number=} implicit */\n  var exitJS = (status, implicit) => {\n      EXITSTATUS = status;\n  \n      checkUnflushedContent();\n  \n      // if exit() was called explicitly, warn the user if the runtime isn't actually being shut down\n      if (keepRuntimeAlive() && !implicit) {\n        var msg = `program exited (with status: ${status}), but keepRuntimeAlive() is set (counter=${runtimeKeepaliveCounter}) due to an async operation, so halting execution but not exiting the runtime or preventing further async execution (you can use emscripten_force_exit, if you want to force a true shutdown)`;\n        err(msg);\n      }\n  \n      _proc_exit(status);\n    };\n  var _exit = exitJS;\n  \n  \n  var maybeExit = () => {\n      if (!keepRuntimeAlive()) {\n        try {\n          _exit(EXITSTATUS);\n        } catch (e) {\n          handleException(e);\n        }\n      }\n    };\n  var callUserCallback = (func) => {\n      if (ABORT) {\n        err('user callback triggered after runtime exited or application aborted.  Ignoring.');\n        return;\n      }\n      try {\n        func();\n        maybeExit();\n      } catch (e) {\n        handleException(e);\n      }\n    };\n  \n  var _emscripten_set_main_loop_timing = (mode, value) => {\n      MainLoop.timingMode = mode;\n      MainLoop.timingValue = value;\n  \n      if (!MainLoop.func) {\n        err('emscripten_set_main_loop_timing: Cannot set timing mode for main loop since a main loop does not exist! Call emscripten_set_main_loop first to set one up.');\n        return 1; // Return non-zero on failure, can't set timing mode when there is no main loop.\n      }\n  \n      if (!MainLoop.running) {\n        \n        MainLoop.running = true;\n      }\n      if (mode == 0) {\n        MainLoop.scheduler = function MainLoop_scheduler_setTimeout() {\n          var timeUntilNextTick = Math.max(0, MainLoop.tickStartTime + value - _emscripten_get_now())|0;\n          setTimeout(MainLoop.runner, timeUntilNextTick); // doing this each time means that on exception, we stop\n        };\n        MainLoop.method = 'timeout';\n      } else if (mode == 1) {\n        MainLoop.scheduler = function MainLoop_scheduler_rAF() {\n          MainLoop.requestAnimationFrame(MainLoop.runner);\n        };\n        MainLoop.method = 'rAF';\n      } else if (mode == 2) {\n        if (!MainLoop.setImmediate) {\n          if (globalThis.setImmediate) {\n            MainLoop.setImmediate = setImmediate;\n          } else {\n            // Emulate setImmediate. (note: not a complete polyfill, we don't emulate clearImmediate() to keep code size to minimum, since not needed)\n            var setImmediates = [];\n            var emscriptenMainLoopMessageId = 'setimmediate';\n            /** @param {Event} event */\n            var MainLoop_setImmediate_messageHandler = (event) => {\n              // When called in current thread or Worker, the main loop ID is structured slightly different to accommodate for --proxy-to-worker runtime listening to Worker events,\n              // so check for both cases.\n              if (event.data === emscriptenMainLoopMessageId || event.data.target === emscriptenMainLoopMessageId) {\n                event.stopPropagation();\n                setImmediates.shift()();\n              }\n            };\n            addEventListener(\"message\", MainLoop_setImmediate_messageHandler, true);\n            MainLoop.setImmediate = /** @type{function(function(): ?, ...?): number} */((func) => {\n              setImmediates.push(func);\n              if (ENVIRONMENT_IS_WORKER) {\n                Module['setImmediates'] ??= [];\n                Module['setImmediates'].push(func);\n                postMessage({target: emscriptenMainLoopMessageId}); // In --proxy-to-worker, route the message via proxyClient.js\n              } else postMessage(emscriptenMainLoopMessageId, \"*\"); // On the main thread, can just send the message to itself.\n            });\n          }\n        }\n        MainLoop.scheduler = function MainLoop_scheduler_setImmediate() {\n          MainLoop.setImmediate(MainLoop.runner);\n        };\n        MainLoop.method = 'immediate';\n      }\n      return 0;\n    };\n  var MainLoop = {\n  running:false,\n  scheduler:null,\n  method:\"\",\n  currentlyRunningMainloop:0,\n  func:null,\n  arg:0,\n  timingMode:0,\n  timingValue:0,\n  currentFrameNumber:0,\n  queue:[],\n  preMainLoop:[],\n  postMainLoop:[],\n  pause() {\n        MainLoop.scheduler = null;\n        // Incrementing this signals the previous main loop that it's now become old, and it must return.\n        MainLoop.currentlyRunningMainloop++;\n      },\n  resume() {\n        MainLoop.currentlyRunningMainloop++;\n        var timingMode = MainLoop.timingMode;\n        var timingValue = MainLoop.timingValue;\n        var func = MainLoop.func;\n        MainLoop.func = null;\n        // do not set timing and call scheduler, we will do it on the next lines\n        setMainLoop(func, 0, false, MainLoop.arg, true);\n        _emscripten_set_main_loop_timing(timingMode, timingValue);\n        MainLoop.scheduler();\n      },\n  updateStatus() {\n        if (Module['setStatus']) {\n          var message = Module['statusMessage'] || 'Please wait...';\n          var remaining = MainLoop.remainingBlockers ?? 0;\n          var expected = MainLoop.expectedBlockers ?? 0;\n          if (remaining) {\n            if (remaining < expected) {\n              Module['setStatus'](`{message} ({expected - remaining}/{expected})`);\n            } else {\n              Module['setStatus'](message);\n            }\n          } else {\n            Module['setStatus']('');\n          }\n        }\n      },\n  init() {\n        Module['preMainLoop'] && MainLoop.preMainLoop.push(Module['preMainLoop']);\n        Module['postMainLoop'] && MainLoop.postMainLoop.push(Module['postMainLoop']);\n      },\n  runIter(func) {\n        if (ABORT) return;\n        for (var pre of MainLoop.preMainLoop) {\n          if (pre() === false) {\n            return; // |return false| skips a frame\n          }\n        }\n        callUserCallback(func);\n        for (var post of MainLoop.postMainLoop) {\n          post();\n        }\n        checkStackCookie();\n      },\n  nextRAF:0,\n  fakeRequestAnimationFrame(func) {\n        // try to keep 60fps between calls to here\n        var now = Date.now();\n        if (MainLoop.nextRAF === 0) {\n          MainLoop.nextRAF = now + 1000/60;\n        } else {\n          while (now + 2 >= MainLoop.nextRAF) { // fudge a little, to avoid timer jitter causing us to do lots of delay:0\n            MainLoop.nextRAF += 1000/60;\n          }\n        }\n        var delay = Math.max(MainLoop.nextRAF - now, 0);\n        setTimeout(func, delay);\n      },\n  requestAnimationFrame(func) {\n        if (globalThis.requestAnimationFrame) {\n          requestAnimationFrame(func);\n        } else {\n          MainLoop.fakeRequestAnimationFrame(func);\n        }\n      },\n  };\n  \n  \n  var _emscripten_get_now = () => performance.now();\n  \n  \n    /**\n     * @param {number=} arg\n     * @param {boolean=} noSetTiming\n     */\n  var setMainLoop = (iterFunc, fps, simulateInfiniteLoop, arg, noSetTiming) => {\n      assert(!MainLoop.func, 'emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters.');\n      MainLoop.func = iterFunc;\n      MainLoop.arg = arg;\n  \n      var thisMainLoopId = MainLoop.currentlyRunningMainloop;\n      function checkIsRunning() {\n        if (thisMainLoopId < MainLoop.currentlyRunningMainloop) {\n          \n          maybeExit();\n          return false;\n        }\n        return true;\n      }\n  \n      // We create the loop runner here but it is not actually running until\n      // _emscripten_set_main_loop_timing is called (which might happen a\n      // later time).  This member signifies that the current runner has not\n      // yet been started so that we can call runtimeKeepalivePush when it\n      // gets it timing set for the first time.\n      MainLoop.running = false;\n      MainLoop.runner = function MainLoop_runner() {\n        if (ABORT) return;\n        if (MainLoop.queue.length > 0) {\n          var start = Date.now();\n          var blocker = MainLoop.queue.shift();\n          blocker.func(blocker.arg);\n          if (MainLoop.remainingBlockers) {\n            var remaining = MainLoop.remainingBlockers;\n            var next = remaining%1 == 0 ? remaining-1 : Math.floor(remaining);\n            if (blocker.counted) {\n              MainLoop.remainingBlockers = next;\n            } else {\n              // not counted, but move the progress along a tiny bit\n              next = next + 0.5; // do not steal all the next one's progress\n              MainLoop.remainingBlockers = (8*remaining + next)/9;\n            }\n          }\n          MainLoop.updateStatus();\n  \n          // catches pause/resume main loop from blocker execution\n          if (!checkIsRunning()) return;\n  \n          setTimeout(MainLoop.runner, 0);\n          return;\n        }\n  \n        // catch pauses from non-main loop sources\n        if (!checkIsRunning()) return;\n  \n        // Implement very basic swap interval control\n        MainLoop.currentFrameNumber = MainLoop.currentFrameNumber + 1 | 0;\n        if (MainLoop.timingMode == 1 && MainLoop.timingValue > 1 && MainLoop.currentFrameNumber % MainLoop.timingValue != 0) {\n          // Not the scheduled time to render this frame - skip.\n          MainLoop.scheduler();\n          return;\n        } else if (MainLoop.timingMode == 0) {\n          MainLoop.tickStartTime = _emscripten_get_now();\n        }\n  \n        if (MainLoop.method === 'timeout' && Module['ctx']) {\n          warnOnce('Looks like you are rendering without using requestAnimationFrame for the main loop. You should use 0 for the frame rate in emscripten_set_main_loop in order to use requestAnimationFrame, as that can greatly improve your frame rates!');\n          MainLoop.method = ''; // just warn once per call to set main loop\n        }\n  \n        MainLoop.runIter(iterFunc);\n  \n        // catch pauses from the main loop itself\n        if (!checkIsRunning()) return;\n  \n        MainLoop.scheduler();\n      }\n  \n      if (!noSetTiming) {\n        if (fps > 0) {\n          _emscripten_set_main_loop_timing(0, 1000.0 / fps);\n        } else {\n          // Do rAF by rendering each frame (no decimating)\n          _emscripten_set_main_loop_timing(1, 1);\n        }\n  \n        MainLoop.scheduler();\n      }\n  \n      if (simulateInfiniteLoop) {\n        throw 'unwind';\n      }\n    };\n  \n  var _emscripten_set_main_loop = (func, fps, simulateInfiniteLoop) => {\n      var iterFunc = getWasmTableEntry(func);\n      setMainLoop(iterFunc, fps, simulateInfiniteLoop);\n    };\n\n  \n  \n  \n  var registerUiEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {\n      JSEvents.uiEvent ||= _malloc(36);\n  \n      target = findEventTarget(target);\n  \n      var uiEventHandlerFunc = (e = event) => {\n        if (e.target != target) {\n          // Never take ui events such as scroll via a 'bubbled' route, but always from the direct element that\n          // was targeted. Otherwise e.g. if app logs a message in response to a page scroll, the Emscripten log\n          // message box could cause to scroll, generating a new (bubbled) scroll message, causing a new log print,\n          // causing a new scroll, etc..\n          return;\n        }\n        var b = document.body; // Take document.body to a variable, Closure compiler does not outline access to it on its own.\n        if (!b) {\n          // During a page unload 'body' can be null, with \"Cannot read property 'clientWidth' of null\" being thrown\n          return;\n        }\n        var uiEvent = JSEvents.uiEvent;\n        HEAP32[((uiEvent)>>2)] = 0; // always zero for resize and scroll\n        HEAP32[(((uiEvent)+(4))>>2)] = b.clientWidth;\n        HEAP32[(((uiEvent)+(8))>>2)] = b.clientHeight;\n        HEAP32[(((uiEvent)+(12))>>2)] = innerWidth;\n        HEAP32[(((uiEvent)+(16))>>2)] = innerHeight;\n        HEAP32[(((uiEvent)+(20))>>2)] = outerWidth;\n        HEAP32[(((uiEvent)+(24))>>2)] = outerHeight;\n        HEAP32[(((uiEvent)+(28))>>2)] = pageXOffset | 0; // scroll offsets are float\n        HEAP32[(((uiEvent)+(32))>>2)] = pageYOffset | 0;\n        if (getWasmTableEntry(callbackfunc)(eventTypeId, uiEvent, userData)) e.preventDefault();\n      };\n  \n      var eventHandler = {\n        target,\n        eventTypeString,\n        callbackfunc,\n        handlerFunc: uiEventHandlerFunc,\n        useCapture\n      };\n      return JSEvents.registerOrRemoveHandler(eventHandler);\n    };\n  var _emscripten_set_resize_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) =>\n      registerUiEventCallback(target, userData, useCapture, callbackfunc, 10, \"resize\", targetThread);\n\n  \n  var fillMouseEventData = (eventStruct, e, target) => {\n      assert(eventStruct % 4 == 0);\n      HEAPF64[((eventStruct)>>3)] = e.timeStamp;\n      var idx = ((eventStruct)>>2);\n      HEAP32[idx + 2] = e.screenX;\n      HEAP32[idx + 3] = e.screenY;\n      HEAP32[idx + 4] = e.clientX;\n      HEAP32[idx + 5] = e.clientY;\n      HEAP8[eventStruct + 24] = e.ctrlKey;\n      HEAP8[eventStruct + 25] = e.shiftKey;\n      HEAP8[eventStruct + 26] = e.altKey;\n      HEAP8[eventStruct + 27] = e.metaKey;\n      HEAP16[idx*2 + 14] = e.button;\n      HEAP16[idx*2 + 15] = e.buttons;\n  \n      HEAP32[idx + 8] = e[\"movementX\"];\n  \n      HEAP32[idx + 9] = e[\"movementY\"];\n  \n      // Note: rect contains doubles (truncated to placate SAFE_HEAP, which is the same behaviour when writing to HEAP32 anyway)\n      var rect = getBoundingClientRect(target);\n      HEAP32[idx + 10] = e.clientX - (rect.left | 0);\n      HEAP32[idx + 11] = e.clientY - (rect.top  | 0);\n    };\n  \n  \n  var registerWheelEventCallback = (target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) => {\n      JSEvents.wheelEvent ||= _malloc(96);\n  \n      // The DOM Level 3 events spec event 'wheel'\n      var wheelHandlerFunc = (e = event) => {\n        var wheelEvent = JSEvents.wheelEvent;\n        fillMouseEventData(wheelEvent, e, target);\n        HEAPF64[(((wheelEvent)+(64))>>3)] = e[\"deltaX\"];\n        HEAPF64[(((wheelEvent)+(72))>>3)] = e[\"deltaY\"];\n        HEAPF64[(((wheelEvent)+(80))>>3)] = e[\"deltaZ\"];\n        HEAP32[(((wheelEvent)+(88))>>2)] = e[\"deltaMode\"];\n        if (getWasmTableEntry(callbackfunc)(eventTypeId, wheelEvent, userData)) e.preventDefault();\n      };\n  \n      var eventHandler = {\n        target,\n        allowsDeferredCalls: true,\n        eventTypeString,\n        callbackfunc,\n        handlerFunc: wheelHandlerFunc,\n        useCapture\n      };\n      return JSEvents.registerOrRemoveHandler(eventHandler);\n    };\n  \n  var _emscripten_set_wheel_callback_on_thread = (target, userData, useCapture, callbackfunc, targetThread) => {\n      target = findEventTarget(target);\n      if (!target) return -4;\n      if (typeof target.onwheel != 'undefined') {\n        return registerWheelEventCallback(target, userData, useCapture, callbackfunc, 9, \"wheel\", targetThread);\n      } else {\n        return -1;\n      }\n    };\n\n  var ENV = {\n  };\n  \n  var getExecutableName = () => thisProgram || './this.program';\n  var getEnvStrings = () => {\n      if (!getEnvStrings.strings) {\n        // Default values.\n        // Browser language detection #8751\n        var lang = ((typeof navigator == 'object' && navigator.language) || 'C').replace('-', '_') + '.UTF-8';\n        var env = {\n          'USER': 'web_user',\n          'LOGNAME': 'web_user',\n          'PATH': '/',\n          'PWD': '/',\n          'HOME': '/home/web_user',\n          'LANG': lang,\n          '_': getExecutableName()\n        };\n        // Apply the user-provided values, if any.\n        for (var x in ENV) {\n          // x is a key in ENV; if ENV[x] is undefined, that means it was\n          // explicitly set to be so. We allow user code to do that to\n          // force variables with default values to remain unset.\n          if (ENV[x] === undefined) delete env[x];\n          else env[x] = ENV[x];\n        }\n        var strings = [];\n        for (var x in env) {\n          strings.push(`${x}=${env[x]}`);\n        }\n        getEnvStrings.strings = strings;\n      }\n      return getEnvStrings.strings;\n    };\n  \n  var _environ_get = (__environ, environ_buf) => {\n      var bufSize = 0;\n      var envp = 0;\n      for (var string of getEnvStrings()) {\n        var ptr = environ_buf + bufSize;\n        HEAPU32[(((__environ)+(envp))>>2)] = ptr;\n        bufSize += stringToUTF8(string, ptr, Infinity) + 1;\n        envp += 4;\n      }\n      return 0;\n    };\n\n  \n  var _environ_sizes_get = (penviron_count, penviron_buf_size) => {\n      var strings = getEnvStrings();\n      HEAPU32[((penviron_count)>>2)] = strings.length;\n      var bufSize = 0;\n      for (var string of strings) {\n        bufSize += lengthBytesUTF8(string) + 1;\n      }\n      HEAPU32[((penviron_buf_size)>>2)] = bufSize;\n      return 0;\n    };\n\n\n  function _fd_close(fd) {\n  try {\n  \n      var stream = SYSCALLS.getStreamFromFD(fd);\n      FS.close(stream);\n      return 0;\n    } catch (e) {\n    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n    return e.errno;\n  }\n  }\n\n  /** @param {number=} offset */\n  var doReadv = (stream, iov, iovcnt, offset) => {\n      var ret = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAPU32[((iov)>>2)];\n        var len = HEAPU32[(((iov)+(4))>>2)];\n        iov += 8;\n        var curr = FS.read(stream, HEAP8, ptr, len, offset);\n        if (curr < 0) return -1;\n        ret += curr;\n        if (curr < len) break; // nothing more to read\n        if (typeof offset != 'undefined') {\n          offset += curr;\n        }\n      }\n      return ret;\n    };\n  \n  function _fd_read(fd, iov, iovcnt, pnum) {\n  try {\n  \n      var stream = SYSCALLS.getStreamFromFD(fd);\n      var num = doReadv(stream, iov, iovcnt);\n      HEAPU32[((pnum)>>2)] = num;\n      return 0;\n    } catch (e) {\n    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n    return e.errno;\n  }\n  }\n\n  \n  var INT53_MAX = 9007199254740992;\n  \n  var INT53_MIN = -9007199254740992;\n  var bigintToI53Checked = (num) => (num < INT53_MIN || num > INT53_MAX) ? NaN : Number(num);\n  function _fd_seek(fd, offset, whence, newOffset) {\n    offset = bigintToI53Checked(offset);\n  \n  \n  try {\n  \n      if (isNaN(offset)) return 61;\n      var stream = SYSCALLS.getStreamFromFD(fd);\n      FS.llseek(stream, offset, whence);\n      HEAP64[((newOffset)>>3)] = BigInt(stream.position);\n      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state\n      return 0;\n    } catch (e) {\n    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n    return e.errno;\n  }\n  // removed by dead control flow\n\n  }\n\n  /** @param {number=} offset */\n  var doWritev = (stream, iov, iovcnt, offset) => {\n      var ret = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAPU32[((iov)>>2)];\n        var len = HEAPU32[(((iov)+(4))>>2)];\n        iov += 8;\n        var curr = FS.write(stream, HEAP8, ptr, len, offset);\n        if (curr < 0) return -1;\n        ret += curr;\n        if (curr < len) {\n          // No more space to write.\n          break;\n        }\n        if (typeof offset != 'undefined') {\n          offset += curr;\n        }\n      }\n      return ret;\n    };\n  \n  function _fd_write(fd, iov, iovcnt, pnum) {\n  try {\n  \n      var stream = SYSCALLS.getStreamFromFD(fd);\n      var num = doWritev(stream, iov, iovcnt);\n      HEAPU32[((pnum)>>2)] = num;\n      return 0;\n    } catch (e) {\n    if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n    return e.errno;\n  }\n  }\n\n  var GLctx;\n  \n  var webgl_enable_ANGLE_instanced_arrays = (ctx) => {\n      // Extension available in WebGL 1 from Firefox 26 and Google Chrome 30 onwards. Core feature in WebGL 2.\n      var ext = ctx.getExtension('ANGLE_instanced_arrays');\n      // Because this extension is a core function in WebGL 2, assign the extension entry points in place of\n      // where the core functions will reside in WebGL 2. This way the calling code can call these without\n      // having to dynamically branch depending if running against WebGL 1 or WebGL 2.\n      if (ext) {\n        ctx['vertexAttribDivisor'] = (index, divisor) => ext['vertexAttribDivisorANGLE'](index, divisor);\n        ctx['drawArraysInstanced'] = (mode, first, count, primcount) => ext['drawArraysInstancedANGLE'](mode, first, count, primcount);\n        ctx['drawElementsInstanced'] = (mode, count, type, indices, primcount) => ext['drawElementsInstancedANGLE'](mode, count, type, indices, primcount);\n        return 1;\n      }\n    };\n  \n  var webgl_enable_OES_vertex_array_object = (ctx) => {\n      // Extension available in WebGL 1 from Firefox 25 and WebKit 536.28/desktop Safari 6.0.3 onwards. Core feature in WebGL 2.\n      var ext = ctx.getExtension('OES_vertex_array_object');\n      if (ext) {\n        ctx['createVertexArray'] = () => ext['createVertexArrayOES']();\n        ctx['deleteVertexArray'] = (vao) => ext['deleteVertexArrayOES'](vao);\n        ctx['bindVertexArray'] = (vao) => ext['bindVertexArrayOES'](vao);\n        ctx['isVertexArray'] = (vao) => ext['isVertexArrayOES'](vao);\n        return 1;\n      }\n    };\n  \n  var webgl_enable_WEBGL_draw_buffers = (ctx) => {\n      // Extension available in WebGL 1 from Firefox 28 onwards. Core feature in WebGL 2.\n      var ext = ctx.getExtension('WEBGL_draw_buffers');\n      if (ext) {\n        ctx['drawBuffers'] = (n, bufs) => ext['drawBuffersWEBGL'](n, bufs);\n        return 1;\n      }\n    };\n  \n  var webgl_enable_WEBGL_draw_instanced_base_vertex_base_instance = (ctx) =>\n      // Closure is expected to be allowed to minify the '.dibvbi' property, so not accessing it quoted.\n      !!(ctx.dibvbi = ctx.getExtension('WEBGL_draw_instanced_base_vertex_base_instance'));\n  \n  var webgl_enable_WEBGL_multi_draw_instanced_base_vertex_base_instance = (ctx) => {\n      // Closure is expected to be allowed to minify the '.mdibvbi' property, so not accessing it quoted.\n      return !!(ctx.mdibvbi = ctx.getExtension('WEBGL_multi_draw_instanced_base_vertex_base_instance'));\n    };\n  \n  var webgl_enable_EXT_polygon_offset_clamp = (ctx) =>\n      !!(ctx.extPolygonOffsetClamp = ctx.getExtension('EXT_polygon_offset_clamp'));\n  \n  var webgl_enable_EXT_clip_control = (ctx) =>\n      !!(ctx.extClipControl = ctx.getExtension('EXT_clip_control'));\n  \n  var webgl_enable_WEBGL_polygon_mode = (ctx) =>\n      !!(ctx.webglPolygonMode = ctx.getExtension('WEBGL_polygon_mode'));\n  \n  var webgl_enable_WEBGL_multi_draw = (ctx) =>\n      // Closure is expected to be allowed to minify the '.multiDrawWebgl' property, so not accessing it quoted.\n      !!(ctx.multiDrawWebgl = ctx.getExtension('WEBGL_multi_draw'));\n  \n  var getEmscriptenSupportedExtensions = (ctx) => {\n      // Restrict the list of advertised extensions to those that we actually\n      // support.\n      var supportedExtensions = [\n        // WebGL 1 extensions\n        'ANGLE_instanced_arrays',\n        'EXT_blend_minmax',\n        'EXT_disjoint_timer_query',\n        'EXT_frag_depth',\n        'EXT_shader_texture_lod',\n        'EXT_sRGB',\n        'OES_element_index_uint',\n        'OES_fbo_render_mipmap',\n        'OES_standard_derivatives',\n        'OES_texture_float',\n        'OES_texture_half_float',\n        'OES_texture_half_float_linear',\n        'OES_vertex_array_object',\n        'WEBGL_color_buffer_float',\n        'WEBGL_depth_texture',\n        'WEBGL_draw_buffers',\n        // WebGL 2 extensions\n        'EXT_color_buffer_float',\n        'EXT_conservative_depth',\n        'EXT_disjoint_timer_query_webgl2',\n        'EXT_texture_norm16',\n        'NV_shader_noperspective_interpolation',\n        'WEBGL_clip_cull_distance',\n        // WebGL 1 and WebGL 2 extensions\n        'EXT_clip_control',\n        'EXT_color_buffer_half_float',\n        'EXT_depth_clamp',\n        'EXT_float_blend',\n        'EXT_polygon_offset_clamp',\n        'EXT_texture_compression_bptc',\n        'EXT_texture_compression_rgtc',\n        'EXT_texture_filter_anisotropic',\n        'KHR_parallel_shader_compile',\n        'OES_texture_float_linear',\n        'WEBGL_blend_func_extended',\n        'WEBGL_compressed_texture_astc',\n        'WEBGL_compressed_texture_etc',\n        'WEBGL_compressed_texture_etc1',\n        'WEBGL_compressed_texture_s3tc',\n        'WEBGL_compressed_texture_s3tc_srgb',\n        'WEBGL_debug_renderer_info',\n        'WEBGL_debug_shaders',\n        'WEBGL_lose_context',\n        'WEBGL_multi_draw',\n        'WEBGL_polygon_mode'\n      ];\n      // .getSupportedExtensions() can return null if context is lost, so coerce to empty array.\n      return (ctx.getSupportedExtensions() || []).filter(ext => supportedExtensions.includes(ext));\n    };\n  \n  var registerPreMainLoop = (f) => {\n      // Does nothing unless $MainLoop is included/used.\n      typeof MainLoop != 'undefined' && MainLoop.preMainLoop.push(f);\n    };\n  \n  \n  var GL = {\n  counter:1,\n  buffers:[],\n  programs:[],\n  framebuffers:[],\n  renderbuffers:[],\n  textures:[],\n  shaders:[],\n  vaos:[],\n  contexts:[],\n  offscreenCanvases:{\n  },\n  queries:[],\n  samplers:[],\n  transformFeedbacks:[],\n  syncs:[],\n  byteSizeByTypeRoot:5120,\n  byteSizeByType:[1,1,2,2,4,4,4,2,3,4,8],\n  stringCache:{\n  },\n  stringiCache:{\n  },\n  unpackAlignment:4,\n  unpackRowLength:0,\n  recordError:(errorCode) => {\n        if (!GL.lastError) {\n          GL.lastError = errorCode;\n        }\n      },\n  getNewId:(table) => {\n        var ret = GL.counter++;\n        for (var i = table.length; i < ret; i++) {\n          table[i] = null;\n        }\n        // Skip over any non-null elements that might have been created by\n        // glBindBuffer.\n        while (table[ret]) {\n          ret = GL.counter++;\n        }\n        return ret;\n      },\n  genObject:(n, buffers, createFunction, objectTable\n        ) => {\n        for (var i = 0; i < n; i++) {\n          var buffer = GLctx[createFunction]();\n          var id = buffer && GL.getNewId(objectTable);\n          if (buffer) {\n            buffer.name = id;\n            objectTable[id] = buffer;\n          } else {\n            GL.recordError(0x502 /* GL_INVALID_OPERATION */);\n          }\n          HEAP32[(((buffers)+(i*4))>>2)] = id;\n        }\n      },\n  MAX_TEMP_BUFFER_SIZE:2097152,\n  numTempVertexBuffersPerSize:64,\n  log2ceilLookup:(i) => 32 - Math.clz32(i === 0 ? 0 : i - 1),\n  generateTempBuffers:(quads, context) => {\n        var largestIndex = GL.log2ceilLookup(GL.MAX_TEMP_BUFFER_SIZE);\n        context.tempVertexBufferCounters1 = [];\n        context.tempVertexBufferCounters2 = [];\n        context.tempVertexBufferCounters1.length = context.tempVertexBufferCounters2.length = largestIndex+1;\n        context.tempVertexBuffers1 = [];\n        context.tempVertexBuffers2 = [];\n        context.tempVertexBuffers1.length = context.tempVertexBuffers2.length = largestIndex+1;\n        context.tempIndexBuffers = [];\n        context.tempIndexBuffers.length = largestIndex+1;\n        for (var i = 0; i <= largestIndex; ++i) {\n          context.tempIndexBuffers[i] = null; // Created on-demand\n          context.tempVertexBufferCounters1[i] = context.tempVertexBufferCounters2[i] = 0;\n          var ringbufferLength = GL.numTempVertexBuffersPerSize;\n          context.tempVertexBuffers1[i] = [];\n          context.tempVertexBuffers2[i] = [];\n          var ringbuffer1 = context.tempVertexBuffers1[i];\n          var ringbuffer2 = context.tempVertexBuffers2[i];\n          ringbuffer1.length = ringbuffer2.length = ringbufferLength;\n          for (var j = 0; j < ringbufferLength; ++j) {\n            ringbuffer1[j] = ringbuffer2[j] = null; // Created on-demand\n          }\n        }\n  \n        if (quads) {\n          // GL_QUAD indexes can be precalculated\n          context.tempQuadIndexBuffer = GLctx.createBuffer();\n          context.GLctx.bindBuffer(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, context.tempQuadIndexBuffer);\n          var numIndexes = GL.MAX_TEMP_BUFFER_SIZE >> 1;\n          var quadIndexes = new Uint16Array(numIndexes);\n          var i = 0, v = 0;\n          while (1) {\n            quadIndexes[i++] = v;\n            if (i >= numIndexes) break;\n            quadIndexes[i++] = v+1;\n            if (i >= numIndexes) break;\n            quadIndexes[i++] = v+2;\n            if (i >= numIndexes) break;\n            quadIndexes[i++] = v;\n            if (i >= numIndexes) break;\n            quadIndexes[i++] = v+2;\n            if (i >= numIndexes) break;\n            quadIndexes[i++] = v+3;\n            if (i >= numIndexes) break;\n            v += 4;\n          }\n          context.GLctx.bufferData(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, quadIndexes, 0x88E4 /*GL_STATIC_DRAW*/);\n          context.GLctx.bindBuffer(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, null);\n        }\n      },\n  getTempVertexBuffer:(sizeBytes) => {\n        var idx = GL.log2ceilLookup(sizeBytes);\n        var ringbuffer = GL.currentContext.tempVertexBuffers1[idx];\n        var nextFreeBufferIndex = GL.currentContext.tempVertexBufferCounters1[idx];\n        GL.currentContext.tempVertexBufferCounters1[idx] = (GL.currentContext.tempVertexBufferCounters1[idx]+1) & (GL.numTempVertexBuffersPerSize-1);\n        var vbo = ringbuffer[nextFreeBufferIndex];\n        if (vbo) {\n          return vbo;\n        }\n        var prevVBO = GLctx.getParameter(0x8894 /*GL_ARRAY_BUFFER_BINDING*/);\n        ringbuffer[nextFreeBufferIndex] = GLctx.createBuffer();\n        GLctx.bindBuffer(0x8892 /*GL_ARRAY_BUFFER*/, ringbuffer[nextFreeBufferIndex]);\n        GLctx.bufferData(0x8892 /*GL_ARRAY_BUFFER*/, 1 << idx, 0x88E8 /*GL_DYNAMIC_DRAW*/);\n        GLctx.bindBuffer(0x8892 /*GL_ARRAY_BUFFER*/, prevVBO);\n        return ringbuffer[nextFreeBufferIndex];\n      },\n  getTempIndexBuffer:(sizeBytes) => {\n        var idx = GL.log2ceilLookup(sizeBytes);\n        var ibo = GL.currentContext.tempIndexBuffers[idx];\n        if (ibo) {\n          return ibo;\n        }\n        var prevIBO = GLctx.getParameter(0x8895 /*ELEMENT_ARRAY_BUFFER_BINDING*/);\n        GL.currentContext.tempIndexBuffers[idx] = GLctx.createBuffer();\n        GLctx.bindBuffer(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, GL.currentContext.tempIndexBuffers[idx]);\n        GLctx.bufferData(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, 1 << idx, 0x88E8 /*GL_DYNAMIC_DRAW*/);\n        GLctx.bindBuffer(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, prevIBO);\n        return GL.currentContext.tempIndexBuffers[idx];\n      },\n  newRenderingFrameStarted:() => {\n        if (!GL.currentContext) {\n          return;\n        }\n        var vb = GL.currentContext.tempVertexBuffers1;\n        GL.currentContext.tempVertexBuffers1 = GL.currentContext.tempVertexBuffers2;\n        GL.currentContext.tempVertexBuffers2 = vb;\n        vb = GL.currentContext.tempVertexBufferCounters1;\n        GL.currentContext.tempVertexBufferCounters1 = GL.currentContext.tempVertexBufferCounters2;\n        GL.currentContext.tempVertexBufferCounters2 = vb;\n        var largestIndex = GL.log2ceilLookup(GL.MAX_TEMP_BUFFER_SIZE);\n        for (var i = 0; i <= largestIndex; ++i) {\n          GL.currentContext.tempVertexBufferCounters1[i] = 0;\n        }\n      },\n  getSource:(shader, count, string, length) => {\n        var source = '';\n        for (var i = 0; i < count; ++i) {\n          var len = length ? HEAPU32[(((length)+(i*4))>>2)] : undefined;\n          source += UTF8ToString(HEAPU32[(((string)+(i*4))>>2)], len);\n        }\n        return source;\n      },\n  calcBufLength:(size, type, stride, count) => {\n        if (stride > 0) {\n          return count * stride;  // XXXvlad this is not exactly correct I don't think\n        }\n        var typeSize = GL.byteSizeByType[type - GL.byteSizeByTypeRoot];\n        return size * typeSize * count;\n      },\n  usedTempBuffers:[],\n  preDrawHandleClientVertexAttribBindings:(count) => {\n        GL.resetBufferBinding = false;\n  \n        // TODO: initial pass to detect ranges we need to upload, might not need\n        // an upload per attrib\n        for (var i = 0; i < GL.currentContext.maxVertexAttribs; ++i) {\n          var cb = GL.currentContext.clientBuffers[i];\n          if (!cb.clientside || !cb.enabled) continue;\n  \n          GL.resetBufferBinding = true;\n  \n          var size = GL.calcBufLength(cb.size, cb.type, cb.stride, count);\n          var buf = GL.getTempVertexBuffer(size);\n          GLctx.bindBuffer(0x8892 /*GL_ARRAY_BUFFER*/, buf);\n          GLctx.bufferSubData(0x8892 /*GL_ARRAY_BUFFER*/,\n                                   0,\n                                   HEAPU8.subarray(cb.ptr, cb.ptr + size));\n          cb.vertexAttribPointerAdaptor.call(GLctx, i, cb.size, cb.type, cb.normalized, cb.stride, 0);\n        }\n      },\n  postDrawHandleClientVertexAttribBindings:() => {\n        if (GL.resetBufferBinding) {\n          GLctx.bindBuffer(0x8892 /*GL_ARRAY_BUFFER*/, GL.buffers[GLctx.currentArrayBufferBinding]);\n        }\n      },\n  createContext:(/** @type {HTMLCanvasElement} */ canvas, webGLContextAttributes) => {\n  \n        // BUG: Workaround Safari WebGL issue: After successfully acquiring WebGL\n        // context on a canvas, calling .getContext() will always return that\n        // context independent of which 'webgl' or 'webgl2'\n        // context version was passed. See:\n        //   https://webkit.org/b/222758\n        // and:\n        //   https://github.com/emscripten-core/emscripten/issues/13295.\n        // TODO: Once the bug is fixed and shipped in Safari, adjust the Safari\n        // version field in above check.\n        if (!canvas.getContextSafariWebGL2Fixed) {\n          canvas.getContextSafariWebGL2Fixed = canvas.getContext;\n          /** @type {function(this:HTMLCanvasElement, string, (Object|null)=): (Object|null)} */\n          function fixedGetContext(ver, attrs) {\n            var gl = canvas.getContextSafariWebGL2Fixed(ver, attrs);\n            return ((ver == 'webgl') == (gl instanceof WebGLRenderingContext)) ? gl : null;\n          }\n          canvas.getContext = fixedGetContext;\n        }\n  \n        var ctx =\n          (webGLContextAttributes.majorVersion > 1)\n          ? canvas.getContext(\"webgl2\", webGLContextAttributes) :\n          canvas.getContext(\"webgl\", webGLContextAttributes);\n  \n        if (!ctx) return 0;\n  \n        var handle = GL.registerContext(ctx, webGLContextAttributes);\n  \n        return handle;\n      },\n  registerContext:(ctx, webGLContextAttributes) => {\n        // without pthreads a context is just an integer ID\n        var handle = GL.getNewId(GL.contexts);\n  \n        var context = {\n          handle,\n          attributes: webGLContextAttributes,\n          version: webGLContextAttributes.majorVersion,\n          GLctx: ctx\n        };\n  \n        // Store the created context object so that we can access the context\n        // given a canvas without having to pass the parameters again.\n        if (ctx.canvas) ctx.canvas.GLctxObject = context;\n        GL.contexts[handle] = context;\n        if (typeof webGLContextAttributes.enableExtensionsByDefault == 'undefined' || webGLContextAttributes.enableExtensionsByDefault) {\n          GL.initExtensions(context);\n        }\n  \n        context.maxVertexAttribs = context.GLctx.getParameter(0x8869 /*GL_MAX_VERTEX_ATTRIBS*/);\n        context.clientBuffers = [];\n        for (var i = 0; i < context.maxVertexAttribs; i++) {\n          context.clientBuffers[i] = {\n            enabled: false,\n            clientside: false,\n            size: 0,\n            type: 0,\n            normalized: 0,\n            stride: 0,\n            ptr: 0,\n            vertexAttribPointerAdaptor: null,\n          };\n        }\n  \n        GL.generateTempBuffers(false, context);\n  \n        return handle;\n      },\n  makeContextCurrent:(contextHandle) => {\n  \n        // Active Emscripten GL layer context object.\n        GL.currentContext = GL.contexts[contextHandle];\n        // Active WebGL context object.\n        Module['ctx'] = GLctx = GL.currentContext?.GLctx;\n        return !(contextHandle && !GLctx);\n      },\n  getContext:(contextHandle) => {\n        return GL.contexts[contextHandle];\n      },\n  deleteContext:(contextHandle) => {\n        if (GL.currentContext === GL.contexts[contextHandle]) {\n          GL.currentContext = null;\n        }\n        if (typeof JSEvents == 'object') {\n          // Release all JS event handlers on the DOM element that the GL context is\n          // associated with since the context is now deleted.\n          JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas);\n        }\n        // Make sure the canvas object no longer refers to the context object so\n        // there are no GC surprises.\n        if (GL.contexts[contextHandle]?.GLctx.canvas) {\n          GL.contexts[contextHandle].GLctx.canvas.GLctxObject = undefined;\n        }\n        GL.contexts[contextHandle] = null;\n      },\n  initExtensions:(context) => {\n        // If this function is called without a specific context object, init the\n        // extensions of the currently active context.\n        context ||= GL.currentContext;\n  \n        if (context.initExtensionsDone) return;\n        context.initExtensionsDone = true;\n  \n        var GLctx = context.GLctx;\n  \n        // Detect the presence of a few extensions manually, ction GL interop\n        // layer itself will need to know if they exist.\n  \n        // Extensions that are available in both WebGL 1 and WebGL 2\n        webgl_enable_WEBGL_multi_draw(GLctx);\n        webgl_enable_EXT_polygon_offset_clamp(GLctx);\n        webgl_enable_EXT_clip_control(GLctx);\n        webgl_enable_WEBGL_polygon_mode(GLctx);\n        // Extensions that are only available in WebGL 1 (the calls will be no-ops\n        // if called on a WebGL 2 context active)\n        webgl_enable_ANGLE_instanced_arrays(GLctx);\n        webgl_enable_OES_vertex_array_object(GLctx);\n        webgl_enable_WEBGL_draw_buffers(GLctx);\n        // Extensions that are available from WebGL >= 2 (no-op if called on a WebGL 1 context active)\n        webgl_enable_WEBGL_draw_instanced_base_vertex_base_instance(GLctx);\n        webgl_enable_WEBGL_multi_draw_instanced_base_vertex_base_instance(GLctx);\n  \n        // On WebGL 2, EXT_disjoint_timer_query is replaced with an alternative\n        // that's based on core APIs, and exposes only the queryCounterEXT()\n        // entrypoint.\n        if (context.version >= 2) {\n          GLctx.disjointTimerQueryExt = GLctx.getExtension(\"EXT_disjoint_timer_query_webgl2\");\n        }\n  \n        // However, Firefox exposes the WebGL 1 version on WebGL 2 as well and\n        // thus we look for the WebGL 1 version again if the WebGL 2 version\n        // isn't present. https://bugzil.la/1328882\n        if (context.version < 2 || !GLctx.disjointTimerQueryExt)\n        {\n          GLctx.disjointTimerQueryExt = GLctx.getExtension(\"EXT_disjoint_timer_query\");\n        }\n  \n        getEmscriptenSupportedExtensions(GLctx).forEach((ext) => {\n          // WEBGL_lose_context, WEBGL_debug_renderer_info and WEBGL_debug_shaders\n          // are not enabled by default.\n          if (!ext.includes('lose_context') && !ext.includes('debug')) {\n            // Call .getExtension() to enable that extension permanently.\n            GLctx.getExtension(ext);\n          }\n        });\n      },\n  };\n  var _emscripten_glActiveTexture = (x0) => GLctx.activeTexture(x0);\n  var _glActiveTexture = _emscripten_glActiveTexture;\n\n  var _emscripten_glAttachShader = (program, shader) => {\n      GLctx.attachShader(GL.programs[program], GL.shaders[shader]);\n    };\n  var _glAttachShader = _emscripten_glAttachShader;\n\n  var _emscripten_glBindBuffer = (target, buffer) => {\n      // Calling glBindBuffer with an unknown buffer will implicitly create a\n      // new one.  Here we bypass `GL.counter` and directly using the ID passed\n      // in.\n      if (buffer && !GL.buffers[buffer]) {\n        var b = GLctx.createBuffer();\n        b.name = buffer;\n        GL.buffers[buffer] = b;\n      }\n      if (target == 0x8892 /*GL_ARRAY_BUFFER*/) {\n        GLctx.currentArrayBufferBinding = buffer;\n      } else if (target == 0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/) {\n        GLctx.currentElementArrayBufferBinding = buffer;\n      }\n  \n      if (target == 0x88EB /*GL_PIXEL_PACK_BUFFER*/) {\n        // In WebGL 2 glReadPixels entry point, we need to use a different WebGL 2\n        // API function call when a buffer is bound to\n        // GL_PIXEL_PACK_BUFFER_BINDING point, so must keep track whether that\n        // binding point is non-null to know what is the proper API function to\n        // call.\n        GLctx.currentPixelPackBufferBinding = buffer;\n      } else if (target == 0x88EC /*GL_PIXEL_UNPACK_BUFFER*/) {\n        // In WebGL 2 gl(Compressed)Tex(Sub)Image[23]D entry points, we need to\n        // use a different WebGL 2 API function call when a buffer is bound to\n        // GL_PIXEL_UNPACK_BUFFER_BINDING point, so must keep track whether that\n        // binding point is non-null to know what is the proper API function to\n        // call.\n        GLctx.currentPixelUnpackBufferBinding = buffer;\n      }\n      GLctx.bindBuffer(target, GL.buffers[buffer]);\n    };\n  var _glBindBuffer = _emscripten_glBindBuffer;\n\n  var _emscripten_glBindTexture = (target, texture) => {\n      GLctx.bindTexture(target, GL.textures[texture]);\n    };\n  var _glBindTexture = _emscripten_glBindTexture;\n\n  var _emscripten_glBindVertexArray = (vao) => {\n      GLctx.bindVertexArray(GL.vaos[vao]);\n      var ibo = GLctx.getParameter(0x8895 /*ELEMENT_ARRAY_BUFFER_BINDING*/);\n      GLctx.currentElementArrayBufferBinding = ibo ? (ibo.name | 0) : 0;\n    };\n  var _glBindVertexArrayOES = _emscripten_glBindVertexArray;\n\n  var _emscripten_glBlendEquation = (x0) => GLctx.blendEquation(x0);\n  var _glBlendEquation = _emscripten_glBlendEquation;\n\n  var _emscripten_glBlendEquationSeparate = (x0, x1) => GLctx.blendEquationSeparate(x0, x1);\n  var _glBlendEquationSeparate = _emscripten_glBlendEquationSeparate;\n\n  var _emscripten_glBlendFuncSeparate = (x0, x1, x2, x3) => GLctx.blendFuncSeparate(x0, x1, x2, x3);\n  var _glBlendFuncSeparate = _emscripten_glBlendFuncSeparate;\n\n  var _emscripten_glBufferData = (target, size, data, usage) => {\n  \n      if (GL.currentContext.version >= 2) {\n        // If size is zero, WebGL would interpret uploading the whole input\n        // arraybuffer (starting from given offset), which would not make sense in\n        // WebAssembly, so avoid uploading if size is zero. However we must still\n        // call bufferData to establish a backing storage of zero bytes.\n        if (data && size) {\n          GLctx.bufferData(target, HEAPU8, usage, data, size);\n        } else {\n          GLctx.bufferData(target, size, usage);\n        }\n        return;\n      }\n      // N.b. here first form specifies a heap subarray, second form an integer\n      // size, so the ?: code here is polymorphic. It is advised to avoid\n      // randomly mixing both uses in calling code, to avoid any potential JS\n      // engine JIT issues.\n      GLctx.bufferData(target, data ? HEAPU8.subarray(data, data+size) : size, usage);\n    };\n  var _glBufferData = _emscripten_glBufferData;\n\n  var _emscripten_glBufferSubData = (target, offset, size, data) => {\n      if (GL.currentContext.version >= 2) {\n        size && GLctx.bufferSubData(target, offset, HEAPU8, data, size);\n        return;\n      }\n      GLctx.bufferSubData(target, offset, HEAPU8.subarray(data, data+size));\n    };\n  var _glBufferSubData = _emscripten_glBufferSubData;\n\n  var _emscripten_glClear = (x0) => GLctx.clear(x0);\n  var _glClear = _emscripten_glClear;\n\n  var _emscripten_glClearColor = (x0, x1, x2, x3) => GLctx.clearColor(x0, x1, x2, x3);\n  var _glClearColor = _emscripten_glClearColor;\n\n  var _emscripten_glCompileShader = (shader) => {\n      GLctx.compileShader(GL.shaders[shader]);\n    };\n  var _glCompileShader = _emscripten_glCompileShader;\n\n  var _emscripten_glCreateProgram = () => {\n      var id = GL.getNewId(GL.programs);\n      var program = GLctx.createProgram();\n      // Store additional information needed for each shader program:\n      program.name = id;\n      // Lazy cache results of\n      // glGetProgramiv(GL_ACTIVE_UNIFORM_MAX_LENGTH/GL_ACTIVE_ATTRIBUTE_MAX_LENGTH/GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH)\n      program.maxUniformLength = program.maxAttributeLength = program.maxUniformBlockNameLength = 0;\n      program.uniformIdCounter = 1;\n      GL.programs[id] = program;\n      return id;\n    };\n  var _glCreateProgram = _emscripten_glCreateProgram;\n\n  var _emscripten_glCreateShader = (shaderType) => {\n      var id = GL.getNewId(GL.shaders);\n      GL.shaders[id] = GLctx.createShader(shaderType);\n  \n      return id;\n    };\n  var _glCreateShader = _emscripten_glCreateShader;\n\n  var _emscripten_glDeleteBuffers = (n, buffers) => {\n      for (var i = 0; i < n; i++) {\n        var id = HEAP32[(((buffers)+(i*4))>>2)];\n        var buffer = GL.buffers[id];\n  \n        // From spec: \"glDeleteBuffers silently ignores 0's and names that do not\n        // correspond to existing buffer objects.\"\n        if (!buffer) continue;\n  \n        GLctx.deleteBuffer(buffer);\n        buffer.name = 0;\n        GL.buffers[id] = null;\n  \n        if (id == GLctx.currentArrayBufferBinding) GLctx.currentArrayBufferBinding = 0;\n        if (id == GLctx.currentElementArrayBufferBinding) GLctx.currentElementArrayBufferBinding = 0;\n        if (id == GLctx.currentPixelPackBufferBinding) GLctx.currentPixelPackBufferBinding = 0;\n        if (id == GLctx.currentPixelUnpackBufferBinding) GLctx.currentPixelUnpackBufferBinding = 0;\n      }\n    };\n  var _glDeleteBuffers = _emscripten_glDeleteBuffers;\n\n  var _emscripten_glDeleteProgram = (id) => {\n      if (!id) return;\n      var program = GL.programs[id];\n      if (!program) {\n        // glDeleteProgram actually signals an error when deleting a nonexisting\n        // object, unlike some other GL delete functions.\n        GL.recordError(0x501 /* GL_INVALID_VALUE */);\n        return;\n      }\n      GLctx.deleteProgram(program);\n      program.name = 0;\n      GL.programs[id] = null;\n    };\n  var _glDeleteProgram = _emscripten_glDeleteProgram;\n\n  var _emscripten_glDeleteShader = (id) => {\n      if (!id) return;\n      var shader = GL.shaders[id];\n      if (!shader) {\n        // glDeleteShader actually signals an error when deleting a nonexisting\n        // object, unlike some other GL delete functions.\n        GL.recordError(0x501 /* GL_INVALID_VALUE */);\n        return;\n      }\n      GLctx.deleteShader(shader);\n      GL.shaders[id] = null;\n    };\n  var _glDeleteShader = _emscripten_glDeleteShader;\n\n  var _emscripten_glDeleteTextures = (n, textures) => {\n      for (var i = 0; i < n; i++) {\n        var id = HEAP32[(((textures)+(i*4))>>2)];\n        var texture = GL.textures[id];\n        // GL spec: \"glDeleteTextures silently ignores 0s and names that do not\n        // correspond to existing textures\".\n        if (!texture) continue;\n        GLctx.deleteTexture(texture);\n        texture.name = 0;\n        GL.textures[id] = null;\n      }\n    };\n  var _glDeleteTextures = _emscripten_glDeleteTextures;\n\n  var _emscripten_glDeleteVertexArrays = (n, vaos) => {\n      for (var i = 0; i < n; i++) {\n        var id = HEAP32[(((vaos)+(i*4))>>2)];\n        GLctx.deleteVertexArray(GL.vaos[id]);\n        GL.vaos[id] = null;\n      }\n    };\n  var _glDeleteVertexArraysOES = _emscripten_glDeleteVertexArrays;\n\n  var _emscripten_glDetachShader = (program, shader) => {\n      GLctx.detachShader(GL.programs[program], GL.shaders[shader]);\n    };\n  var _glDetachShader = _emscripten_glDetachShader;\n\n  var _emscripten_glDisable = (x0) => GLctx.disable(x0);\n  var _glDisable = _emscripten_glDisable;\n\n  var _emscripten_glDrawElements = (mode, count, type, indices) => {\n      var buf;\n      var vertexes = 0;\n      if (!GLctx.currentElementArrayBufferBinding) {\n        var size = GL.calcBufLength(1, type, 0, count);\n        buf = GL.getTempIndexBuffer(size);\n        GLctx.bindBuffer(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, buf);\n        GLctx.bufferSubData(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/,\n                            0,\n                            HEAPU8.subarray(indices, indices + size));\n        \n        // Calculating vertex count if shader's attribute data is on client side\n        if (count > 0) {\n          for (var i = 0; i < GL.currentContext.maxVertexAttribs; ++i) {\n            var cb = GL.currentContext.clientBuffers[i];\n            if (cb.clientside && cb.enabled) {\n              let arrayClass;\n              switch(type) {\n                case 0x1401 /* GL_UNSIGNED_BYTE */: arrayClass = Uint8Array; break;\n                case 0x1403 /* GL_UNSIGNED_SHORT */: arrayClass = Uint16Array; break;\n                default:\n                  GL.recordError(0x502 /* GL_INVALID_OPERATION */);\n                  return;\n              }\n  \n              vertexes = new arrayClass(HEAPU8.buffer, indices, count).reduce((max, current) => Math.max(max, current)) + 1;\n              break;\n            }\n          }\n        }\n  \n        // the index is now 0\n        indices = 0;\n      }\n  \n      // bind any client-side buffers\n      GL.preDrawHandleClientVertexAttribBindings(vertexes);\n  \n      GLctx.drawElements(mode, count, type, indices);\n  \n      GL.postDrawHandleClientVertexAttribBindings(count);\n  \n      if (!GLctx.currentElementArrayBufferBinding) {\n        GLctx.bindBuffer(0x8893 /*GL_ELEMENT_ARRAY_BUFFER*/, null);\n      }\n    };\n  var _glDrawElements = _emscripten_glDrawElements;\n\n  var _emscripten_glEnable = (x0) => GLctx.enable(x0);\n  var _glEnable = _emscripten_glEnable;\n\n  var _emscripten_glEnableVertexAttribArray = (index) => {\n      var cb = GL.currentContext.clientBuffers[index];\n      cb.enabled = true;\n      GLctx.enableVertexAttribArray(index);\n    };\n  var _glEnableVertexAttribArray = _emscripten_glEnableVertexAttribArray;\n\n  var _emscripten_glGenBuffers = (n, buffers) => {\n      GL.genObject(n, buffers, 'createBuffer', GL.buffers\n        );\n    };\n  var _glGenBuffers = _emscripten_glGenBuffers;\n\n  var _emscripten_glGenTextures = (n, textures) => {\n      GL.genObject(n, textures, 'createTexture', GL.textures\n        );\n    };\n  var _glGenTextures = _emscripten_glGenTextures;\n\n  var _emscripten_glGenVertexArrays = (n, arrays) => {\n      GL.genObject(n, arrays, 'createVertexArray', GL.vaos\n        );\n    };\n  var _glGenVertexArraysOES = _emscripten_glGenVertexArrays;\n\n  \n  var _emscripten_glGetAttribLocation = (program, name) =>\n      GLctx.getAttribLocation(GL.programs[program], UTF8ToString(name));\n  var _glGetAttribLocation = _emscripten_glGetAttribLocation;\n\n  var readI53FromI64 = (ptr) => {\n      return HEAPU32[((ptr)>>2)] + HEAP32[(((ptr)+(4))>>2)] * 4294967296;\n    };\n  \n  var readI53FromU64 = (ptr) => {\n      return HEAPU32[((ptr)>>2)] + HEAPU32[(((ptr)+(4))>>2)] * 4294967296;\n    };\n  var writeI53ToI64 = (ptr, num) => {\n      HEAPU32[((ptr)>>2)] = num;\n      var lower = HEAPU32[((ptr)>>2)];\n      HEAPU32[(((ptr)+(4))>>2)] = (num - lower)/4294967296;\n      var deserialized = (num >= 0) ? readI53FromU64(ptr) : readI53FromI64(ptr);\n      var offset = ((ptr)>>2);\n      if (deserialized != num) warnOnce(`writeI53ToI64() out of range: serialized JS Number ${num} to Wasm heap as bytes lo=${ptrToString(HEAPU32[offset])}, hi=${ptrToString(HEAPU32[offset+1])}, which deserializes back to ${deserialized} instead!`);\n    };\n  \n  \n  var webglGetExtensions = () => {\n      var exts = getEmscriptenSupportedExtensions(GLctx);\n      exts = exts.concat(exts.map((e) => \"GL_\" + e));\n      return exts;\n    };\n  \n  var emscriptenWebGLGet = (name_, p, type) => {\n      // Guard against user passing a null pointer.\n      // Note that GLES2 spec does not say anything about how passing a null\n      // pointer should be treated.  Testing on desktop core GL 3, the application\n      // crashes on glGetIntegerv to a null pointer, but better to report an error\n      // instead of doing anything random.\n      if (!p) {\n        GL.recordError(0x501 /* GL_INVALID_VALUE */);\n        return;\n      }\n      var ret = undefined;\n      switch (name_) { // Handle a few trivial GLES values\n        case 0x8DFA: // GL_SHADER_COMPILER\n          ret = 1;\n          break;\n        case 0x8DF8: // GL_SHADER_BINARY_FORMATS\n          if (type != 0 && type != 1) {\n            GL.recordError(0x500); // GL_INVALID_ENUM\n          }\n          // Do not write anything to the out pointer, since no binary formats are\n          // supported.\n          return;\n        case 0x87FE: // GL_NUM_PROGRAM_BINARY_FORMATS\n        case 0x8DF9: // GL_NUM_SHADER_BINARY_FORMATS\n          ret = 0;\n          break;\n        case 0x86A2: // GL_NUM_COMPRESSED_TEXTURE_FORMATS\n          // WebGL doesn't have GL_NUM_COMPRESSED_TEXTURE_FORMATS (it's obsolete\n          // since GL_COMPRESSED_TEXTURE_FORMATS returns a JS array that can be\n          // queried for length), so implement it ourselves to allow C++ GLES2\n          // code get the length.\n          var formats = GLctx.getParameter(0x86A3 /*GL_COMPRESSED_TEXTURE_FORMATS*/);\n          ret = formats ? formats.length : 0;\n          break;\n  \n        case 0x821D: // GL_NUM_EXTENSIONS\n          if (GL.currentContext.version < 2) {\n            // Calling GLES3/WebGL2 function with a GLES2/WebGL1 context\n            GL.recordError(0x502 /* GL_INVALID_OPERATION */);\n            return;\n          }\n          ret = webglGetExtensions().length;\n          break;\n        case 0x821B: // GL_MAJOR_VERSION\n        case 0x821C: // GL_MINOR_VERSION\n          if (GL.currentContext.version < 2) {\n            GL.recordError(0x500); // GL_INVALID_ENUM\n            return;\n          }\n          ret = name_ == 0x821B ? 3 : 0; // return version 3.0\n          break;\n      }\n  \n      if (ret === undefined) {\n        var result = GLctx.getParameter(name_);\n        switch (typeof result) {\n          case \"number\":\n            ret = result;\n            break;\n          case \"boolean\":\n            ret = result ? 1 : 0;\n            break;\n          case \"string\":\n            GL.recordError(0x500); // GL_INVALID_ENUM\n            return;\n          case \"object\":\n            if (result === null) {\n              // null is a valid result for some (e.g., which buffer is bound -\n              // perhaps nothing is bound), but otherwise can mean an invalid\n              // name_, which we need to report as an error\n              switch (name_) {\n                case 0x8894: // ARRAY_BUFFER_BINDING\n                case 0x8B8D: // CURRENT_PROGRAM\n                case 0x8895: // ELEMENT_ARRAY_BUFFER_BINDING\n                case 0x8CA6: // FRAMEBUFFER_BINDING or DRAW_FRAMEBUFFER_BINDING\n                case 0x8CA7: // RENDERBUFFER_BINDING\n                case 0x8069: // TEXTURE_BINDING_2D\n                case 0x85B5: // WebGL 2 GL_VERTEX_ARRAY_BINDING, or WebGL 1 extension OES_vertex_array_object GL_VERTEX_ARRAY_BINDING_OES\n                case 0x8F36: // COPY_READ_BUFFER_BINDING or COPY_READ_BUFFER\n                case 0x8F37: // COPY_WRITE_BUFFER_BINDING or COPY_WRITE_BUFFER\n                case 0x88ED: // PIXEL_PACK_BUFFER_BINDING\n                case 0x88EF: // PIXEL_UNPACK_BUFFER_BINDING\n                case 0x8CAA: // READ_FRAMEBUFFER_BINDING\n                case 0x8919: // SAMPLER_BINDING\n                case 0x8C1D: // TEXTURE_BINDING_2D_ARRAY\n                case 0x806A: // TEXTURE_BINDING_3D\n                case 0x8E25: // TRANSFORM_FEEDBACK_BINDING\n                case 0x8C8F: // TRANSFORM_FEEDBACK_BUFFER_BINDING\n                case 0x8A28: // UNIFORM_BUFFER_BINDING\n                case 0x8514: { // TEXTURE_BINDING_CUBE_MAP\n                  ret = 0;\n                  break;\n                }\n                default: {\n                  GL.recordError(0x500); // GL_INVALID_ENUM\n                  return;\n                }\n              }\n            } else if (result instanceof Float32Array ||\n                       result instanceof Uint32Array ||\n                       result instanceof Int32Array ||\n                       result instanceof Array) {\n              for (var i = 0; i < result.length; ++i) {\n                switch (type) {\n                  case 0: HEAP32[(((p)+(i*4))>>2)] = result[i]; break;\n                  case 2: HEAPF32[(((p)+(i*4))>>2)] = result[i]; break;\n                  case 4: HEAP8[(p)+(i)] = result[i] ? 1 : 0; break;\n                }\n              }\n              return;\n            } else {\n              try {\n                ret = result.name | 0;\n              } catch(e) {\n                GL.recordError(0x500); // GL_INVALID_ENUM\n                err(`GL_INVALID_ENUM in glGet${type}v: Unknown object returned from WebGL getParameter(${name_})! (error: ${e})`);\n                return;\n              }\n            }\n            break;\n          default:\n            GL.recordError(0x500); // GL_INVALID_ENUM\n            err(`GL_INVALID_ENUM in glGet${type}v: Native code calling glGet${type}v(${name_}) and it returns ${result} of type ${typeof(result)}!`);\n            return;\n        }\n      }\n  \n      switch (type) {\n        case 1: writeI53ToI64(p, ret); break;\n        case 0: HEAP32[((p)>>2)] = ret; break;\n        case 2:   HEAPF32[((p)>>2)] = ret; break;\n        case 4: HEAP8[p] = ret ? 1 : 0; break;\n      }\n    };\n  \n  var _emscripten_glGetIntegerv = (name_, p) => emscriptenWebGLGet(name_, p, 0);\n  var _glGetIntegerv = _emscripten_glGetIntegerv;\n\n  var _emscripten_glGetProgramInfoLog = (program, maxLength, length, infoLog) => {\n      var log = GLctx.getProgramInfoLog(GL.programs[program]);\n      if (log === null) log = '(unknown error)';\n      var numBytesWrittenExclNull = (maxLength > 0 && infoLog) ? stringToUTF8(log, infoLog, maxLength) : 0;\n      if (length) HEAP32[((length)>>2)] = numBytesWrittenExclNull;\n    };\n  var _glGetProgramInfoLog = _emscripten_glGetProgramInfoLog;\n\n  var _emscripten_glGetProgramiv = (program, pname, p) => {\n      if (!p) {\n        // GLES2 specification does not specify how to behave if p is a null\n        // pointer. Since calling this function does not make sense if p == null,\n        // issue a GL error to notify user about it.\n        GL.recordError(0x501 /* GL_INVALID_VALUE */);\n        return;\n      }\n  \n      if (program >= GL.counter) {\n        GL.recordError(0x501 /* GL_INVALID_VALUE */);\n        return;\n      }\n  \n      program = GL.programs[program];\n  \n      if (pname == 0x8B84) { // GL_INFO_LOG_LENGTH\n        var log = GLctx.getProgramInfoLog(program);\n        if (log === null) log = '(unknown error)';\n        HEAP32[((p)>>2)] = log.length + 1;\n      } else if (pname == 0x8B87 /* GL_ACTIVE_UNIFORM_MAX_LENGTH */) {\n        if (!program.maxUniformLength) {\n          var numActiveUniforms = GLctx.getProgramParameter(program, 0x8B86/*GL_ACTIVE_UNIFORMS*/);\n          for (var i = 0; i < numActiveUniforms; ++i) {\n            program.maxUniformLength = Math.max(program.maxUniformLength, GLctx.getActiveUniform(program, i).name.length+1);\n          }\n        }\n        HEAP32[((p)>>2)] = program.maxUniformLength;\n      } else if (pname == 0x8B8A /* GL_ACTIVE_ATTRIBUTE_MAX_LENGTH */) {\n        if (!program.maxAttributeLength) {\n          var numActiveAttributes = GLctx.getProgramParameter(program, 0x8B89/*GL_ACTIVE_ATTRIBUTES*/);\n          for (var i = 0; i < numActiveAttributes; ++i) {\n            program.maxAttributeLength = Math.max(program.maxAttributeLength, GLctx.getActiveAttrib(program, i).name.length+1);\n          }\n        }\n        HEAP32[((p)>>2)] = program.maxAttributeLength;\n      } else if (pname == 0x8A35 /* GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH */) {\n        if (!program.maxUniformBlockNameLength) {\n          var numActiveUniformBlocks = GLctx.getProgramParameter(program, 0x8A36/*GL_ACTIVE_UNIFORM_BLOCKS*/);\n          for (var i = 0; i < numActiveUniformBlocks; ++i) {\n            program.maxUniformBlockNameLength = Math.max(program.maxUniformBlockNameLength, GLctx.getActiveUniformBlockName(program, i).length+1);\n          }\n        }\n        HEAP32[((p)>>2)] = program.maxUniformBlockNameLength;\n      } else {\n        HEAP32[((p)>>2)] = GLctx.getProgramParameter(program, pname);\n      }\n    };\n  var _glGetProgramiv = _emscripten_glGetProgramiv;\n\n  \n  var _emscripten_glGetShaderInfoLog = (shader, maxLength, length, infoLog) => {\n      var log = GLctx.getShaderInfoLog(GL.shaders[shader]);\n      if (log === null) log = '(unknown error)';\n      var numBytesWrittenExclNull = (maxLength > 0 && infoLog) ? stringToUTF8(log, infoLog, maxLength) : 0;\n      if (length) HEAP32[((length)>>2)] = numBytesWrittenExclNull;\n    };\n  var _glGetShaderInfoLog = _emscripten_glGetShaderInfoLog;\n\n  var _emscripten_glGetShaderiv = (shader, pname, p) => {\n      if (!p) {\n        // GLES2 specification does not specify how to behave if p is a null\n        // pointer. Since calling this function does not make sense if p == null,\n        // issue a GL error to notify user about it.\n        GL.recordError(0x501 /* GL_INVALID_VALUE */);\n        return;\n      }\n      if (pname == 0x8B84) { // GL_INFO_LOG_LENGTH\n        var log = GLctx.getShaderInfoLog(GL.shaders[shader]);\n        if (log === null) log = '(unknown error)';\n        // The GLES2 specification says that if the shader has an empty info log,\n        // a value of 0 is returned. Otherwise the log has a null char appended.\n        // (An empty string is falsey, so we can just check that instead of\n        // looking at log.length.)\n        var logLength = log ? log.length + 1 : 0;\n        HEAP32[((p)>>2)] = logLength;\n      } else if (pname == 0x8B88) { // GL_SHADER_SOURCE_LENGTH\n        var source = GLctx.getShaderSource(GL.shaders[shader]);\n        // source may be a null, or the empty string, both of which are falsey\n        // values that we report a 0 length for.\n        var sourceLength = source ? source.length + 1 : 0;\n        HEAP32[((p)>>2)] = sourceLength;\n      } else {\n        HEAP32[((p)>>2)] = GLctx.getShaderParameter(GL.shaders[shader], pname);\n      }\n    };\n  var _glGetShaderiv = _emscripten_glGetShaderiv;\n\n  \n  \n  var stringToNewUTF8 = (str) => {\n      var size = lengthBytesUTF8(str) + 1;\n      var ret = _malloc(size);\n      if (ret) stringToUTF8(str, ret, size);\n      return ret;\n    };\n  \n  \n  var _emscripten_glGetString = (name_) => {\n      var ret = GL.stringCache[name_];\n      if (!ret) {\n        switch (name_) {\n          case 0x1F03 /* GL_EXTENSIONS */:\n            ret = stringToNewUTF8(webglGetExtensions().join(' '));\n            break;\n          case 0x1F00 /* GL_VENDOR */:\n          case 0x1F01 /* GL_RENDERER */:\n          case 0x9245 /* UNMASKED_VENDOR_WEBGL */:\n          case 0x9246 /* UNMASKED_RENDERER_WEBGL */:\n            var s = GLctx.getParameter(name_);\n            if (!s) {\n              GL.recordError(0x500/*GL_INVALID_ENUM*/);\n            }\n            ret = s ? stringToNewUTF8(s) : 0;\n            break;\n  \n          case 0x1F02 /* GL_VERSION */:\n            var webGLVersion = GLctx.getParameter(0x1F02 /*GL_VERSION*/);\n            // return GLES version string corresponding to the version of the WebGL context\n            var glVersion = `OpenGL ES 2.0 (${webGLVersion})`;\n            if (GL.currentContext.version >= 2) glVersion = `OpenGL ES 3.0 (${webGLVersion})`;\n            ret = stringToNewUTF8(glVersion);\n            break;\n          case 0x8B8C /* GL_SHADING_LANGUAGE_VERSION */:\n            var glslVersion = GLctx.getParameter(0x8B8C /*GL_SHADING_LANGUAGE_VERSION*/);\n            // extract the version number 'N.M' from the string 'WebGL GLSL ES N.M ...'\n            var ver_re = /^WebGL GLSL ES ([0-9]\\.[0-9][0-9]?)(?:$| .*)/;\n            var ver_num = glslVersion.match(ver_re);\n            if (ver_num !== null) {\n              if (ver_num[1].length == 3) ver_num[1] = ver_num[1] + '0'; // ensure minor version has 2 digits\n              glslVersion = `OpenGL ES GLSL ES ${ver_num[1]} (${glslVersion})`;\n            }\n            ret = stringToNewUTF8(glslVersion);\n            break;\n          default:\n            GL.recordError(0x500/*GL_INVALID_ENUM*/);\n            // fall through\n        }\n        GL.stringCache[name_] = ret;\n      }\n      return ret;\n    };\n  var _glGetString = _emscripten_glGetString;\n\n  /** @suppress {checkTypes} */\n  var jstoi_q = (str) => parseInt(str);\n  \n  /** @noinline */\n  var webglGetLeftBracePos = (name) => name.slice(-1) == ']' && name.lastIndexOf('[');\n  \n  var webglPrepareUniformLocationsBeforeFirstUse = (program) => {\n      var uniformLocsById = program.uniformLocsById, // Maps GLuint -> WebGLUniformLocation\n        uniformSizeAndIdsByName = program.uniformSizeAndIdsByName, // Maps name -> [uniform array length, GLuint]\n        i, j;\n  \n      // On the first time invocation of glGetUniformLocation on this shader program:\n      // initialize cache data structures and discover which uniforms are arrays.\n      if (!uniformLocsById) {\n        // maps GLint integer locations to WebGLUniformLocations\n        program.uniformLocsById = uniformLocsById = {};\n        // maps integer locations back to uniform name strings, so that we can lazily fetch uniform array locations\n        program.uniformArrayNamesById = {};\n  \n        var numActiveUniforms = GLctx.getProgramParameter(program, 0x8B86/*GL_ACTIVE_UNIFORMS*/);\n        for (i = 0; i < numActiveUniforms; ++i) {\n          var u = GLctx.getActiveUniform(program, i);\n          var nm = u.name;\n          var sz = u.size;\n          var lb = webglGetLeftBracePos(nm);\n          var arrayName = lb > 0 ? nm.slice(0, lb) : nm;\n  \n          // Assign a new location.\n          var id = program.uniformIdCounter;\n          program.uniformIdCounter += sz;\n          // Eagerly get the location of the uniformArray[0] base element.\n          // The remaining indices >0 will be left for lazy evaluation to\n          // improve performance. Those may never be needed to fetch, if the\n          // application fills arrays always in full starting from the first\n          // element of the array.\n          uniformSizeAndIdsByName[arrayName] = [sz, id];\n  \n          // Store placeholder integers in place that highlight that these\n          // >0 index locations are array indices pending population.\n          for (j = 0; j < sz; ++j) {\n            uniformLocsById[id] = j;\n            program.uniformArrayNamesById[id++] = arrayName;\n          }\n        }\n      }\n    };\n  \n  \n  \n  var _emscripten_glGetUniformLocation = (program, name) => {\n  \n      name = UTF8ToString(name);\n  \n      if (program = GL.programs[program]) {\n        webglPrepareUniformLocationsBeforeFirstUse(program);\n        var uniformLocsById = program.uniformLocsById; // Maps GLuint -> WebGLUniformLocation\n        var arrayIndex = 0;\n        var uniformBaseName = name;\n  \n        // Invariant: when populating integer IDs for uniform locations, we must\n        // maintain the precondition that arrays reside in contiguous addresses,\n        // i.e. for a 'vec4 colors[10];', colors[4] must be at location\n        // colors[0]+4.  However, user might call glGetUniformLocation(program,\n        // \"colors\") for an array, so we cannot discover based on the user input\n        // arguments whether the uniform we are dealing with is an array. The only\n        // way to discover which uniforms are arrays is to enumerate over all the\n        // active uniforms in the program.\n        var leftBrace = webglGetLeftBracePos(name);\n  \n        // If user passed an array accessor \"[index]\", parse the array index off the accessor.\n        if (leftBrace > 0) {\n          arrayIndex = jstoi_q(name.slice(leftBrace + 1)) >>> 0; // \"index]\", coerce parseInt(']') with >>>0 to treat \"foo[]\" as \"foo[0]\" and foo[-1] as unsigned out-of-bounds.\n          uniformBaseName = name.slice(0, leftBrace);\n        }\n  \n        // Have we cached the location of this uniform before?\n        // A pair [array length, GLint of the uniform location]\n        var sizeAndId = program.uniformSizeAndIdsByName[uniformBaseName];\n  \n        // If an uniform with this name exists, and if its index is within the\n        // array limits (if it's even an array), query the WebGLlocation, or\n        // return an existing cached location.\n        if (sizeAndId && arrayIndex < sizeAndId[0]) {\n          arrayIndex += sizeAndId[1]; // Add the base location of the uniform to the array index offset.\n          if ((uniformLocsById[arrayIndex] = uniformLocsById[arrayIndex] || GLctx.getUniformLocation(program, name))) {\n            return arrayIndex;\n          }\n        }\n      }\n      else {\n        // N.b. we are currently unable to distinguish between GL program IDs that\n        // never existed vs GL program IDs that have been deleted, so report\n        // GL_INVALID_VALUE in both cases.\n        GL.recordError(0x501 /* GL_INVALID_VALUE */);\n      }\n      return -1;\n    };\n  var _glGetUniformLocation = _emscripten_glGetUniformLocation;\n\n  var _emscripten_glIsEnabled = (x0) => GLctx.isEnabled(x0);\n  var _glIsEnabled = _emscripten_glIsEnabled;\n\n  var _emscripten_glIsProgram = (program) => {\n      program = GL.programs[program];\n      if (!program) return 0;\n      return GLctx.isProgram(program);\n    };\n  var _glIsProgram = _emscripten_glIsProgram;\n\n  var _emscripten_glLinkProgram = (program) => {\n      program = GL.programs[program];\n      GLctx.linkProgram(program);\n      // Invalidate earlier computed uniform->ID mappings, those have now become stale\n      program.uniformLocsById = 0; // Mark as null-like so that glGetUniformLocation() knows to populate this again.\n      program.uniformSizeAndIdsByName = {};\n  \n    };\n  var _glLinkProgram = _emscripten_glLinkProgram;\n\n  var _emscripten_glPixelStorei = (pname, param) => {\n      if (pname == 3317) {\n        GL.unpackAlignment = param;\n      } else if (pname == 3314) {\n        GL.unpackRowLength = param;\n      }\n      GLctx.pixelStorei(pname, param);\n    };\n  var _glPixelStorei = _emscripten_glPixelStorei;\n\n  var _emscripten_glScissor = (x0, x1, x2, x3) => GLctx.scissor(x0, x1, x2, x3);\n  var _glScissor = _emscripten_glScissor;\n\n  var _emscripten_glShaderSource = (shader, count, string, length) => {\n      var source = GL.getSource(shader, count, string, length);\n  \n      GLctx.shaderSource(GL.shaders[shader], source);\n    };\n  var _glShaderSource = _emscripten_glShaderSource;\n\n  var computeUnpackAlignedImageSize = (width, height, sizePerPixel) => {\n      function roundedToNextMultipleOf(x, y) {\n        return (x + y - 1) & -y;\n      }\n      var plainRowSize = (GL.unpackRowLength || width) * sizePerPixel;\n      var alignedRowSize = roundedToNextMultipleOf(plainRowSize, GL.unpackAlignment);\n      return height * alignedRowSize;\n    };\n  \n  var colorChannelsInGlTextureFormat = (format) => {\n      // Micro-optimizations for size: map format to size by subtracting smallest\n      // enum value (0x1902) from all values first.  Also omit the most common\n      // size value (1) from the list, which is assumed by formats not on the\n      // list.\n      var colorChannels = {\n        // 0x1902 /* GL_DEPTH_COMPONENT */ - 0x1902: 1,\n        // 0x1906 /* GL_ALPHA */ - 0x1902: 1,\n        5: 3,\n        6: 4,\n        // 0x1909 /* GL_LUMINANCE */ - 0x1902: 1,\n        8: 2,\n        29502: 3,\n        29504: 4,\n        // 0x1903 /* GL_RED */ - 0x1902: 1,\n        26917: 2,\n        26918: 2,\n        // 0x8D94 /* GL_RED_INTEGER */ - 0x1902: 1,\n        29846: 3,\n        29847: 4\n      };\n      return colorChannels[format - 0x1902]||1;\n    };\n  \n  var heapObjectForWebGLType = (type) => {\n      // Micro-optimization for size: Subtract lowest GL enum number (0x1400/* GL_BYTE */) from type to compare\n      // smaller values for the heap, for shorter generated code size.\n      // Also the type HEAPU16 is not tested for explicitly, but any unrecognized type will return out HEAPU16.\n      // (since most types are HEAPU16)\n      type -= 0x1400;\n      if (type == 0) return HEAP8;\n  \n      if (type == 1) return HEAPU8;\n  \n      if (type == 2) return HEAP16;\n  \n      if (type == 4) return HEAP32;\n  \n      if (type == 6) return HEAPF32;\n  \n      if (type == 5\n        || type == 28922\n        || type == 28520\n        || type == 30779\n        || type == 30782\n        )\n        return HEAPU32;\n  \n      return HEAPU16;\n    };\n  \n  var toTypedArrayIndex = (pointer, heap) =>\n      pointer >>> (31 - Math.clz32(heap.BYTES_PER_ELEMENT));\n  \n  var emscriptenWebGLGetTexPixelData = (type, format, width, height, pixels, internalFormat) => {\n      var heap = heapObjectForWebGLType(type);\n      var sizePerPixel = colorChannelsInGlTextureFormat(format) * heap.BYTES_PER_ELEMENT;\n      var bytes = computeUnpackAlignedImageSize(width, height, sizePerPixel);\n      return heap.subarray(toTypedArrayIndex(pixels, heap), toTypedArrayIndex(pixels + bytes, heap));\n    };\n  \n  \n  \n  var _emscripten_glTexImage2D = (target, level, internalFormat, width, height, border, format, type, pixels) => {\n      if (GL.currentContext.version >= 2) {\n        if (GLctx.currentPixelUnpackBufferBinding) {\n          GLctx.texImage2D(target, level, internalFormat, width, height, border, format, type, pixels);\n          return;\n        }\n        if (pixels) {\n          var heap = heapObjectForWebGLType(type);\n          var index = toTypedArrayIndex(pixels, heap);\n          GLctx.texImage2D(target, level, internalFormat, width, height, border, format, type, heap, index);\n          return;\n        }\n      }\n      var pixelData = pixels ? emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, internalFormat) : null;\n      GLctx.texImage2D(target, level, internalFormat, width, height, border, format, type, pixelData);\n    };\n  var _glTexImage2D = _emscripten_glTexImage2D;\n\n  var _emscripten_glTexParameteri = (x0, x1, x2) => GLctx.texParameteri(x0, x1, x2);\n  var _glTexParameteri = _emscripten_glTexParameteri;\n\n  \n  \n  \n  var _emscripten_glTexSubImage2D = (target, level, xoffset, yoffset, width, height, format, type, pixels) => {\n      if (GL.currentContext.version >= 2) {\n        if (GLctx.currentPixelUnpackBufferBinding) {\n          GLctx.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);\n          return;\n        }\n        if (pixels) {\n          var heap = heapObjectForWebGLType(type);\n          GLctx.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, heap, toTypedArrayIndex(pixels, heap));\n          return;\n        }\n      }\n      var pixelData = pixels ? emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, 0) : null;\n      GLctx.texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixelData);\n    };\n  var _glTexSubImage2D = _emscripten_glTexSubImage2D;\n\n  var webglGetUniformLocation = (location) => {\n      var p = GLctx.currentProgram;\n  \n      if (p) {\n        var webglLoc = p.uniformLocsById[location];\n        // p.uniformLocsById[location] stores either an integer, or a\n        // WebGLUniformLocation.\n        // If an integer, we have not yet bound the location, so do it now. The\n        // integer value specifies the array index we should bind to.\n        if (typeof webglLoc == 'number') {\n          p.uniformLocsById[location] = webglLoc = GLctx.getUniformLocation(p, p.uniformArrayNamesById[location] + (webglLoc > 0 ? `[${webglLoc}]` : ''));\n        }\n        // Else an already cached WebGLUniformLocation, return it.\n        return webglLoc;\n      } else {\n        GL.recordError(0x502/*GL_INVALID_OPERATION*/);\n      }\n    };\n  \n  var _emscripten_glUniform1i = (location, v0) => {\n      GLctx.uniform1i(webglGetUniformLocation(location), v0);\n    };\n  var _glUniform1i = _emscripten_glUniform1i;\n\n  \n  var miniTempWebGLFloatBuffers = [];\n  \n  var _emscripten_glUniformMatrix4fv = (location, count, transpose, value) => {\n  \n      if (GL.currentContext.version >= 2) {\n        count && GLctx.uniformMatrix4fv(webglGetUniformLocation(location), !!transpose, HEAPF32, ((value)>>2), count*16);\n        return;\n      }\n  \n      if (count <= 18) {\n        // avoid allocation when uploading few enough uniforms\n        var view = miniTempWebGLFloatBuffers[16*count];\n        // hoist the heap out of the loop for size and for pthreads+growth.\n        var heap = HEAPF32;\n        value = ((value)>>2);\n        count *= 16;\n        for (var i = 0; i < count; i += 16) {\n          var dst = value + i;\n          view[i] = heap[dst];\n          view[i + 1] = heap[dst + 1];\n          view[i + 2] = heap[dst + 2];\n          view[i + 3] = heap[dst + 3];\n          view[i + 4] = heap[dst + 4];\n          view[i + 5] = heap[dst + 5];\n          view[i + 6] = heap[dst + 6];\n          view[i + 7] = heap[dst + 7];\n          view[i + 8] = heap[dst + 8];\n          view[i + 9] = heap[dst + 9];\n          view[i + 10] = heap[dst + 10];\n          view[i + 11] = heap[dst + 11];\n          view[i + 12] = heap[dst + 12];\n          view[i + 13] = heap[dst + 13];\n          view[i + 14] = heap[dst + 14];\n          view[i + 15] = heap[dst + 15];\n        }\n      } else\n      {\n        var view = HEAPF32.subarray((((value)>>2)), ((value+count*64)>>2));\n      }\n      GLctx.uniformMatrix4fv(webglGetUniformLocation(location), !!transpose, view);\n    };\n  var _glUniformMatrix4fv = _emscripten_glUniformMatrix4fv;\n\n  var _emscripten_glUseProgram = (program) => {\n      program = GL.programs[program];\n      GLctx.useProgram(program);\n      // Record the currently active program so that we can access the uniform\n      // mapping table of that program.\n      GLctx.currentProgram = program;\n    };\n  var _glUseProgram = _emscripten_glUseProgram;\n\n  var _emscripten_glVertexAttribPointer = (index, size, type, normalized, stride, ptr) => {\n      var cb = GL.currentContext.clientBuffers[index];\n      if (!GLctx.currentArrayBufferBinding) {\n        cb.size = size;\n        cb.type = type;\n        cb.normalized = normalized;\n        cb.stride = stride;\n        cb.ptr = ptr;\n        cb.clientside = true;\n        cb.vertexAttribPointerAdaptor = function(index, size, type, normalized, stride, ptr) {\n          this.vertexAttribPointer(index, size, type, normalized, stride, ptr);\n        };\n        return;\n      }\n      cb.clientside = false;\n      GLctx.vertexAttribPointer(index, size, type, !!normalized, stride, ptr);\n    };\n  var _glVertexAttribPointer = _emscripten_glVertexAttribPointer;\n\n  var _emscripten_glViewport = (x0, x1, x2, x3) => GLctx.viewport(x0, x1, x2, x3);\n  var _glViewport = _emscripten_glViewport;\n\n  \n  \n  \n  \n  /** @param {number=} timeout */\n  var safeSetTimeout = (func, timeout) => {\n      \n      return setTimeout(() => {\n        \n        callUserCallback(func);\n      }, timeout);\n    };\n  \n  \n  \n  var Browser = {\n  useWebGL:false,\n  isFullscreen:false,\n  pointerLock:false,\n  moduleContextCreatedCallbacks:[],\n  workers:[],\n  preloadedImages:{\n  },\n  preloadedAudios:{\n  },\n  getCanvas:() => Module['canvas'],\n  init() {\n        if (Browser.initted) return;\n        Browser.initted = true;\n  \n        // Support for plugins that can process preloaded files. You can add more of these to\n        // your app by creating and appending to preloadPlugins.\n        //\n        // Each plugin is asked if it can handle a file based on the file's name. If it can,\n        // it is given the file's raw data. When it is done, it calls a callback with the file's\n        // (possibly modified) data. For example, a plugin might decompress a file, or it\n        // might create some side data structure for use later (like an Image element, etc.).\n  \n        var imagePlugin = {};\n        imagePlugin['canHandle'] = function imagePlugin_canHandle(name) {\n          return !Module['noImageDecoding'] && /\\.(jpg|jpeg|png|bmp|webp)$/i.test(name);\n        };\n        imagePlugin['handle'] = async function imagePlugin_handle(byteArray, name) {\n          var b = new Blob([byteArray], { type: Browser.getMimetype(name) });\n          if (b.size !== byteArray.length) { // Safari bug #118630\n            // Safari's Blob can only take an ArrayBuffer\n            b = new Blob([(new Uint8Array(byteArray)).buffer], { type: Browser.getMimetype(name) });\n          }\n          var url = URL.createObjectURL(b);\n          return new Promise((resolve, reject) => {\n            var img = new Image();\n            img.onload = () => {\n              assert(img.complete, `Image ${name} could not be decoded`);\n              var canvas = /** @type {!HTMLCanvasElement} */ (document.createElement('canvas'));\n              canvas.width = img.width;\n              canvas.height = img.height;\n              var ctx = canvas.getContext('2d');\n              ctx.drawImage(img, 0, 0);\n              Browser.preloadedImages[name] = canvas;\n              URL.revokeObjectURL(url);\n              resolve(byteArray);\n            };\n            img.onerror = (event) => {\n              err(`Image ${url} could not be decoded`);\n              reject();\n            };\n            img.src = url;\n          });\n        };\n        preloadPlugins.push(imagePlugin);\n  \n        var audioPlugin = {};\n        audioPlugin['canHandle'] = function audioPlugin_canHandle(name) {\n          return !Module['noAudioDecoding'] && name.slice(-4) in { '.ogg': 1, '.wav': 1, '.mp3': 1 };\n        };\n        audioPlugin['handle'] = async function audioPlugin_handle(byteArray, name) {\n          return new Promise((resolve, reject) => {\n            var done = false;\n            function finish(audio) {\n              if (done) return;\n              done = true;\n              Browser.preloadedAudios[name] = audio;\n              resolve(byteArray);\n            }\n            var b = new Blob([byteArray], { type: Browser.getMimetype(name) });\n            var url = URL.createObjectURL(b); // XXX we never revoke this!\n            var audio = new Audio();\n            audio.addEventListener('canplaythrough', () => finish(audio), false); // use addEventListener due to chromium bug 124926\n            audio.onerror = function audio_onerror(event) {\n              if (done) return;\n              err(`warning: browser could not fully decode audio ${name}, trying slower base64 approach`);\n              function encode64(data) {\n                var BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n                var PAD = '=';\n                var ret = '';\n                var leftchar = 0;\n                var leftbits = 0;\n                for (var i = 0; i < data.length; i++) {\n                  leftchar = (leftchar << 8) | data[i];\n                  leftbits += 8;\n                  while (leftbits >= 6) {\n                    var curr = (leftchar >> (leftbits-6)) & 0x3f;\n                    leftbits -= 6;\n                    ret += BASE[curr];\n                  }\n                }\n                if (leftbits == 2) {\n                  ret += BASE[(leftchar&3) << 4];\n                  ret += PAD + PAD;\n                } else if (leftbits == 4) {\n                  ret += BASE[(leftchar&0xf) << 2];\n                  ret += PAD;\n                }\n                return ret;\n              }\n              audio.src = 'data:audio/x-' + name.slice(-3) + ';base64,' + encode64(byteArray);\n              finish(audio); // we don't wait for confirmation this worked - but it's worth trying\n            };\n            audio.src = url;\n            // workaround for chrome bug 124926 - we do not always get oncanplaythrough or onerror\n            safeSetTimeout(() => {\n              finish(audio); // try to use it even though it is not necessarily ready to play\n            }, 10000);\n          });\n        };\n        preloadPlugins.push(audioPlugin);\n  \n        // Canvas event setup\n  \n        function pointerLockChange() {\n          var canvas = Browser.getCanvas();\n          Browser.pointerLock = document.pointerLockElement === canvas;\n        }\n        var canvas = Browser.getCanvas();\n        if (canvas) {\n          // forced aspect ratio can be enabled by defining 'forcedAspectRatio' on Module\n          // Module['forcedAspectRatio'] = 4 / 3;\n  \n          document.addEventListener('pointerlockchange', pointerLockChange, false);\n  \n          if (Module['elementPointerLock']) {\n            canvas.addEventListener(\"click\", (ev) => {\n              if (!Browser.pointerLock && Browser.getCanvas().requestPointerLock) {\n                Browser.getCanvas().requestPointerLock();\n                ev.preventDefault();\n              }\n            }, false);\n          }\n        }\n      },\n  createContext(/** @type {HTMLCanvasElement} */ canvas, useWebGL, setInModule, webGLContextAttributes) {\n        if (useWebGL && Module['ctx'] && canvas == Browser.getCanvas()) return Module['ctx']; // no need to recreate GL context if it's already been created for this canvas.\n  \n        var ctx;\n        var contextHandle;\n        if (useWebGL) {\n          // For GLES2/desktop GL compatibility, adjust a few defaults to be different to WebGL defaults, so that they align better with the desktop defaults.\n          var contextAttributes = {\n            antialias: false,\n            alpha: false,\n            majorVersion: (typeof WebGL2RenderingContext != 'undefined') ? 2 : 1,\n          };\n  \n          if (webGLContextAttributes) {\n            for (var attribute in webGLContextAttributes) {\n              contextAttributes[attribute] = webGLContextAttributes[attribute];\n            }\n          }\n  \n          // This check of existence of GL is here to satisfy Closure compiler, which yells if variable GL is referenced below but GL object is not\n          // actually compiled in because application is not doing any GL operations. TODO: Ideally if GL is not being used, this function\n          // Browser.createContext() should not even be emitted.\n          if (typeof GL != 'undefined') {\n            contextHandle = GL.createContext(canvas, contextAttributes);\n            if (contextHandle) {\n              ctx = GL.getContext(contextHandle).GLctx;\n            }\n          }\n        } else {\n          ctx = canvas.getContext('2d');\n        }\n  \n        if (!ctx) return null;\n  \n        if (setInModule) {\n          if (!useWebGL) assert(typeof GLctx == 'undefined', 'cannot set in module if GLctx is used, but we are a non-GL context that would replace it');\n          Module['ctx'] = ctx;\n          if (useWebGL) GL.makeContextCurrent(contextHandle);\n          Browser.useWebGL = useWebGL;\n          Browser.moduleContextCreatedCallbacks.forEach((callback) => callback());\n          Browser.init();\n        }\n        return ctx;\n      },\n  fullscreenHandlersInstalled:false,\n  lockPointer:undefined,\n  resizeCanvas:undefined,\n  requestFullscreen(lockPointer, resizeCanvas) {\n        Browser.lockPointer = lockPointer;\n        Browser.resizeCanvas = resizeCanvas;\n        if (typeof Browser.lockPointer == 'undefined') Browser.lockPointer = true;\n        if (typeof Browser.resizeCanvas == 'undefined') Browser.resizeCanvas = false;\n  \n        var canvas = Browser.getCanvas();\n        function fullscreenChange() {\n          Browser.isFullscreen = false;\n          var canvasContainer = canvas.parentNode;\n          if (getFullscreenElement() === canvasContainer) {\n            canvas.exitFullscreen = Browser.exitFullscreen;\n            if (Browser.lockPointer) canvas.requestPointerLock();\n            Browser.isFullscreen = true;\n            if (Browser.resizeCanvas) {\n              Browser.setFullscreenCanvasSize();\n            } else {\n              Browser.updateCanvasDimensions(canvas);\n            }\n          } else {\n            // remove the full screen specific parent of the canvas again to restore the HTML structure from before going full screen\n            canvasContainer.parentNode.insertBefore(canvas, canvasContainer);\n            canvasContainer.parentNode.removeChild(canvasContainer);\n  \n            if (Browser.resizeCanvas) {\n              Browser.setWindowedCanvasSize();\n            } else {\n              Browser.updateCanvasDimensions(canvas);\n            }\n          }\n          Module['onFullScreen']?.(Browser.isFullscreen);\n          Module['onFullscreen']?.(Browser.isFullscreen);\n        }\n  \n        if (!Browser.fullscreenHandlersInstalled) {\n          Browser.fullscreenHandlersInstalled = true;\n          document.addEventListener('fullscreenchange', fullscreenChange, false);\n          document.addEventListener('mozfullscreenchange', fullscreenChange, false);\n          document.addEventListener('webkitfullscreenchange', fullscreenChange, false);\n          document.addEventListener('MSFullscreenChange', fullscreenChange, false);\n        }\n  \n        // create a new parent to ensure the canvas has no siblings. this allows browsers to optimize full screen performance when its parent is the full screen root\n        var canvasContainer = document.createElement(\"div\");\n        canvas.parentNode.insertBefore(canvasContainer, canvas);\n        canvasContainer.appendChild(canvas);\n  \n        // use parent of canvas as full screen root to allow aspect ratio correction (Firefox stretches the root to screen size)\n        canvasContainer.requestFullscreen = canvasContainer['requestFullscreen'] ||\n                                            canvasContainer['mozRequestFullScreen'] ||\n                                            canvasContainer['msRequestFullscreen'] ||\n                                           (canvasContainer['webkitRequestFullscreen'] ? () => canvasContainer['webkitRequestFullscreen'](Element['ALLOW_KEYBOARD_INPUT']) : null) ||\n                                           (canvasContainer['webkitRequestFullScreen'] ? () => canvasContainer['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']) : null);\n  \n        canvasContainer.requestFullscreen();\n      },\n  requestFullScreen() {\n        abort('Module.requestFullScreen has been replaced by Module.requestFullscreen (without a capital S)');\n      },\n  exitFullscreen() {\n        // This is workaround for chrome. Trying to exit from fullscreen\n        // not in fullscreen state will cause \"TypeError: Document not active\"\n        // in chrome. See https://github.com/emscripten-core/emscripten/pull/8236\n        if (!Browser.isFullscreen) {\n          return false;\n        }\n  \n        var CFS = document['exitFullscreen'] ||\n                  document['cancelFullScreen'] ||\n                  document['mozCancelFullScreen'] ||\n                  document['msExitFullscreen'] ||\n                  document['webkitCancelFullScreen'] ||\n            (() => {});\n        CFS.apply(document, []);\n        return true;\n      },\n  safeSetTimeout(func, timeout) {\n        // Legacy function, this is used by the SDL2 port so we need to keep it\n        // around at least until that is updated.\n        // See https://github.com/libsdl-org/SDL/pull/6304\n        return safeSetTimeout(func, timeout);\n      },\n  getMimetype(name) {\n        return {\n          'jpg': 'image/jpeg',\n          'jpeg': 'image/jpeg',\n          'png': 'image/png',\n          'bmp': 'image/bmp',\n          'ogg': 'audio/ogg',\n          'wav': 'audio/wav',\n          'mp3': 'audio/mpeg'\n        }[name.slice(name.lastIndexOf('.')+1)];\n      },\n  getUserMedia(func) {\n        window.getUserMedia ||= navigator['getUserMedia'] ||\n                                navigator['mozGetUserMedia'];\n        window.getUserMedia(func);\n      },\n  getMovementX(event) {\n        return event['movementX'] ||\n               event['mozMovementX'] ||\n               event['webkitMovementX'] ||\n               0;\n      },\n  getMovementY(event) {\n        return event['movementY'] ||\n               event['mozMovementY'] ||\n               event['webkitMovementY'] ||\n               0;\n      },\n  getMouseWheelDelta(event) {\n        var delta = 0;\n        switch (event.type) {\n          case 'DOMMouseScroll':\n            // 3 lines make up a step\n            delta = event.detail / 3;\n            break;\n          case 'mousewheel':\n            // 120 units make up a step\n            delta = event.wheelDelta / 120;\n            break;\n          case 'wheel':\n            delta = event.deltaY\n            switch (event.deltaMode) {\n              case 0:\n                // DOM_DELTA_PIXEL: 100 pixels make up a step\n                delta /= 100;\n                break;\n              case 1:\n                // DOM_DELTA_LINE: 3 lines make up a step\n                delta /= 3;\n                break;\n              case 2:\n                // DOM_DELTA_PAGE: A page makes up 80 steps\n                delta *= 80;\n                break;\n              default:\n                abort('unrecognized mouse wheel delta mode: ' + event.deltaMode);\n            }\n            break;\n          default:\n            abort('unrecognized mouse wheel event: ' + event.type);\n        }\n        return delta;\n      },\n  mouseX:0,\n  mouseY:0,\n  mouseMovementX:0,\n  mouseMovementY:0,\n  touches:{\n  },\n  lastTouches:{\n  },\n  calculateMouseCoords(pageX, pageY) {\n        // Calculate the movement based on the changes\n        // in the coordinates.\n        var canvas = Browser.getCanvas();\n        var rect = canvas.getBoundingClientRect();\n  \n        // Neither .scrollX or .pageXOffset are defined in a spec, but\n        // we prefer .scrollX because it is currently in a spec draft.\n        // (see: http://www.w3.org/TR/2013/WD-cssom-view-20131217/)\n        var scrollX = ((typeof window.scrollX != 'undefined') ? window.scrollX : window.pageXOffset);\n        var scrollY = ((typeof window.scrollY != 'undefined') ? window.scrollY : window.pageYOffset);\n        // If this assert lands, it's likely because the browser doesn't support scrollX or pageXOffset\n        // and we have no viable fallback.\n        assert((typeof scrollX != 'undefined') && (typeof scrollY != 'undefined'), 'Unable to retrieve scroll position, mouse positions likely broken.');\n        var adjustedX = pageX - (scrollX + rect.left);\n        var adjustedY = pageY - (scrollY + rect.top);\n  \n        // the canvas might be CSS-scaled compared to its backbuffer;\n        // SDL-using content will want mouse coordinates in terms\n        // of backbuffer units.\n        adjustedX = adjustedX * (canvas.width / rect.width);\n        adjustedY = adjustedY * (canvas.height / rect.height);\n  \n        return { x: adjustedX, y: adjustedY };\n      },\n  setMouseCoords(pageX, pageY) {\n        const {x, y} = Browser.calculateMouseCoords(pageX, pageY);\n        Browser.mouseMovementX = x - Browser.mouseX;\n        Browser.mouseMovementY = y - Browser.mouseY;\n        Browser.mouseX = x;\n        Browser.mouseY = y;\n      },\n  calculateMouseEvent(event) { // event should be mousemove, mousedown or mouseup\n        if (Browser.pointerLock) {\n          // When the pointer is locked, calculate the coordinates\n          // based on the movement of the mouse.\n          // Workaround for Firefox bug 764498\n          if (event.type != 'mousemove' &&\n              ('mozMovementX' in event)) {\n            Browser.mouseMovementX = Browser.mouseMovementY = 0;\n          } else {\n            Browser.mouseMovementX = Browser.getMovementX(event);\n            Browser.mouseMovementY = Browser.getMovementY(event);\n          }\n  \n          // add the mouse delta to the current absolute mouse position\n          Browser.mouseX += Browser.mouseMovementX;\n          Browser.mouseY += Browser.mouseMovementY;\n        } else {\n          if (event.type === 'touchstart' || event.type === 'touchend' || event.type === 'touchmove') {\n            var touch = event.touch;\n            if (touch === undefined) {\n              return; // the \"touch\" property is only defined in SDL\n  \n            }\n            var coords = Browser.calculateMouseCoords(touch.pageX, touch.pageY);\n  \n            if (event.type === 'touchstart') {\n              Browser.lastTouches[touch.identifier] = coords;\n              Browser.touches[touch.identifier] = coords;\n            } else if (event.type === 'touchend' || event.type === 'touchmove') {\n              var last = Browser.touches[touch.identifier];\n              last ||= coords;\n              Browser.lastTouches[touch.identifier] = last;\n              Browser.touches[touch.identifier] = coords;\n            }\n            return;\n          }\n  \n          Browser.setMouseCoords(event.pageX, event.pageY);\n        }\n      },\n  resizeListeners:[],\n  updateResizeListeners() {\n        var canvas = Browser.getCanvas();\n        Browser.resizeListeners.forEach((listener) => listener(canvas.width, canvas.height));\n      },\n  setCanvasSize(width, height, noUpdates) {\n        var canvas = Browser.getCanvas();\n        Browser.updateCanvasDimensions(canvas, width, height);\n        if (!noUpdates) Browser.updateResizeListeners();\n      },\n  windowedWidth:0,\n  windowedHeight:0,\n  setFullscreenCanvasSize() {\n        // check if SDL is available\n        if (typeof SDL != \"undefined\") {\n          var flags = HEAPU32[((SDL.screen)>>2)];\n          flags = flags | 0x00800000; // set SDL_FULLSCREEN flag\n          HEAP32[((SDL.screen)>>2)] = flags;\n        }\n        Browser.updateCanvasDimensions(Browser.getCanvas());\n        Browser.updateResizeListeners();\n      },\n  setWindowedCanvasSize() {\n        // check if SDL is available\n        if (typeof SDL != \"undefined\") {\n          var flags = HEAPU32[((SDL.screen)>>2)];\n          flags = flags & ~0x00800000; // clear SDL_FULLSCREEN flag\n          HEAP32[((SDL.screen)>>2)] = flags;\n        }\n        Browser.updateCanvasDimensions(Browser.getCanvas());\n        Browser.updateResizeListeners();\n      },\n  updateCanvasDimensions(canvas, wNative, hNative) {\n        if (wNative && hNative) {\n          canvas.widthNative = wNative;\n          canvas.heightNative = hNative;\n        } else {\n          wNative = canvas.widthNative;\n          hNative = canvas.heightNative;\n        }\n        var w = wNative;\n        var h = hNative;\n        if (Module['forcedAspectRatio'] > 0) {\n          if (w/h < Module['forcedAspectRatio']) {\n            w = Math.round(h * Module['forcedAspectRatio']);\n          } else {\n            h = Math.round(w / Module['forcedAspectRatio']);\n          }\n        }\n        if ((getFullscreenElement() === canvas.parentNode) && (typeof screen != 'undefined')) {\n           var factor = Math.min(screen.width / w, screen.height / h);\n           w = Math.round(w * factor);\n           h = Math.round(h * factor);\n        }\n        if (Browser.resizeCanvas) {\n          if (canvas.width  != w) canvas.width  = w;\n          if (canvas.height != h) canvas.height = h;\n          if (typeof canvas.style != 'undefined') {\n            canvas.style.removeProperty( \"width\");\n            canvas.style.removeProperty(\"height\");\n          }\n        } else {\n          if (canvas.width  != wNative) canvas.width  = wNative;\n          if (canvas.height != hNative) canvas.height = hNative;\n          if (typeof canvas.style != 'undefined') {\n            if (w != wNative || h != hNative) {\n              canvas.style.setProperty( \"width\", w + \"px\", \"important\");\n              canvas.style.setProperty(\"height\", h + \"px\", \"important\");\n            } else {\n              canvas.style.removeProperty( \"width\");\n              canvas.style.removeProperty(\"height\");\n            }\n          }\n        }\n      },\n  };\n  \n  /** @constructor */\n  function GLFW_Window(id, width, height, framebufferWidth, framebufferHeight, title, monitor, share) {\n        this.id = id;\n        this.x = 0;\n        this.y = 0;\n        this.fullscreen = false; // Used to determine if app in fullscreen mode\n        this.storedX = 0; // Used to store X before fullscreen\n        this.storedY = 0; // Used to store Y before fullscreen\n        this.width = width;\n        this.height = height;\n        this.framebufferWidth = framebufferWidth;\n        this.framebufferHeight = framebufferHeight;\n        this.storedWidth = width; // Used to store width before fullscreen\n        this.storedHeight = height; // Used to store height before fullscreen\n        this.title = title;\n        this.monitor = monitor;\n        this.share = share;\n        this.attributes = {...GLFW.hints};\n        this.inputModes = {\n          0x00033001:0x00034001, // GLFW_CURSOR (GLFW_CURSOR_NORMAL)\n          0x00033002:0, // GLFW_STICKY_KEYS\n          0x00033003:0, // GLFW_STICKY_MOUSE_BUTTONS\n        };\n        this.buttons = 0;\n        this.keys = new Array();\n        this.domKeys = new Array();\n        this.shouldClose = 0;\n        this.title = null;\n        this.windowPosFunc = 0; // GLFWwindowposfun\n        this.windowSizeFunc = 0; // GLFWwindowsizefun\n        this.windowCloseFunc = 0; // GLFWwindowclosefun\n        this.windowRefreshFunc = 0; // GLFWwindowrefreshfun\n        this.windowFocusFunc = 0; // GLFWwindowfocusfun\n        this.windowIconifyFunc = 0; // GLFWwindowiconifyfun\n        this.windowMaximizeFunc = 0; // GLFWwindowmaximizefun\n        this.framebufferSizeFunc = 0; // GLFWframebuffersizefun\n        this.windowContentScaleFunc = 0; // GLFWwindowcontentscalefun\n        this.mouseButtonFunc = 0; // GLFWmousebuttonfun\n        this.cursorPosFunc = 0; // GLFWcursorposfun\n        this.cursorEnterFunc = 0; // GLFWcursorenterfun\n        this.scrollFunc = 0; // GLFWscrollfun\n        this.dropFunc = 0; // GLFWdropfun\n        this.keyFunc = 0; // GLFWkeyfun\n        this.charFunc = 0; // GLFWcharfun\n        this.userptr = 0;\n      }\n  \n  \n  \n  \n  \n  \n  \n  var _emscripten_set_window_title = (title) => document.title = UTF8ToString(title);\n  \n  \n  \n  var GLFW = {\n  WindowFromId:(id) => {\n        if (id <= 0 || !GLFW.windows) return null;\n        return GLFW.windows[id - 1];\n      },\n  joystickFunc:0,\n  errorFunc:0,\n  monitorFunc:0,\n  active:null,\n  scale:null,\n  windows:null,\n  monitors:null,\n  monitorString:null,\n  versionString:null,\n  initialTime:null,\n  extensions:null,\n  devicePixelRatioMQL:null,\n  hints:null,\n  primaryTouchId:null,\n  defaultHints:{\n  131073:0,\n  131074:0,\n  131075:1,\n  131076:1,\n  131077:1,\n  131082:0,\n  135169:8,\n  135170:8,\n  135171:8,\n  135172:8,\n  135173:24,\n  135174:8,\n  135175:0,\n  135176:0,\n  135177:0,\n  135178:0,\n  135179:0,\n  135180:0,\n  135181:0,\n  135182:0,\n  135183:0,\n  139265:196609,\n  139266:1,\n  139267:0,\n  139268:0,\n  139269:0,\n  139270:0,\n  139271:0,\n  139272:0,\n  139276:0,\n  },\n  DOMToGLFWKeyCode:(keycode) => {\n        switch (keycode) {\n          // these keycodes are only defined for GLFW3, assume they are the same for GLFW2\n          case 0x20:return 32; // DOM_VK_SPACE -> GLFW_KEY_SPACE\n          case 0xDE:return 39; // DOM_VK_QUOTE -> GLFW_KEY_APOSTROPHE\n          case 0xBC:return 44; // DOM_VK_COMMA -> GLFW_KEY_COMMA\n          case 0xAD:return 45; // DOM_VK_HYPHEN_MINUS -> GLFW_KEY_MINUS\n          case 0xBD:return 45; // DOM_VK_MINUS -> GLFW_KEY_MINUS\n          case 0xBE:return 46; // DOM_VK_PERIOD -> GLFW_KEY_PERIOD\n          case 0xBF:return 47; // DOM_VK_SLASH -> GLFW_KEY_SLASH\n          case 0x30:return 48; // DOM_VK_0 -> GLFW_KEY_0\n          case 0x31:return 49; // DOM_VK_1 -> GLFW_KEY_1\n          case 0x32:return 50; // DOM_VK_2 -> GLFW_KEY_2\n          case 0x33:return 51; // DOM_VK_3 -> GLFW_KEY_3\n          case 0x34:return 52; // DOM_VK_4 -> GLFW_KEY_4\n          case 0x35:return 53; // DOM_VK_5 -> GLFW_KEY_5\n          case 0x36:return 54; // DOM_VK_6 -> GLFW_KEY_6\n          case 0x37:return 55; // DOM_VK_7 -> GLFW_KEY_7\n          case 0x38:return 56; // DOM_VK_8 -> GLFW_KEY_8\n          case 0x39:return 57; // DOM_VK_9 -> GLFW_KEY_9\n          case 0x3B:return 59; // DOM_VK_SEMICOLON -> GLFW_KEY_SEMICOLON\n          case 0x3D:return 61; // DOM_VK_EQUALS -> GLFW_KEY_EQUAL\n          case 0xBB:return 61; // DOM_VK_EQUALS -> GLFW_KEY_EQUAL\n          case 0x41:return 65; // DOM_VK_A -> GLFW_KEY_A\n          case 0x42:return 66; // DOM_VK_B -> GLFW_KEY_B\n          case 0x43:return 67; // DOM_VK_C -> GLFW_KEY_C\n          case 0x44:return 68; // DOM_VK_D -> GLFW_KEY_D\n          case 0x45:return 69; // DOM_VK_E -> GLFW_KEY_E\n          case 0x46:return 70; // DOM_VK_F -> GLFW_KEY_F\n          case 0x47:return 71; // DOM_VK_G -> GLFW_KEY_G\n          case 0x48:return 72; // DOM_VK_H -> GLFW_KEY_H\n          case 0x49:return 73; // DOM_VK_I -> GLFW_KEY_I\n          case 0x4A:return 74; // DOM_VK_J -> GLFW_KEY_J\n          case 0x4B:return 75; // DOM_VK_K -> GLFW_KEY_K\n          case 0x4C:return 76; // DOM_VK_L -> GLFW_KEY_L\n          case 0x4D:return 77; // DOM_VK_M -> GLFW_KEY_M\n          case 0x4E:return 78; // DOM_VK_N -> GLFW_KEY_N\n          case 0x4F:return 79; // DOM_VK_O -> GLFW_KEY_O\n          case 0x50:return 80; // DOM_VK_P -> GLFW_KEY_P\n          case 0x51:return 81; // DOM_VK_Q -> GLFW_KEY_Q\n          case 0x52:return 82; // DOM_VK_R -> GLFW_KEY_R\n          case 0x53:return 83; // DOM_VK_S -> GLFW_KEY_S\n          case 0x54:return 84; // DOM_VK_T -> GLFW_KEY_T\n          case 0x55:return 85; // DOM_VK_U -> GLFW_KEY_U\n          case 0x56:return 86; // DOM_VK_V -> GLFW_KEY_V\n          case 0x57:return 87; // DOM_VK_W -> GLFW_KEY_W\n          case 0x58:return 88; // DOM_VK_X -> GLFW_KEY_X\n          case 0x59:return 89; // DOM_VK_Y -> GLFW_KEY_Y\n          case 0x5a:return 90; // DOM_VK_Z -> GLFW_KEY_Z\n          case 0xDB:return 91; // DOM_VK_OPEN_BRACKET -> GLFW_KEY_LEFT_BRACKET\n          case 0xDC:return 92; // DOM_VK_BACKSLASH -> GLFW_KEY_BACKSLASH\n          case 0xDD:return 93; // DOM_VK_CLOSE_BRACKET -> GLFW_KEY_RIGHT_BRACKET\n          case 0xC0:return 96; // DOM_VK_BACK_QUOTE -> GLFW_KEY_GRAVE_ACCENT\n  \n          case 0x1B:return 256; // DOM_VK_ESCAPE -> GLFW_KEY_ESCAPE\n          case 0x0D:return 257; // DOM_VK_RETURN -> GLFW_KEY_ENTER\n          case 0x09:return 258; // DOM_VK_TAB -> GLFW_KEY_TAB\n          case 0x08:return 259; // DOM_VK_BACK -> GLFW_KEY_BACKSPACE\n          case 0x2D:return 260; // DOM_VK_INSERT -> GLFW_KEY_INSERT\n          case 0x2E:return 261; // DOM_VK_DELETE -> GLFW_KEY_DELETE\n          case 0x27:return 262; // DOM_VK_RIGHT -> GLFW_KEY_RIGHT\n          case 0x25:return 263; // DOM_VK_LEFT -> GLFW_KEY_LEFT\n          case 0x28:return 264; // DOM_VK_DOWN -> GLFW_KEY_DOWN\n          case 0x26:return 265; // DOM_VK_UP -> GLFW_KEY_UP\n          case 0x21:return 266; // DOM_VK_PAGE_UP -> GLFW_KEY_PAGE_UP\n          case 0x22:return 267; // DOM_VK_PAGE_DOWN -> GLFW_KEY_PAGE_DOWN\n          case 0x24:return 268; // DOM_VK_HOME -> GLFW_KEY_HOME\n          case 0x23:return 269; // DOM_VK_END -> GLFW_KEY_END\n          case 0x14:return 280; // DOM_VK_CAPS_LOCK -> GLFW_KEY_CAPS_LOCK\n          case 0x91:return 281; // DOM_VK_SCROLL_LOCK -> GLFW_KEY_SCROLL_LOCK\n          case 0x90:return 282; // DOM_VK_NUM_LOCK -> GLFW_KEY_NUM_LOCK\n          case 0x2C:return 283; // DOM_VK_SNAPSHOT -> GLFW_KEY_PRINT_SCREEN\n          case 0x13:return 284; // DOM_VK_PAUSE -> GLFW_KEY_PAUSE\n          case 0x70:return 290; // DOM_VK_F1 -> GLFW_KEY_F1\n          case 0x71:return 291; // DOM_VK_F2 -> GLFW_KEY_F2\n          case 0x72:return 292; // DOM_VK_F3 -> GLFW_KEY_F3\n          case 0x73:return 293; // DOM_VK_F4 -> GLFW_KEY_F4\n          case 0x74:return 294; // DOM_VK_F5 -> GLFW_KEY_F5\n          case 0x75:return 295; // DOM_VK_F6 -> GLFW_KEY_F6\n          case 0x76:return 296; // DOM_VK_F7 -> GLFW_KEY_F7\n          case 0x77:return 297; // DOM_VK_F8 -> GLFW_KEY_F8\n          case 0x78:return 298; // DOM_VK_F9 -> GLFW_KEY_F9\n          case 0x79:return 299; // DOM_VK_F10 -> GLFW_KEY_F10\n          case 0x7A:return 300; // DOM_VK_F11 -> GLFW_KEY_F11\n          case 0x7B:return 301; // DOM_VK_F12 -> GLFW_KEY_F12\n          case 0x7C:return 302; // DOM_VK_F13 -> GLFW_KEY_F13\n          case 0x7D:return 303; // DOM_VK_F14 -> GLFW_KEY_F14\n          case 0x7E:return 304; // DOM_VK_F15 -> GLFW_KEY_F15\n          case 0x7F:return 305; // DOM_VK_F16 -> GLFW_KEY_F16\n          case 0x80:return 306; // DOM_VK_F17 -> GLFW_KEY_F17\n          case 0x81:return 307; // DOM_VK_F18 -> GLFW_KEY_F18\n          case 0x82:return 308; // DOM_VK_F19 -> GLFW_KEY_F19\n          case 0x83:return 309; // DOM_VK_F20 -> GLFW_KEY_F20\n          case 0x84:return 310; // DOM_VK_F21 -> GLFW_KEY_F21\n          case 0x85:return 311; // DOM_VK_F22 -> GLFW_KEY_F22\n          case 0x86:return 312; // DOM_VK_F23 -> GLFW_KEY_F23\n          case 0x87:return 313; // DOM_VK_F24 -> GLFW_KEY_F24\n          case 0x88:return 314; // 0x88 (not used?) -> GLFW_KEY_F25\n          case 0x60:return 320; // DOM_VK_NUMPAD0 -> GLFW_KEY_KP_0\n          case 0x61:return 321; // DOM_VK_NUMPAD1 -> GLFW_KEY_KP_1\n          case 0x62:return 322; // DOM_VK_NUMPAD2 -> GLFW_KEY_KP_2\n          case 0x63:return 323; // DOM_VK_NUMPAD3 -> GLFW_KEY_KP_3\n          case 0x64:return 324; // DOM_VK_NUMPAD4 -> GLFW_KEY_KP_4\n          case 0x65:return 325; // DOM_VK_NUMPAD5 -> GLFW_KEY_KP_5\n          case 0x66:return 326; // DOM_VK_NUMPAD6 -> GLFW_KEY_KP_6\n          case 0x67:return 327; // DOM_VK_NUMPAD7 -> GLFW_KEY_KP_7\n          case 0x68:return 328; // DOM_VK_NUMPAD8 -> GLFW_KEY_KP_8\n          case 0x69:return 329; // DOM_VK_NUMPAD9 -> GLFW_KEY_KP_9\n          case 0x6E:return 330; // DOM_VK_DECIMAL -> GLFW_KEY_KP_DECIMAL\n          case 0x6F:return 331; // DOM_VK_DIVIDE -> GLFW_KEY_KP_DIVIDE\n          case 0x6A:return 332; // DOM_VK_MULTIPLY -> GLFW_KEY_KP_MULTIPLY\n          case 0x6D:return 333; // DOM_VK_SUBTRACT -> GLFW_KEY_KP_SUBTRACT\n          case 0x6B:return 334; // DOM_VK_ADD -> GLFW_KEY_KP_ADD\n          // case 0x0D:return 335; // DOM_VK_RETURN -> GLFW_KEY_KP_ENTER (DOM_KEY_LOCATION_RIGHT)\n          // case 0x61:return 336; // DOM_VK_EQUALS -> GLFW_KEY_KP_EQUAL (DOM_KEY_LOCATION_RIGHT)\n          case 0x10:return 340; // DOM_VK_SHIFT -> GLFW_KEY_LEFT_SHIFT\n          case 0x11:return 341; // DOM_VK_CONTROL -> GLFW_KEY_LEFT_CONTROL\n          case 0x12:return 342; // DOM_VK_ALT -> GLFW_KEY_LEFT_ALT\n          case 0x5B:return 343; // DOM_VK_WIN -> GLFW_KEY_LEFT_SUPER\n          case 0xE0:return 343; // DOM_VK_META -> GLFW_KEY_LEFT_SUPER\n          // case 0x10:return 344; // DOM_VK_SHIFT -> GLFW_KEY_RIGHT_SHIFT (DOM_KEY_LOCATION_RIGHT)\n          // case 0x11:return 345; // DOM_VK_CONTROL -> GLFW_KEY_RIGHT_CONTROL (DOM_KEY_LOCATION_RIGHT)\n          // case 0x12:return 346; // DOM_VK_ALT -> GLFW_KEY_RIGHT_ALT (DOM_KEY_LOCATION_RIGHT)\n          // case 0x5B:return 347; // DOM_VK_WIN -> GLFW_KEY_RIGHT_SUPER (DOM_KEY_LOCATION_RIGHT)\n          case 0x5D:return 348; // DOM_VK_CONTEXT_MENU -> GLFW_KEY_MENU\n          // XXX: GLFW_KEY_WORLD_1, GLFW_KEY_WORLD_2 what are these?\n          default:return -1; // GLFW_KEY_UNKNOWN\n        };\n      },\n  getModBits:(win) => {\n        var mod = 0;\n        if (win.keys[340]) mod |= 0x0001; // GLFW_MOD_SHIFT\n        if (win.keys[341]) mod |= 0x0002; // GLFW_MOD_CONTROL\n        if (win.keys[342]) mod |= 0x0004; // GLFW_MOD_ALT\n        if (win.keys[343] || win.keys[348]) mod |= 0x0008; // GLFW_MOD_SUPER\n        // add caps and num lock keys? only if lock_key_mod is set\n        return mod;\n      },\n  onKeyPress:(event) => {\n        if (!GLFW.active || !GLFW.active.charFunc) return;\n        if (event.ctrlKey || event.metaKey) return;\n  \n        // correct unicode charCode is only available with onKeyPress event\n        var charCode = event.charCode;\n        if (charCode == 0 || (charCode >= 0x00 && charCode <= 0x1F)) return;\n  \n        getWasmTableEntry(GLFW.active.charFunc)(GLFW.active.id, charCode);\n      },\n  onKeyChanged:(keyCode, status) => {\n        if (!GLFW.active) return;\n  \n        var key = GLFW.DOMToGLFWKeyCode(keyCode);\n        if (key == -1) return;\n  \n        var repeat = status && GLFW.active.keys[key];\n        GLFW.active.keys[key] = status;\n        GLFW.active.domKeys[keyCode] = status;\n  \n        if (GLFW.active.keyFunc) {\n          if (repeat) status = 2; // GLFW_REPEAT\n          getWasmTableEntry(GLFW.active.keyFunc)(GLFW.active.id, key, keyCode, status, GLFW.getModBits(GLFW.active));\n        }\n      },\n  onGamepadConnected:(event) => {\n        GLFW.refreshJoysticks();\n      },\n  onGamepadDisconnected:(event) => {\n        GLFW.refreshJoysticks();\n      },\n  onKeydown:(event) => {\n        GLFW.onKeyChanged(event.keyCode, 1); // GLFW_PRESS or GLFW_REPEAT\n  \n        // This logic comes directly from the sdl implementation. We cannot\n        // call preventDefault on all keydown events otherwise onKeyPress will\n        // not get called\n        if (event.key == 'Backspace' || event.key == 'Tab') {\n          event.preventDefault();\n        }\n      },\n  onKeyup:(event) => {\n        GLFW.onKeyChanged(event.keyCode, 0); // GLFW_RELEASE\n      },\n  onBlur:(event) => {\n        if (!GLFW.active) return;\n  \n        for (var i = 0; i < GLFW.active.domKeys.length; ++i) {\n          if (GLFW.active.domKeys[i]) {\n            GLFW.onKeyChanged(i, 0); // GLFW_RELEASE\n          }\n        }\n      },\n  onMousemove:(event) => {\n        if (!GLFW.active) return;\n  \n        if (event.type === 'touchmove') {\n          // Handling for touch events that are being converted to mouse input.\n  \n          // Don't let the browser fire a duplicate mouse event.\n          event.preventDefault();\n  \n          let primaryChanged = false;\n          for (let i of event.changedTouches) {\n            // If our chosen primary touch moved, update Browser mouse coords\n            if (GLFW.primaryTouchId === i.identifier) {\n              Browser.setMouseCoords(i.pageX, i.pageY);\n              primaryChanged = true;\n              break;\n            }\n          }\n  \n          if (!primaryChanged) {\n            // Do not send mouse events if some touch other than the primary triggered this.\n            return;\n          }\n  \n        } else {\n          // Handling for non-touch mouse input events.\n          Browser.calculateMouseEvent(event);\n        }\n  \n        if (event.target != Browser.getCanvas() || !GLFW.active.cursorPosFunc) return;\n  \n        if (GLFW.active.cursorPosFunc) {\n          getWasmTableEntry(GLFW.active.cursorPosFunc)(GLFW.active.id, Browser.mouseX, Browser.mouseY);\n        }\n      },\n  DOMToGLFWMouseButton:(event) => {\n        // DOM and glfw have different button codes.\n        // See http://www.w3schools.com/jsref/event_button.asp.\n        var eventButton = event['button'];\n        if (eventButton > 0) {\n          if (eventButton == 1) {\n            eventButton = 2;\n          } else {\n            eventButton = 1;\n          }\n        }\n        return eventButton;\n      },\n  onMouseenter:(event) => {\n        if (!GLFW.active) return;\n  \n        if (event.target != Browser.getCanvas()) return;\n  \n        if (GLFW.active.cursorEnterFunc) {\n          getWasmTableEntry(GLFW.active.cursorEnterFunc)(GLFW.active.id, 1);\n        }\n      },\n  onMouseleave:(event) => {\n        if (!GLFW.active) return;\n  \n        if (event.target != Browser.getCanvas()) return;\n  \n        if (GLFW.active.cursorEnterFunc) {\n          getWasmTableEntry(GLFW.active.cursorEnterFunc)(GLFW.active.id, 0);\n        }\n      },\n  onMouseButtonChanged:(event, status) => {\n        if (!GLFW.active) return;\n  \n        if (event.target != Browser.getCanvas()) return;\n  \n        // Is this from a touch event?\n        const isTouchType = event.type === 'touchstart' || event.type === 'touchend' || event.type === 'touchcancel';\n  \n        // Only emulating mouse left-click behavior for touches.\n        let eventButton = 0;\n        if (isTouchType) {\n          // Handling for touch events that are being converted to mouse input.\n  \n          // Don't let the browser fire a duplicate mouse event.\n          event.preventDefault();\n  \n          let primaryChanged = false;\n  \n          // Set a primary touch if we have none.\n          if (GLFW.primaryTouchId === null && event.type === 'touchstart' && event.targetTouches.length > 0) {\n            // Pick the first touch that started in the canvas and treat it as primary.\n            const chosenTouch = event.targetTouches[0];\n            GLFW.primaryTouchId = chosenTouch.identifier;\n  \n            Browser.setMouseCoords(chosenTouch.pageX, chosenTouch.pageY);\n            primaryChanged = true;\n          } else if (event.type === 'touchend' || event.type === 'touchcancel') {\n            // Clear the primary touch if it ended.\n            for (let i of event.changedTouches) {\n              // If our chosen primary touch ended, remove it.\n              if (GLFW.primaryTouchId === i.identifier) {\n                GLFW.primaryTouchId = null;\n                primaryChanged = true;\n                break;\n              }\n            }\n          }\n  \n          if (!primaryChanged) {\n            // Do not send mouse events if some touch other than the primary triggered this.\n            return;\n          }\n  \n        } else {\n          // Handling for non-touch mouse input events.\n          Browser.calculateMouseEvent(event);\n          eventButton = GLFW.DOMToGLFWMouseButton(event);\n        }\n  \n        if (status == 1) { // GLFW_PRESS\n          GLFW.active.buttons |= (1 << eventButton);\n          try {\n            event.target.setCapture();\n          } catch (e) {}\n        } else {  // GLFW_RELEASE\n          GLFW.active.buttons &= ~(1 << eventButton);\n        }\n  \n        // Send mouse event to GLFW.\n        if (GLFW.active.mouseButtonFunc) {\n          getWasmTableEntry(GLFW.active.mouseButtonFunc)(GLFW.active.id, eventButton, status, GLFW.getModBits(GLFW.active));\n        }\n      },\n  onMouseButtonDown:(event) => {\n        if (!GLFW.active) return;\n        GLFW.onMouseButtonChanged(event, 1); // GLFW_PRESS\n      },\n  onMouseButtonUp:(event) => {\n        if (!GLFW.active) return;\n        GLFW.onMouseButtonChanged(event, 0); // GLFW_RELEASE\n      },\n  onMouseWheel:(event) => {\n        // Note the minus sign that flips browser wheel direction (positive direction scrolls page down) to native wheel direction (positive direction is mouse wheel up)\n        var delta = -Browser.getMouseWheelDelta(event);\n        delta = (delta == 0) ? 0 : (delta > 0 ? Math.max(delta, 1) : Math.min(delta, -1)); // Quantize to integer so that minimum scroll is at least +/- 1.\n        GLFW.wheelPos += delta;\n  \n        if (!GLFW.active || !GLFW.active.scrollFunc || event.target != Browser.getCanvas()) return;\n        var sx = 0;\n        var sy = delta;\n        if (event.type == 'mousewheel') {\n          sx = event.wheelDeltaX;\n        } else {\n          sx = event.deltaX;\n        }\n  \n        getWasmTableEntry(GLFW.active.scrollFunc)(GLFW.active.id, sx, sy);\n  \n        event.preventDefault();\n      },\n  onCanvasResize:(width, height, framebufferWidth, framebufferHeight) => {\n        if (!GLFW.active) return;\n  \n        var resizeNeeded = false;\n  \n        // If the client is requesting fullscreen mode\n        if (getFullscreenElement()) {\n          if (!GLFW.active.fullscreen) {\n            resizeNeeded = width != screen.width || height != screen.height;\n            GLFW.active.storedX = GLFW.active.x;\n            GLFW.active.storedY = GLFW.active.y;\n            GLFW.active.storedWidth = GLFW.active.width;\n            GLFW.active.storedHeight = GLFW.active.height;\n            GLFW.active.x = GLFW.active.y = 0;\n            GLFW.active.width = screen.width;\n            GLFW.active.height = screen.height;\n            GLFW.active.fullscreen = true;\n          }\n        // If the client is reverting from fullscreen mode\n        } else if (GLFW.active.fullscreen == true) {\n          resizeNeeded = width != GLFW.active.storedWidth || height != GLFW.active.storedHeight;\n          GLFW.active.x = GLFW.active.storedX;\n          GLFW.active.y = GLFW.active.storedY;\n          GLFW.active.width = GLFW.active.storedWidth;\n          GLFW.active.height = GLFW.active.storedHeight;\n          GLFW.active.fullscreen = false;\n        }\n  \n        if (resizeNeeded) {\n          // width or height is changed (fullscreen / exit fullscreen) which will call this listener back\n          // with proper framebufferWidth/framebufferHeight\n          Browser.setCanvasSize(GLFW.active.width, GLFW.active.height);\n        } else if (GLFW.active.width != width ||\n                   GLFW.active.height != height ||\n                   GLFW.active.framebufferWidth != framebufferWidth ||\n                   GLFW.active.framebufferHeight != framebufferHeight) {\n          GLFW.active.width = width;\n          GLFW.active.height = height;\n          GLFW.active.framebufferWidth = framebufferWidth;\n          GLFW.active.framebufferHeight = framebufferHeight;\n          GLFW.onWindowSizeChanged();\n          GLFW.onFramebufferSizeChanged();\n        }\n      },\n  onWindowSizeChanged:() => {\n        if (!GLFW.active) return;\n  \n        if (GLFW.active.windowSizeFunc) {\n          getWasmTableEntry(GLFW.active.windowSizeFunc)(GLFW.active.id, GLFW.active.width, GLFW.active.height);\n        }\n      },\n  onFramebufferSizeChanged:() => {\n        if (!GLFW.active) return;\n  \n        if (GLFW.active.framebufferSizeFunc) {\n          getWasmTableEntry(GLFW.active.framebufferSizeFunc)(GLFW.active.id, GLFW.active.framebufferWidth, GLFW.active.framebufferHeight);\n        }\n      },\n  onWindowContentScaleChanged:(scale) => {\n        GLFW.scale = scale;\n        if (!GLFW.active) return;\n  \n        if (GLFW.active.windowContentScaleFunc) {\n          getWasmTableEntry(GLFW.active.windowContentScaleFunc)(GLFW.active.id, GLFW.scale, GLFW.scale);\n        }\n      },\n  getTime:() => _emscripten_get_now() / 1000,\n  setWindowTitle:(winid, title) => {\n        var win = GLFW.WindowFromId(winid);\n        if (!win) return;\n  \n        win.title = title;\n        if (GLFW.active.id == win.id) {\n          _emscripten_set_window_title(title);\n        }\n      },\n  setJoystickCallback:(cbfun) => {\n        var prevcbfun = GLFW.joystickFunc;\n        GLFW.joystickFunc = cbfun;\n        GLFW.refreshJoysticks();\n        return prevcbfun;\n      },\n  joys:{\n  },\n  lastGamepadState:[],\n  lastGamepadStateFrame:null,\n  refreshJoysticks:() => {\n        // Produce a new Gamepad API sample if we are ticking a new game frame, or if not using emscripten_set_main_loop() at all to drive animation.\n        if (MainLoop.currentFrameNumber !== GLFW.lastGamepadStateFrame || !MainLoop.currentFrameNumber) {\n          GLFW.lastGamepadState = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads || []);\n          GLFW.lastGamepadStateFrame = MainLoop.currentFrameNumber;\n  \n          for (var joy = 0; joy < GLFW.lastGamepadState.length; ++joy) {\n            var gamepad = GLFW.lastGamepadState[joy];\n  \n            if (gamepad) {\n              if (!GLFW.joys[joy]) {\n                out('glfw joystick connected:',joy);\n                GLFW.joys[joy] = {\n                  id: stringToNewUTF8(gamepad.id),\n                  buttonsCount: gamepad.buttons.length,\n                  axesCount: gamepad.axes.length,\n                  buttons: _malloc(gamepad.buttons.length),\n                  axes: _malloc(gamepad.axes.length*4),\n                };\n  \n                if (GLFW.joystickFunc) {\n                  getWasmTableEntry(GLFW.joystickFunc)(joy, 0x00040001); // GLFW_CONNECTED\n                }\n              }\n  \n              var data = GLFW.joys[joy];\n  \n              for (var i = 0; i < gamepad.buttons.length;  ++i) {\n                HEAP8[data.buttons + i] = gamepad.buttons[i].pressed;\n              }\n  \n              for (var i = 0; i < gamepad.axes.length; ++i) {\n                HEAPF32[((data.axes + i*4)>>2)] = gamepad.axes[i];\n              }\n            } else {\n              if (GLFW.joys[joy]) {\n                out('glfw joystick disconnected',joy);\n  \n                if (GLFW.joystickFunc) {\n                  getWasmTableEntry(GLFW.joystickFunc)(joy, 0x00040002); // GLFW_DISCONNECTED\n                }\n  \n                _free(GLFW.joys[joy].id);\n                _free(GLFW.joys[joy].buttons);\n                _free(GLFW.joys[joy].axes);\n  \n                delete GLFW.joys[joy];\n              }\n            }\n          }\n        }\n      },\n  setKeyCallback:(winid, cbfun) => {\n        var win = GLFW.WindowFromId(winid);\n        if (!win) return null;\n        var prevcbfun = win.keyFunc;\n        win.keyFunc = cbfun;\n        return prevcbfun;\n      },\n  setCharCallback:(winid, cbfun) => {\n        var win = GLFW.WindowFromId(winid);\n        if (!win) return null;\n        var prevcbfun = win.charFunc;\n        win.charFunc = cbfun;\n        return prevcbfun;\n      },\n  setMouseButtonCallback:(winid, cbfun) => {\n        var win = GLFW.WindowFromId(winid);\n        if (!win) return null;\n        var prevcbfun = win.mouseButtonFunc;\n        win.mouseButtonFunc = cbfun;\n        return prevcbfun;\n      },\n  setCursorPosCallback:(winid, cbfun) => {\n        var win = GLFW.WindowFromId(winid);\n        if (!win) return null;\n        var prevcbfun = win.cursorPosFunc;\n        win.cursorPosFunc = cbfun;\n        return prevcbfun;\n      },\n  setScrollCallback:(winid, cbfun) => {\n        var win = GLFW.WindowFromId(winid);\n        if (!win) return null;\n        var prevcbfun = win.scrollFunc;\n        win.scrollFunc = cbfun;\n        return prevcbfun;\n      },\n  setDropCallback:(winid, cbfun) => {\n        var win = GLFW.WindowFromId(winid);\n        if (!win) return null;\n        var prevcbfun = win.dropFunc;\n        win.dropFunc = cbfun;\n        return prevcbfun;\n      },\n  onDrop:(event) => {\n        if (!GLFW.active || !GLFW.active.dropFunc) return;\n        if (!event.dataTransfer || !event.dataTransfer.files || event.dataTransfer.files.length == 0) return;\n  \n        event.preventDefault();\n  \n        var filenames = _malloc(event.dataTransfer.files.length * 4);\n        var filenamesArray = [];\n        var count = event.dataTransfer.files.length;\n  \n        // Read and save the files to emscripten's FS\n        var written = 0;\n        var drop_dir = '.glfw_dropped_files';\n        FS.createPath('/', drop_dir);\n  \n        function save(file) {\n          var path = '/' + drop_dir + '/' + file.name.replace(/\\//g, '_');\n          var reader = new FileReader();\n          reader.onloadend = (e) => {\n            if (reader.readyState != 2) { // not DONE\n              ++written;\n              out('failed to read dropped file: '+file.name+': '+reader.error);\n              return;\n            }\n  \n            var data = e.target.result;\n            FS.writeFile(path, new Uint8Array(data));\n            if (++written === count) {\n              getWasmTableEntry(GLFW.active.dropFunc)(GLFW.active.id, count, filenames);\n  \n              for (var i = 0; i < filenamesArray.length; ++i) {\n                _free(filenamesArray[i]);\n              }\n              _free(filenames);\n            }\n          };\n          reader.readAsArrayBuffer(file);\n  \n          var filename = stringToNewUTF8(path);\n          filenamesArray.push(filename);\n          HEAPU32[(((filenames)+(i*4))>>2)] = filename;\n        }\n  \n        for (var i = 0; i < count; ++i) {\n          save(event.dataTransfer.files[i]);\n        }\n  \n        return false;\n      },\n  onDragover:(event) => {\n        if (!GLFW.active || !GLFW.active.dropFunc) return;\n  \n        event.preventDefault();\n        return false;\n      },\n  setWindowSizeCallback:(winid, cbfun) => {\n        var win = GLFW.WindowFromId(winid);\n        if (!win) return null;\n        var prevcbfun = win.windowSizeFunc;\n        win.windowSizeFunc = cbfun;\n  \n        return prevcbfun;\n      },\n  setWindowCloseCallback:(winid, cbfun) => {\n        var win = GLFW.WindowFromId(winid);\n        if (!win) return null;\n        var prevcbfun = win.windowCloseFunc;\n        win.windowCloseFunc = cbfun;\n        return prevcbfun;\n      },\n  setWindowRefreshCallback:(winid, cbfun) => {\n        var win = GLFW.WindowFromId(winid);\n        if (!win) return null;\n        var prevcbfun = win.windowRefreshFunc;\n        win.windowRefreshFunc = cbfun;\n        return prevcbfun;\n      },\n  onClickRequestPointerLock:(e) => {\n        var canvas = Browser.getCanvas();\n        if (!Browser.pointerLock && canvas.requestPointerLock) {\n          canvas.requestPointerLock();\n          e.preventDefault();\n        }\n      },\n  setInputMode:(winid, mode, value) => {\n        var win = GLFW.WindowFromId(winid);\n        if (!win) return;\n  \n        switch (mode) {\n          case 0x00033001: { // GLFW_CURSOR\n            var canvas = Browser.getCanvas();\n            switch (value) {\n              case 0x00034001: { // GLFW_CURSOR_NORMAL\n                win.inputModes[mode] = value;\n                canvas.removeEventListener('click', GLFW.onClickRequestPointerLock, true);\n                document.exitPointerLock();\n                break;\n              }\n              case 0x00034002: { // GLFW_CURSOR_HIDDEN\n                err('glfwSetInputMode called with GLFW_CURSOR_HIDDEN value not implemented');\n                break;\n              }\n              case 0x00034003: { // GLFW_CURSOR_DISABLED\n                win.inputModes[mode] = value;\n                canvas.addEventListener('click', GLFW.onClickRequestPointerLock, true);\n                canvas.requestPointerLock();\n                break;\n              }\n              default: {\n                err(`glfwSetInputMode called with unknown value parameter value: ${value}`);\n                break;\n              }\n            }\n            break;\n          }\n          case 0x00033002: { // GLFW_STICKY_KEYS\n            err('glfwSetInputMode called with GLFW_STICKY_KEYS mode not implemented');\n            break;\n          }\n          case 0x00033003: { // GLFW_STICKY_MOUSE_BUTTONS\n            err('glfwSetInputMode called with GLFW_STICKY_MOUSE_BUTTONS mode not implemented');\n            break;\n          }\n          case 0x00033004: { // GLFW_LOCK_KEY_MODS\n            err('glfwSetInputMode called with GLFW_LOCK_KEY_MODS mode not implemented');\n            break;\n          }\n          case 0x000330005: { // GLFW_RAW_MOUSE_MOTION\n            err('glfwSetInputMode called with GLFW_RAW_MOUSE_MOTION mode not implemented');\n            break;\n          }\n          default: {\n            err(`glfwSetInputMode called with unknown mode parameter value: ${mode}`);\n            break;\n          }\n        }\n      },\n  getKey:(winid, key) => {\n        var win = GLFW.WindowFromId(winid);\n        if (!win) return 0;\n        return win.keys[key];\n      },\n  getMouseButton:(winid, button) => {\n        var win = GLFW.WindowFromId(winid);\n        if (!win) return 0;\n        return (win.buttons & (1 << button)) > 0;\n      },\n  getCursorPos:(winid, x, y) => {\n        HEAPF64[((x)>>3)] = Browser.mouseX;\n        HEAPF64[((y)>>3)] = Browser.mouseY;\n      },\n  getMousePos:(winid, x, y) => {\n        HEAP32[((x)>>2)] = Browser.mouseX;\n        HEAP32[((y)>>2)] = Browser.mouseY;\n      },\n  setCursorPos:(winid, x, y) => {\n      },\n  getWindowPos:(winid, x, y) => {\n        var wx = 0;\n        var wy = 0;\n  \n        var win = GLFW.WindowFromId(winid);\n        if (win) {\n          wx = win.x;\n          wy = win.y;\n        }\n  \n        if (x) {\n          HEAP32[((x)>>2)] = wx;\n        }\n  \n        if (y) {\n          HEAP32[((y)>>2)] = wy;\n        }\n      },\n  setWindowPos:(winid, x, y) => {\n        var win = GLFW.WindowFromId(winid);\n        if (!win) return;\n        win.x = x;\n        win.y = y;\n      },\n  getWindowSize:(winid, width, height) => {\n        var ww = 0;\n        var wh = 0;\n  \n        var win = GLFW.WindowFromId(winid);\n        if (win) {\n          ww = win.width;\n          wh = win.height;\n        }\n  \n        if (width) {\n          HEAP32[((width)>>2)] = ww;\n        }\n  \n        if (height) {\n          HEAP32[((height)>>2)] = wh;\n        }\n      },\n  setWindowSize:(winid, width, height) => {\n        var win = GLFW.WindowFromId(winid);\n        if (!win) return;\n  \n        if (GLFW.active.id == win.id) {\n          Browser.setCanvasSize(width, height); // triggers the listener (onCanvasResize) + windowSizeFunc\n        }\n      },\n  defaultWindowHints:() => {\n        GLFW.hints = {...GLFW.defaultHints};\n      },\n  createWindow:(width, height, title, monitor, share) => {\n        var i, id;\n        for (i = 0; i < GLFW.windows.length && GLFW.windows[i] !== null; i++) {\n          // no-op\n        }\n        if (i > 0) abort(\"glfwCreateWindow only supports one window at time currently\");\n  \n        // id for window\n        id = i + 1;\n  \n        // not valid\n        if (width <= 0 || height <= 0) return 0;\n  \n        if (monitor) {\n          Browser.requestFullscreen();\n        } else {\n          Browser.setCanvasSize(width, height);\n        }\n  \n        // Create context when there are no existing alive windows\n        for (i = 0; i < GLFW.windows.length && GLFW.windows[i] == null; i++) {\n          // no-op\n        }\n  \n        const canvas = Browser.getCanvas();\n  \n        var useWebGL = GLFW.hints[0x00022001] > 0; // Use WebGL when we are told to based on GLFW_CLIENT_API\n        if (i == GLFW.windows.length) {\n          if (useWebGL) {\n            var contextAttributes = {\n              antialias: (GLFW.hints[0x0002100D] > 1), // GLFW_SAMPLES\n              depth: (GLFW.hints[0x00021005] > 0),     // GLFW_DEPTH_BITS\n              stencil: (GLFW.hints[0x00021006] > 0),   // GLFW_STENCIL_BITS\n              alpha: (GLFW.hints[0x00021004] > 0)      // GLFW_ALPHA_BITS\n            }\n            Browser.createContext(canvas, /*useWebGL=*/true, /*setInModule=*/true, contextAttributes);\n          } else {\n            Browser.init();\n          }\n        }\n  \n        // If context creation failed, do not return a valid window\n        if (!Module['ctx'] && useWebGL) return 0;\n  \n        // Initializes the framebuffer size from the canvas\n        var win = new GLFW_Window(id, width, height, canvas.width, canvas.height, title, monitor, share);\n  \n        // Set window to array\n        if (id - 1 == GLFW.windows.length) {\n          GLFW.windows.push(win);\n        } else {\n          GLFW.windows[id - 1] = win;\n        }\n  \n        GLFW.active = win;\n        GLFW.adjustCanvasDimensions();\n        return win.id;\n      },\n  destroyWindow:(winid) => {\n        var win = GLFW.WindowFromId(winid);\n        if (!win) return;\n  \n        if (win.windowCloseFunc) {\n          getWasmTableEntry(win.windowCloseFunc)(win.id);\n        }\n  \n        GLFW.windows[win.id - 1] = null;\n        if (GLFW.active.id == win.id) {\n          GLFW.active = null;\n        }\n  \n        // Destroy context when no alive windows\n        for (win of GLFW.windows) {\n          if (win !== null) return;\n        }\n  \n        delete Module['ctx'];\n      },\n  swapBuffers:(winid) => {\n      },\n  requestFullscreen(lockPointer, resizeCanvas) {\n        Browser.lockPointer = lockPointer;\n        Browser.resizeCanvas = resizeCanvas;\n        if (typeof Browser.lockPointer == 'undefined') Browser.lockPointer = true;\n        if (typeof Browser.resizeCanvas == 'undefined') Browser.resizeCanvas = false;\n  \n        var canvas = Browser.getCanvas();\n        function fullscreenChange() {\n          Browser.isFullscreen = false;\n          var canvasContainer = canvas.parentNode;\n          if (getFullscreenElement() === canvasContainer) {\n            canvas.exitFullscreen = Browser.exitFullscreen;\n            if (Browser.lockPointer) canvas.requestPointerLock();\n            Browser.isFullscreen = true;\n            if (Browser.resizeCanvas) {\n              Browser.setFullscreenCanvasSize();\n            } else {\n              Browser.updateCanvasDimensions(canvas);\n              Browser.updateResizeListeners();\n            }\n          } else {\n            // remove the full screen specific parent of the canvas again to restore the HTML structure from before going full screen\n            canvasContainer.parentNode.insertBefore(canvas, canvasContainer);\n            canvasContainer.parentNode.removeChild(canvasContainer);\n  \n            if (Browser.resizeCanvas) {\n              Browser.setWindowedCanvasSize();\n            } else {\n              Browser.updateCanvasDimensions(canvas);\n              Browser.updateResizeListeners();\n            }\n          }\n          Module['onFullScreen']?.(Browser.isFullscreen);\n          Module['onFullscreen']?.(Browser.isFullscreen);\n        }\n  \n        if (!Browser.fullscreenHandlersInstalled) {\n          Browser.fullscreenHandlersInstalled = true;\n          document.addEventListener('fullscreenchange', fullscreenChange, false);\n          document.addEventListener('mozfullscreenchange', fullscreenChange, false);\n          document.addEventListener('webkitfullscreenchange', fullscreenChange, false);\n          document.addEventListener('MSFullscreenChange', fullscreenChange, false);\n        }\n  \n        // create a new parent to ensure the canvas has no siblings. this allows browsers to optimize full screen performance when its parent is the full screen root\n        var canvasContainer = document.createElement(\"div\");\n        canvas.parentNode.insertBefore(canvasContainer, canvas);\n        canvasContainer.appendChild(canvas);\n  \n        // use parent of canvas as full screen root to allow aspect ratio correction (Firefox stretches the root to screen size)\n        canvasContainer.requestFullscreen = canvasContainer['requestFullscreen'] ||\n          canvasContainer['mozRequestFullScreen'] ||\n          canvasContainer['msRequestFullscreen'] ||\n          (canvasContainer['webkitRequestFullscreen'] ? () => canvasContainer['webkitRequestFullscreen'](Element['ALLOW_KEYBOARD_INPUT']) : null) ||\n          (canvasContainer['webkitRequestFullScreen'] ? () => canvasContainer['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']) : null);\n  \n        canvasContainer.requestFullscreen();\n      },\n  updateCanvasDimensions(canvas, wNative, hNative) {\n        const scale = GLFW.getHiDPIScale();\n  \n        if (wNative && hNative) {\n          canvas.widthNative = wNative;\n          canvas.heightNative = hNative;\n        } else {\n          wNative = canvas.widthNative;\n          hNative = canvas.heightNative;\n        }\n        var w = wNative;\n        var h = hNative;\n        if (Module['forcedAspectRatio'] && Module['forcedAspectRatio'] > 0) {\n          if (w/h < Module['forcedAspectRatio']) {\n            w = Math.round(h * Module['forcedAspectRatio']);\n          } else {\n            h = Math.round(w / Module['forcedAspectRatio']);\n          }\n        }\n        if ((getFullscreenElement() === canvas.parentNode) && (typeof screen != 'undefined')) {\n          var factor = Math.min(screen.width / w, screen.height / h);\n          w = Math.round(w * factor);\n          h = Math.round(h * factor);\n        }\n        if (Browser.resizeCanvas) {\n          wNative = w;\n          hNative = h;\n        }\n        const wNativeScaled = Math.floor(wNative * scale);\n        const hNativeScaled = Math.floor(hNative * scale);\n        if (canvas.width  != wNativeScaled) canvas.width  = wNativeScaled;\n        if (canvas.height != hNativeScaled) canvas.height = hNativeScaled;\n        if (typeof canvas.style != 'undefined') {\n          if (!GLFW.isCSSScalingEnabled()) {\n            canvas.style.setProperty( \"width\", wNative + \"px\", \"important\");\n            canvas.style.setProperty(\"height\", hNative + \"px\", \"important\");\n          } else {\n            canvas.style.removeProperty( \"width\");\n            canvas.style.removeProperty(\"height\");\n          }\n        }\n      },\n  calculateMouseCoords(pageX, pageY) {\n        // Calculate the movement based on the changes\n        // in the coordinates.\n        const rect = Browser.getCanvas().getBoundingClientRect();\n  \n        // Neither .scrollX or .pageXOffset are defined in a spec, but\n        // we prefer .scrollX because it is currently in a spec draft.\n        // (see: http://www.w3.org/TR/2013/WD-cssom-view-20131217/)\n        var scrollX = ((typeof window.scrollX != 'undefined') ? window.scrollX : window.pageXOffset);\n        var scrollY = ((typeof window.scrollY != 'undefined') ? window.scrollY : window.pageYOffset);\n        // If this assert lands, it's likely because the browser doesn't support scrollX or pageXOffset\n        // and we have no viable fallback.\n        assert((typeof scrollX != 'undefined') && (typeof scrollY != 'undefined'), 'Unable to retrieve scroll position, mouse positions likely broken.');\n        var adjustedX = pageX - (scrollX + rect.left);\n        var adjustedY = pageY - (scrollY + rect.top);\n  \n        // getBoundingClientRect() returns dimension affected by CSS, so as a result:\n        // - when CSS scaling is enabled, this will fix the mouse coordinates to match the width/height of the window\n        // - otherwise the CSS width/height are forced to the width/height of the GLFW window (see updateCanvasDimensions),\n        //   so there is no need to adjust the position\n        if (GLFW.isCSSScalingEnabled() && GLFW.active) {\n          adjustedX = adjustedX * (GLFW.active.width / rect.width);\n          adjustedY = adjustedY * (GLFW.active.height / rect.height);\n        }\n  \n        return { x: adjustedX, y: adjustedY };\n      },\n  setWindowAttrib:(winid, attrib, value) => {\n        var win = GLFW.WindowFromId(winid);\n        if (!win) return;\n        const isHiDPIAware = GLFW.isHiDPIAware();\n        win.attributes[attrib] = value;\n        if (isHiDPIAware !== GLFW.isHiDPIAware())\n          GLFW.adjustCanvasDimensions();\n      },\n  getDevicePixelRatio() {\n        return (typeof devicePixelRatio == 'number' && devicePixelRatio) || 1.0;\n      },\n  isHiDPIAware() {\n        if (GLFW.active)\n          return GLFW.active.attributes[0x0002200C] > 0; // GLFW_SCALE_TO_MONITOR\n        else\n          return false;\n      },\n  isCSSScalingEnabled() {\n        return !GLFW.isHiDPIAware();\n      },\n  adjustCanvasDimensions() {\n        if (GLFW.active) {\n          Browser.updateCanvasDimensions(Browser.getCanvas(), GLFW.active.width, GLFW.active.height);\n          Browser.updateResizeListeners();\n        }\n      },\n  getHiDPIScale() {\n        return GLFW.isHiDPIAware() ? GLFW.scale : 1.0;\n      },\n  onDevicePixelRatioChange() {\n        GLFW.onWindowContentScaleChanged(GLFW.getDevicePixelRatio());\n        GLFW.adjustCanvasDimensions();\n      },\n  GLFW2ParamToGLFW3Param:(param) => {\n        var table = {\n          0x00030001:0, // GLFW_MOUSE_CURSOR\n          0x00030002:0, // GLFW_STICKY_KEYS\n          0x00030003:0, // GLFW_STICKY_MOUSE_BUTTONS\n          0x00030004:0, // GLFW_SYSTEM_KEYS\n          0x00030005:0, // GLFW_KEY_REPEAT\n          0x00030006:0, // GLFW_AUTO_POLL_EVENTS\n          0x00020001:0, // GLFW_OPENED\n          0x00020002:0, // GLFW_ACTIVE\n          0x00020003:0, // GLFW_ICONIFIED\n          0x00020004:0, // GLFW_ACCELERATED\n          0x00020005:0x00021001, // GLFW_RED_BITS\n          0x00020006:0x00021002, // GLFW_GREEN_BITS\n          0x00020007:0x00021003, // GLFW_BLUE_BITS\n          0x00020008:0x00021004, // GLFW_ALPHA_BITS\n          0x00020009:0x00021005, // GLFW_DEPTH_BITS\n          0x0002000A:0x00021006, // GLFW_STENCIL_BITS\n          0x0002000B:0x0002100F, // GLFW_REFRESH_RATE\n          0x0002000C:0x00021007, // GLFW_ACCUM_RED_BITS\n          0x0002000D:0x00021008, // GLFW_ACCUM_GREEN_BITS\n          0x0002000E:0x00021009, // GLFW_ACCUM_BLUE_BITS\n          0x0002000F:0x0002100A, // GLFW_ACCUM_ALPHA_BITS\n          0x00020010:0x0002100B, // GLFW_AUX_BUFFERS\n          0x00020011:0x0002100C, // GLFW_STEREO\n          0x00020012:0, // GLFW_WINDOW_NO_RESIZE\n          0x00020013:0x0002100D, // GLFW_FSAA_SAMPLES\n          0x00020014:0x00022002, // GLFW_OPENGL_VERSION_MAJOR\n          0x00020015:0x00022003, // GLFW_OPENGL_VERSION_MINOR\n          0x00020016:0x00022006, // GLFW_OPENGL_FORWARD_COMPAT\n          0x00020017:0x00022007, // GLFW_OPENGL_DEBUG_CONTEXT\n          0x00020018:0x00022008, // GLFW_OPENGL_PROFILE\n        };\n        return table[param];\n      },\n  };\n  var _glfwCreateStandardCursor = (shape) => 0;\n\n  var _glfwCreateWindow = (width, height, title, monitor, share) => GLFW.createWindow(width, height, title, monitor, share);\n\n  var _glfwDestroyCursor = (cursor) => 0;\n\n  var _glfwDestroyWindow = (winid) => GLFW.destroyWindow(winid);\n\n  var _glfwFocusWindow = (winid) => 0;\n\n  var _glfwGetClipboardString = (win) => 0;\n\n  var _glfwGetCursorPos = (winid, x, y) => GLFW.getCursorPos(winid, x, y);\n\n  var _glfwGetFramebufferSize = (winid, width, height) => {\n      var ww = 0;\n      var wh = 0;\n  \n      var win = GLFW.WindowFromId(winid);\n      if (win) {\n        ww = win.framebufferWidth;\n        wh = win.framebufferHeight;\n      }\n  \n      if (width) {\n        HEAP32[((width)>>2)] = ww;\n      }\n  \n      if (height) {\n        HEAP32[((height)>>2)] = wh;\n      }\n    };\n\n  var _glfwGetInputMode = (winid, mode) => {\n      var win = GLFW.WindowFromId(winid);\n      if (!win) return;\n  \n      switch (mode) {\n        case 0x00033001: { // GLFW_CURSOR\n          if (Browser.pointerLock) {\n            win.inputModes[mode] = 0x00034003; // GLFW_CURSOR_DISABLED\n          } else {\n            win.inputModes[mode] = 0x00034001; // GLFW_CURSOR_NORMAL\n          }\n        }\n      }\n  \n      return win.inputModes[mode];\n    };\n\n  var _glfwGetJoystickAxes = (joy, count) => {\n      GLFW.refreshJoysticks();\n  \n      var state = GLFW.joys[joy];\n      if (!state || !state.axes) {\n        HEAP32[((count)>>2)] = 0;\n        return;\n      }\n  \n      HEAP32[((count)>>2)] = state.axesCount;\n      return state.axes;\n    };\n\n  var _glfwGetJoystickButtons = (joy, count) => {\n      GLFW.refreshJoysticks();\n  \n      var state = GLFW.joys[joy];\n      if (!state || !state.buttons) {\n        HEAP32[((count)>>2)] = 0;\n        return;\n      }\n  \n      HEAP32[((count)>>2)] = state.buttonsCount;\n      return state.buttons;\n    };\n\n  var _glfwGetKey = (winid, key) => GLFW.getKey(winid, key);\n\n  var _glfwGetMonitorPos = (monitor, x, y) => {\n      HEAP32[((x)>>2)] = 0;\n      HEAP32[((y)>>2)] = 0;\n    };\n\n  var _glfwGetMonitorWorkarea = (monitor, x, y, w, h) => {\n      HEAP32[((x)>>2)] = 0;\n      HEAP32[((y)>>2)] = 0;\n  \n      HEAP32[((w)>>2)] = screen.availWidth;\n      HEAP32[((h)>>2)] = screen.availHeight;\n    };\n\n  \n  var _glfwGetMonitors = (count) => {\n      HEAP32[((count)>>2)] = 1;\n      if (!GLFW.monitors) {\n        GLFW.monitors = _malloc(4);\n        HEAP32[((GLFW.monitors)>>2)] = 1;\n      }\n      return GLFW.monitors;\n    };\n\n  var _glfwGetTime = () => GLFW.getTime() - GLFW.initialTime;\n\n  var _glfwGetVideoMode = (monitor) => 0;\n\n  var _glfwGetWindowAttrib = (winid, attrib) => {\n      var win = GLFW.WindowFromId(winid);\n      if (!win) return 0;\n      return win.attributes[attrib];\n    };\n\n  var _glfwGetWindowPos = (winid, x, y) => GLFW.getWindowPos(winid, x, y);\n\n  var _glfwGetWindowSize = (winid, width, height) => GLFW.getWindowSize(winid, width, height);\n\n  var _glfwInit = () => {\n      if (GLFW.windows) return 1; // GL_TRUE\n  \n      GLFW.initialTime = GLFW.getTime();\n      GLFW.defaultWindowHints();\n      GLFW.windows = new Array()\n      GLFW.active = null;\n      GLFW.scale  = GLFW.getDevicePixelRatio();\n  \n      window.addEventListener('gamepadconnected', GLFW.onGamepadConnected, true);\n      window.addEventListener('gamepaddisconnected', GLFW.onGamepadDisconnected, true);\n      window.addEventListener('keydown', GLFW.onKeydown, true);\n      window.addEventListener('keypress', GLFW.onKeyPress, true);\n      window.addEventListener('keyup', GLFW.onKeyup, true);\n      window.addEventListener('blur', GLFW.onBlur, true);\n  \n      // watch for devicePixelRatio changes\n      GLFW.devicePixelRatioMQL = window.matchMedia('(resolution: ' + GLFW.getDevicePixelRatio() + 'dppx)');\n      GLFW.devicePixelRatioMQL.addEventListener('change', GLFW.onDevicePixelRatioChange);\n  \n      var canvas = Browser.getCanvas();\n      canvas.addEventListener('touchmove', GLFW.onMousemove, true);\n      canvas.addEventListener('touchstart', GLFW.onMouseButtonDown, true);\n      canvas.addEventListener('touchcancel', GLFW.onMouseButtonUp, true);\n      canvas.addEventListener('touchend', GLFW.onMouseButtonUp, true);\n      canvas.addEventListener('mousemove', GLFW.onMousemove, true);\n      canvas.addEventListener('mousedown', GLFW.onMouseButtonDown, true);\n      canvas.addEventListener(\"mouseup\", GLFW.onMouseButtonUp, true);\n      canvas.addEventListener('wheel', GLFW.onMouseWheel, true);\n      canvas.addEventListener('mousewheel', GLFW.onMouseWheel, true);\n      canvas.addEventListener('mouseenter', GLFW.onMouseenter, true);\n      canvas.addEventListener('mouseleave', GLFW.onMouseleave, true);\n      canvas.addEventListener('drop', GLFW.onDrop, true);\n      canvas.addEventListener('dragover', GLFW.onDragover, true);\n  \n      // Overriding implementation to account for HiDPI\n      Browser.requestFullscreen = GLFW.requestFullscreen;\n      Browser.calculateMouseCoords = GLFW.calculateMouseCoords;\n      Browser.updateCanvasDimensions = GLFW.updateCanvasDimensions;\n  \n      Browser.resizeListeners.push((width, height) => {\n        if (GLFW.isHiDPIAware()) {\n          var canvas = Browser.getCanvas();\n          GLFW.onCanvasResize(canvas.clientWidth, canvas.clientHeight, width, height);\n        } else {\n          GLFW.onCanvasResize(width, height, width, height);\n        }\n      });\n  \n      return 1; // GL_TRUE\n    };\n\n  var _glfwMakeContextCurrent = (winid) => 0;\n\n  var _glfwPollEvents = () => 0;\n\n  var _glfwSetCharCallback = (winid, cbfun) => GLFW.setCharCallback(winid, cbfun);\n\n  var _glfwSetClipboardString = (win, string) => 0;\n\n  var _glfwSetCursor = (winid, cursor) => 0;\n\n  var _glfwSetCursorEnterCallback = (winid, cbfun) => {\n      var win = GLFW.WindowFromId(winid);\n      if (!win) return null;\n      var prevcbfun = win.cursorEnterFunc;\n      win.cursorEnterFunc = cbfun;\n      return prevcbfun;\n    };\n\n  var _glfwSetCursorPos = (winid, x, y) => GLFW.setCursorPos(winid, x, y);\n\n  var _glfwSetCursorPosCallback = (winid, cbfun) => GLFW.setCursorPosCallback(winid, cbfun);\n\n  var _glfwSetErrorCallback = (cbfun) => {\n      var prevcbfun = GLFW.errorFunc;\n      GLFW.errorFunc = cbfun;\n      return prevcbfun;\n    };\n\n  var _glfwSetInputMode = (winid, mode, value) => {\n      GLFW.setInputMode(winid, mode, value);\n    };\n\n  var _glfwSetKeyCallback = (winid, cbfun) => GLFW.setKeyCallback(winid, cbfun);\n\n  var _glfwSetMonitorCallback = (cbfun) => {\n      var prevcbfun = GLFW.monitorFunc;\n      GLFW.monitorFunc = cbfun;\n      return prevcbfun;\n    };\n\n  var _glfwSetMouseButtonCallback = (winid, cbfun) => GLFW.setMouseButtonCallback(winid, cbfun);\n\n  var _glfwSetScrollCallback = (winid, cbfun) => GLFW.setScrollCallback(winid, cbfun);\n\n  var _glfwSetWindowCloseCallback = (winid, cbfun) => GLFW.setWindowCloseCallback(winid, cbfun);\n\n  var _glfwSetWindowFocusCallback = (winid, cbfun) => {\n      var win = GLFW.WindowFromId(winid);\n      if (!win) return null;\n      var prevcbfun = win.windowFocusFunc;\n      win.windowFocusFunc = cbfun;\n      return prevcbfun;\n    };\n\n  var _glfwSetWindowOpacity = (winid, opacity) => { /* error */ };\n\n  var _glfwSetWindowPos = (winid, x, y) => GLFW.setWindowPos(winid, x, y);\n\n  var _glfwSetWindowPosCallback = (winid, cbfun) => {\n      var win = GLFW.WindowFromId(winid);\n      if (!win) return null;\n      var prevcbfun = win.windowPosFunc;\n      win.windowPosFunc = cbfun;\n      return prevcbfun;\n    };\n\n  var _glfwSetWindowSize = (winid, width, height) => GLFW.setWindowSize(winid, width, height);\n\n  var _glfwSetWindowSizeCallback = (winid, cbfun) => GLFW.setWindowSizeCallback(winid, cbfun);\n\n  var _glfwSetWindowTitle = (winid, title) => GLFW.setWindowTitle(winid, title);\n\n  var _glfwShowWindow = (winid) => 0;\n\n  var _glfwSwapBuffers = (winid) => GLFW.swapBuffers(winid);\n\n  \n  var _glfwSwapInterval = (interval) => {\n      interval = Math.abs(interval); // GLFW uses negative values to enable GLX_EXT_swap_control_tear, which we don't have, so just treat negative and positive the same.\n      if (interval == 0) _emscripten_set_main_loop_timing(0, 0);\n      else _emscripten_set_main_loop_timing(1, interval);\n    };\n\n  var _glfwTerminate = () => {\n      window.removeEventListener('gamepadconnected', GLFW.onGamepadConnected, true);\n      window.removeEventListener('gamepaddisconnected', GLFW.onGamepadDisconnected, true);\n      window.removeEventListener('keydown', GLFW.onKeydown, true);\n      window.removeEventListener('keypress', GLFW.onKeyPress, true);\n      window.removeEventListener('keyup', GLFW.onKeyup, true);\n      window.removeEventListener('blur', GLFW.onBlur, true);\n      var canvas = Browser.getCanvas();\n      canvas.removeEventListener('touchmove', GLFW.onMousemove, true);\n      canvas.removeEventListener('touchstart', GLFW.onMouseButtonDown, true);\n      canvas.removeEventListener('touchcancel', GLFW.onMouseButtonUp, true);\n      canvas.removeEventListener('touchend', GLFW.onMouseButtonUp, true);\n      canvas.removeEventListener('mousemove', GLFW.onMousemove, true);\n      canvas.removeEventListener('mousedown', GLFW.onMouseButtonDown, true);\n      canvas.removeEventListener('mouseup', GLFW.onMouseButtonUp, true);\n      canvas.removeEventListener('wheel', GLFW.onMouseWheel, true);\n      canvas.removeEventListener('mousewheel', GLFW.onMouseWheel, true);\n      canvas.removeEventListener('mouseenter', GLFW.onMouseenter, true);\n      canvas.removeEventListener('mouseleave', GLFW.onMouseleave, true);\n      canvas.removeEventListener('drop', GLFW.onDrop, true);\n      canvas.removeEventListener('dragover', GLFW.onDragover, true);\n  \n      if (GLFW.devicePixelRatioMQL)\n        GLFW.devicePixelRatioMQL.removeEventListener('change', GLFW.onDevicePixelRatioChange);\n  \n      canvas.width = canvas.height = 1;\n      GLFW.windows = null;\n      GLFW.active = null;\n    };\n\n  var _glfwWindowHint = (target, hint) => {\n      GLFW.hints[target] = hint;\n    };\n\n\n\n  \n  \n  var stackAlloc = (sz) => __emscripten_stack_alloc(sz);\n  var stringToUTF8OnStack = (str) => {\n      var size = lengthBytesUTF8(str) + 1;\n      var ret = stackAlloc(size);\n      stringToUTF8(str, ret, size);\n      return ret;\n    };\n\n  FS.createPreloadedFile = FS_createPreloadedFile;\n  FS.preloadFile = FS_preloadFile;\n  FS.staticInit();;\n\n      Module['requestAnimationFrame'] = MainLoop.requestAnimationFrame;\n      Module['pauseMainLoop'] = MainLoop.pause;\n      Module['resumeMainLoop'] = MainLoop.resume;\n      MainLoop.init();;\n\n      // Signal GL rendering layer that processing of a new frame is about to\n      // start. This helps it optimize VBO double-buffering and reduce GPU stalls.\n      registerPreMainLoop(() => GL.newRenderingFrameStarted());\n    ;\nvar miniTempWebGLFloatBuffersStorage = new Float32Array(288);\n  // Create GL_POOL_TEMP_BUFFERS_SIZE+1 temporary buffers, for uploads of size 0 through GL_POOL_TEMP_BUFFERS_SIZE inclusive\n  for (/**@suppress{duplicate}*/var i = 0; i <= 288; ++i) {\n    miniTempWebGLFloatBuffers[i] = miniTempWebGLFloatBuffersStorage.subarray(0, i);\n  };\n// End JS library code\n\n// include: postlibrary.js\n// This file is included after the automatically-generated JS library code\n// but before the wasm module is created.\n\n{\n\n  // Begin ATMODULES hooks\n  if (Module['noExitRuntime']) noExitRuntime = Module['noExitRuntime'];\nif (Module['preloadPlugins']) preloadPlugins = Module['preloadPlugins'];\nif (Module['print']) out = Module['print'];\nif (Module['printErr']) err = Module['printErr'];\nif (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];\n  // End ATMODULES hooks\n\n  checkIncomingModuleAPI();\n\n  if (Module['arguments']) arguments_ = Module['arguments'];\n  if (Module['thisProgram']) thisProgram = Module['thisProgram'];\n\n  // Assertions on removed incoming Module JS APIs.\n  assert(typeof Module['memoryInitializerPrefixURL'] == 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');\n  assert(typeof Module['pthreadMainPrefixURL'] == 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');\n  assert(typeof Module['cdInitializerPrefixURL'] == 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');\n  assert(typeof Module['filePackagePrefixURL'] == 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');\n  assert(typeof Module['read'] == 'undefined', 'Module.read option was removed');\n  assert(typeof Module['readAsync'] == 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');\n  assert(typeof Module['readBinary'] == 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');\n  assert(typeof Module['setWindowTitle'] == 'undefined', 'Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)');\n  assert(typeof Module['TOTAL_MEMORY'] == 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');\n  assert(typeof Module['ENVIRONMENT'] == 'undefined', 'Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)');\n  assert(typeof Module['STACK_SIZE'] == 'undefined', 'STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time')\n  // If memory is defined in wasm, the user can't provide it, or set INITIAL_MEMORY\n  assert(typeof Module['wasmMemory'] == 'undefined', 'Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally');\n  assert(typeof Module['INITIAL_MEMORY'] == 'undefined', 'Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically');\n\n  if (Module['preInit']) {\n    if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n    while (Module['preInit'].length > 0) {\n      Module['preInit'].shift()();\n    }\n  }\n  consumedModuleProp('preInit');\n}\n\n// Begin runtime exports\n  var missingLibrarySymbols = [\n  'writeI53ToI64Clamped',\n  'writeI53ToI64Signaling',\n  'writeI53ToU64Clamped',\n  'writeI53ToU64Signaling',\n  'convertI32PairToI53',\n  'convertI32PairToI53Checked',\n  'convertU32PairToI53',\n  'getTempRet0',\n  'setTempRet0',\n  'createNamedFunction',\n  'zeroMemory',\n  'getHeapMax',\n  'growMemory',\n  'withStackSave',\n  'inetPton4',\n  'inetNtop4',\n  'inetPton6',\n  'inetNtop6',\n  'readSockaddr',\n  'writeSockaddr',\n  'readEmAsmArgs',\n  'autoResumeAudioContext',\n  'getDynCaller',\n  'dynCall',\n  'runtimeKeepalivePush',\n  'runtimeKeepalivePop',\n  'asmjsMangle',\n  'alignMemory',\n  'HandleAllocator',\n  'addOnInit',\n  'addOnPostCtor',\n  'addOnPreMain',\n  'STACK_SIZE',\n  'STACK_ALIGN',\n  'POINTER_SIZE',\n  'ASSERTIONS',\n  'ccall',\n  'cwrap',\n  'convertJsFunctionToWasm',\n  'getEmptyTableSlot',\n  'updateTableMap',\n  'getFunctionAddress',\n  'addFunction',\n  'removeFunction',\n  'intArrayToString',\n  'AsciiToString',\n  'stringToAscii',\n  'UTF16ToString',\n  'stringToUTF16',\n  'lengthBytesUTF16',\n  'UTF32ToString',\n  'stringToUTF32',\n  'lengthBytesUTF32',\n  'writeArrayToMemory',\n  'registerKeyEventCallback',\n  'registerMouseEventCallback',\n  'registerFocusEventCallback',\n  'fillDeviceOrientationEventData',\n  'registerDeviceOrientationEventCallback',\n  'fillDeviceMotionEventData',\n  'registerDeviceMotionEventCallback',\n  'screenOrientation',\n  'fillOrientationChangeEventData',\n  'registerOrientationChangeEventCallback',\n  'JSEvents_requestFullscreen',\n  'JSEvents_resizeCanvasForFullscreen',\n  'registerRestoreOldStyle',\n  'hideEverythingExceptGivenElement',\n  'restoreHiddenElements',\n  'setLetterbox',\n  'softFullscreenResizeWebGLRenderTarget',\n  'doRequestFullscreen',\n  'fillPointerlockChangeEventData',\n  'registerPointerlockChangeEventCallback',\n  'registerPointerlockErrorEventCallback',\n  'requestPointerLock',\n  'fillVisibilityChangeEventData',\n  'registerVisibilityChangeEventCallback',\n  'registerTouchEventCallback',\n  'fillGamepadEventData',\n  'registerGamepadEventCallback',\n  'registerBeforeUnloadEventCallback',\n  'fillBatteryEventData',\n  'registerBatteryEventCallback',\n  'setCanvasElementSize',\n  'getCanvasElementSize',\n  'jsStackTrace',\n  'getCallstack',\n  'convertPCtoSourceLocation',\n  'checkWasiClock',\n  'wasiRightsToMuslOFlags',\n  'wasiOFlagsToMuslOFlags',\n  'setImmediateWrapped',\n  'safeRequestAnimationFrame',\n  'clearImmediateWrapped',\n  'registerPostMainLoop',\n  'getPromise',\n  'makePromise',\n  'idsToPromises',\n  'makePromiseCallback',\n  'ExceptionInfo',\n  'findMatchingCatch',\n  'Browser_asyncPrepareDataCounter',\n  'isLeapYear',\n  'ydayFromDate',\n  'arraySum',\n  'addDays',\n  'getSocketFromFD',\n  'getSocketAddress',\n  'FS_mkdirTree',\n  '_setNetworkCallback',\n  'emscriptenWebGLGetUniform',\n  'emscriptenWebGLGetVertexAttrib',\n  '__glGetActiveAttribOrUniform',\n  'writeGLArray',\n  'registerWebGlEventCallback',\n  'runAndAbortIfError',\n  'emscriptenWebGLGetIndexed',\n  'ALLOC_NORMAL',\n  'ALLOC_STACK',\n  'allocate',\n  'writeStringToMemory',\n  'writeAsciiToMemory',\n  'allocateUTF8',\n  'allocateUTF8OnStack',\n  'demangle',\n  'stackTrace',\n  'getNativeTypeSize',\n];\nmissingLibrarySymbols.forEach(missingLibrarySymbol)\n\n  var unexportedSymbols = [\n  'run',\n  'out',\n  'err',\n  'callMain',\n  'abort',\n  'wasmExports',\n  'HEAPF32',\n  'HEAPF64',\n  'HEAP8',\n  'HEAPU8',\n  'HEAP16',\n  'HEAPU16',\n  'HEAP32',\n  'HEAPU32',\n  'HEAP64',\n  'HEAPU64',\n  'writeStackCookie',\n  'checkStackCookie',\n  'writeI53ToI64',\n  'readI53FromI64',\n  'readI53FromU64',\n  'INT53_MAX',\n  'INT53_MIN',\n  'bigintToI53Checked',\n  'stackSave',\n  'stackRestore',\n  'stackAlloc',\n  'ptrToString',\n  'exitJS',\n  'abortOnCannotGrowMemory',\n  'ENV',\n  'ERRNO_CODES',\n  'strError',\n  'DNS',\n  'Protocols',\n  'Sockets',\n  'timers',\n  'warnOnce',\n  'readEmAsmArgsArray',\n  'jstoi_q',\n  'getExecutableName',\n  'handleException',\n  'keepRuntimeAlive',\n  'callUserCallback',\n  'maybeExit',\n  'asyncLoad',\n  'mmapAlloc',\n  'wasmTable',\n  'wasmMemory',\n  'getUniqueRunDependency',\n  'noExitRuntime',\n  'addRunDependency',\n  'removeRunDependency',\n  'addOnPreRun',\n  'addOnExit',\n  'addOnPostRun',\n  'freeTableIndexes',\n  'functionsInTableMap',\n  'setValue',\n  'getValue',\n  'PATH',\n  'PATH_FS',\n  'UTF8Decoder',\n  'UTF8ArrayToString',\n  'UTF8ToString',\n  'stringToUTF8Array',\n  'stringToUTF8',\n  'lengthBytesUTF8',\n  'intArrayFromString',\n  'UTF16Decoder',\n  'stringToNewUTF8',\n  'stringToUTF8OnStack',\n  'JSEvents',\n  'specialHTMLTargets',\n  'maybeCStringToJsString',\n  'findEventTarget',\n  'findCanvasEventTarget',\n  'getBoundingClientRect',\n  'fillMouseEventData',\n  'registerWheelEventCallback',\n  'registerUiEventCallback',\n  'fillFullscreenChangeEventData',\n  'registerFullscreenChangeEventCallback',\n  'currentFullscreenStrategy',\n  'restoreOldWindowedStyle',\n  'UNWIND_CACHE',\n  'ExitStatus',\n  'getEnvStrings',\n  'doReadv',\n  'doWritev',\n  'initRandomFill',\n  'randomFill',\n  'safeSetTimeout',\n  'emSetImmediate',\n  'emClearImmediate_deps',\n  'emClearImmediate',\n  'registerPreMainLoop',\n  'promiseMap',\n  'uncaughtExceptionCount',\n  'exceptionLast',\n  'exceptionCaught',\n  'Browser',\n  'requestFullscreen',\n  'requestFullScreen',\n  'setCanvasSize',\n  'getUserMedia',\n  'createContext',\n  'getPreloadedImageData__data',\n  'wget',\n  'MONTH_DAYS_REGULAR',\n  'MONTH_DAYS_LEAP',\n  'MONTH_DAYS_REGULAR_CUMULATIVE',\n  'MONTH_DAYS_LEAP_CUMULATIVE',\n  'SYSCALLS',\n  'preloadPlugins',\n  'FS_createPreloadedFile',\n  'FS_preloadFile',\n  'FS_modeStringToFlags',\n  'FS_getMode',\n  'FS_stdin_getChar_buffer',\n  'FS_stdin_getChar',\n  'FS_unlink',\n  'FS_createPath',\n  'FS_createDevice',\n  'FS_readFile',\n  'FS',\n  'FS_root',\n  'FS_mounts',\n  'FS_devices',\n  'FS_streams',\n  'FS_nextInode',\n  'FS_nameTable',\n  'FS_currentPath',\n  'FS_initialized',\n  'FS_ignorePermissions',\n  'FS_filesystems',\n  'FS_syncFSRequests',\n  'FS_readFiles',\n  'FS_lookupPath',\n  'FS_getPath',\n  'FS_hashName',\n  'FS_hashAddNode',\n  'FS_hashRemoveNode',\n  'FS_lookupNode',\n  'FS_createNode',\n  'FS_destroyNode',\n  'FS_isRoot',\n  'FS_isMountpoint',\n  'FS_isFile',\n  'FS_isDir',\n  'FS_isLink',\n  'FS_isChrdev',\n  'FS_isBlkdev',\n  'FS_isFIFO',\n  'FS_isSocket',\n  'FS_flagsToPermissionString',\n  'FS_nodePermissions',\n  'FS_mayLookup',\n  'FS_mayCreate',\n  'FS_mayDelete',\n  'FS_mayOpen',\n  'FS_checkOpExists',\n  'FS_nextfd',\n  'FS_getStreamChecked',\n  'FS_getStream',\n  'FS_createStream',\n  'FS_closeStream',\n  'FS_dupStream',\n  'FS_doSetAttr',\n  'FS_chrdev_stream_ops',\n  'FS_major',\n  'FS_minor',\n  'FS_makedev',\n  'FS_registerDevice',\n  'FS_getDevice',\n  'FS_getMounts',\n  'FS_syncfs',\n  'FS_mount',\n  'FS_unmount',\n  'FS_lookup',\n  'FS_mknod',\n  'FS_statfs',\n  'FS_statfsStream',\n  'FS_statfsNode',\n  'FS_create',\n  'FS_mkdir',\n  'FS_mkdev',\n  'FS_symlink',\n  'FS_rename',\n  'FS_rmdir',\n  'FS_readdir',\n  'FS_readlink',\n  'FS_stat',\n  'FS_fstat',\n  'FS_lstat',\n  'FS_doChmod',\n  'FS_chmod',\n  'FS_lchmod',\n  'FS_fchmod',\n  'FS_doChown',\n  'FS_chown',\n  'FS_lchown',\n  'FS_fchown',\n  'FS_doTruncate',\n  'FS_truncate',\n  'FS_ftruncate',\n  'FS_utime',\n  'FS_open',\n  'FS_close',\n  'FS_isClosed',\n  'FS_llseek',\n  'FS_read',\n  'FS_write',\n  'FS_mmap',\n  'FS_msync',\n  'FS_ioctl',\n  'FS_writeFile',\n  'FS_cwd',\n  'FS_chdir',\n  'FS_createDefaultDirectories',\n  'FS_createDefaultDevices',\n  'FS_createSpecialDirectories',\n  'FS_createStandardStreams',\n  'FS_staticInit',\n  'FS_init',\n  'FS_quit',\n  'FS_findObject',\n  'FS_analyzePath',\n  'FS_createFile',\n  'FS_createDataFile',\n  'FS_forceLoadFile',\n  'FS_createLazyFile',\n  'FS_absolutePath',\n  'FS_createFolder',\n  'FS_createLink',\n  'FS_joinPath',\n  'FS_mmapAlloc',\n  'FS_standardizePath',\n  'MEMFS',\n  'TTY',\n  'PIPEFS',\n  'SOCKFS',\n  'tempFixedLengthArray',\n  'miniTempWebGLFloatBuffers',\n  'miniTempWebGLIntBuffers',\n  'heapObjectForWebGLType',\n  'toTypedArrayIndex',\n  'webgl_enable_ANGLE_instanced_arrays',\n  'webgl_enable_OES_vertex_array_object',\n  'webgl_enable_WEBGL_draw_buffers',\n  'webgl_enable_WEBGL_multi_draw',\n  'webgl_enable_EXT_polygon_offset_clamp',\n  'webgl_enable_EXT_clip_control',\n  'webgl_enable_WEBGL_polygon_mode',\n  'GL',\n  'emscriptenWebGLGet',\n  'computeUnpackAlignedImageSize',\n  'colorChannelsInGlTextureFormat',\n  'emscriptenWebGLGetTexPixelData',\n  'webglGetUniformLocation',\n  'webglPrepareUniformLocationsBeforeFirstUse',\n  'webglGetLeftBracePos',\n  'AL',\n  'GLUT',\n  'EGL',\n  'GLEW',\n  'IDBStore',\n  'SDL',\n  'SDL_gfx',\n  'GLFW_Window',\n  'GLFW',\n  'webgl_enable_WEBGL_draw_instanced_base_vertex_base_instance',\n  'webgl_enable_WEBGL_multi_draw_instanced_base_vertex_base_instance',\n  'print',\n  'printErr',\n  'jstoi_s',\n];\nunexportedSymbols.forEach(unexportedRuntimeSymbol);\n\n  // End runtime exports\n  // Begin JS library exports\n  // End JS library exports\n\n// end include: postlibrary.js\n\nfunction checkIncomingModuleAPI() {\n  ignoredModuleProp('fetchSettings');\n}\nfunction ImGui_ImplGlfw_EmscriptenOpenURL(url) { url = url ? UTF8ToString(url) : null; if (url) window.open(url, '_blank'); }\n\n// Imports from the Wasm binary.\nvar _main = Module['_main'] = makeInvalidEarlyAccess('_main');\nvar _fflush = makeInvalidEarlyAccess('_fflush');\nvar _malloc = makeInvalidEarlyAccess('_malloc');\nvar _free = makeInvalidEarlyAccess('_free');\nvar _emscripten_stack_get_end = makeInvalidEarlyAccess('_emscripten_stack_get_end');\nvar _emscripten_stack_get_base = makeInvalidEarlyAccess('_emscripten_stack_get_base');\nvar _strerror = makeInvalidEarlyAccess('_strerror');\nvar _emscripten_stack_init = makeInvalidEarlyAccess('_emscripten_stack_init');\nvar _emscripten_stack_get_free = makeInvalidEarlyAccess('_emscripten_stack_get_free');\nvar __emscripten_stack_restore = makeInvalidEarlyAccess('__emscripten_stack_restore');\nvar __emscripten_stack_alloc = makeInvalidEarlyAccess('__emscripten_stack_alloc');\nvar _emscripten_stack_get_current = makeInvalidEarlyAccess('_emscripten_stack_get_current');\nvar memory = makeInvalidEarlyAccess('memory');\nvar __indirect_function_table = makeInvalidEarlyAccess('__indirect_function_table');\nvar wasmMemory = makeInvalidEarlyAccess('wasmMemory');\nvar wasmTable = makeInvalidEarlyAccess('wasmTable');\n\nfunction assignWasmExports(wasmExports) {\n  assert(typeof wasmExports['__main_argc_argv'] != 'undefined', 'missing Wasm export: __main_argc_argv');\n  _main = Module['_main'] = createExportWrapper('__main_argc_argv', 2);\n  assert(typeof wasmExports['fflush'] != 'undefined', 'missing Wasm export: fflush');\n  _fflush = createExportWrapper('fflush', 1);\n  assert(typeof wasmExports['malloc'] != 'undefined', 'missing Wasm export: malloc');\n  _malloc = createExportWrapper('malloc', 1);\n  assert(typeof wasmExports['free'] != 'undefined', 'missing Wasm export: free');\n  _free = createExportWrapper('free', 1);\n  assert(typeof wasmExports['emscripten_stack_get_end'] != 'undefined', 'missing Wasm export: emscripten_stack_get_end');\n  _emscripten_stack_get_end = wasmExports['emscripten_stack_get_end'];\n  assert(typeof wasmExports['emscripten_stack_get_base'] != 'undefined', 'missing Wasm export: emscripten_stack_get_base');\n  _emscripten_stack_get_base = wasmExports['emscripten_stack_get_base'];\n  assert(typeof wasmExports['strerror'] != 'undefined', 'missing Wasm export: strerror');\n  _strerror = createExportWrapper('strerror', 1);\n  assert(typeof wasmExports['emscripten_stack_init'] != 'undefined', 'missing Wasm export: emscripten_stack_init');\n  _emscripten_stack_init = wasmExports['emscripten_stack_init'];\n  assert(typeof wasmExports['emscripten_stack_get_free'] != 'undefined', 'missing Wasm export: emscripten_stack_get_free');\n  _emscripten_stack_get_free = wasmExports['emscripten_stack_get_free'];\n  assert(typeof wasmExports['_emscripten_stack_restore'] != 'undefined', 'missing Wasm export: _emscripten_stack_restore');\n  __emscripten_stack_restore = wasmExports['_emscripten_stack_restore'];\n  assert(typeof wasmExports['_emscripten_stack_alloc'] != 'undefined', 'missing Wasm export: _emscripten_stack_alloc');\n  __emscripten_stack_alloc = wasmExports['_emscripten_stack_alloc'];\n  assert(typeof wasmExports['emscripten_stack_get_current'] != 'undefined', 'missing Wasm export: emscripten_stack_get_current');\n  _emscripten_stack_get_current = wasmExports['emscripten_stack_get_current'];\n  assert(typeof wasmExports['memory'] != 'undefined', 'missing Wasm export: memory');\n  memory = wasmMemory = wasmExports['memory'];\n  assert(typeof wasmExports['__indirect_function_table'] != 'undefined', 'missing Wasm export: __indirect_function_table');\n  __indirect_function_table = wasmTable = wasmExports['__indirect_function_table'];\n}\n\nvar wasmImports = {\n  /** @export */\n  ImGui_ImplGlfw_EmscriptenOpenURL,\n  /** @export */\n  __assert_fail: ___assert_fail,\n  /** @export */\n  __syscall_fcntl64: ___syscall_fcntl64,\n  /** @export */\n  __syscall_ioctl: ___syscall_ioctl,\n  /** @export */\n  __syscall_openat: ___syscall_openat,\n  /** @export */\n  _abort_js: __abort_js,\n  /** @export */\n  emscripten_err: _emscripten_err,\n  /** @export */\n  emscripten_get_element_css_size: _emscripten_get_element_css_size,\n  /** @export */\n  emscripten_resize_heap: _emscripten_resize_heap,\n  /** @export */\n  emscripten_set_fullscreenchange_callback_on_thread: _emscripten_set_fullscreenchange_callback_on_thread,\n  /** @export */\n  emscripten_set_main_loop: _emscripten_set_main_loop,\n  /** @export */\n  emscripten_set_resize_callback_on_thread: _emscripten_set_resize_callback_on_thread,\n  /** @export */\n  emscripten_set_wheel_callback_on_thread: _emscripten_set_wheel_callback_on_thread,\n  /** @export */\n  environ_get: _environ_get,\n  /** @export */\n  environ_sizes_get: _environ_sizes_get,\n  /** @export */\n  exit: _exit,\n  /** @export */\n  fd_close: _fd_close,\n  /** @export */\n  fd_read: _fd_read,\n  /** @export */\n  fd_seek: _fd_seek,\n  /** @export */\n  fd_write: _fd_write,\n  /** @export */\n  glActiveTexture: _glActiveTexture,\n  /** @export */\n  glAttachShader: _glAttachShader,\n  /** @export */\n  glBindBuffer: _glBindBuffer,\n  /** @export */\n  glBindTexture: _glBindTexture,\n  /** @export */\n  glBindVertexArrayOES: _glBindVertexArrayOES,\n  /** @export */\n  glBlendEquation: _glBlendEquation,\n  /** @export */\n  glBlendEquationSeparate: _glBlendEquationSeparate,\n  /** @export */\n  glBlendFuncSeparate: _glBlendFuncSeparate,\n  /** @export */\n  glBufferData: _glBufferData,\n  /** @export */\n  glBufferSubData: _glBufferSubData,\n  /** @export */\n  glClear: _glClear,\n  /** @export */\n  glClearColor: _glClearColor,\n  /** @export */\n  glCompileShader: _glCompileShader,\n  /** @export */\n  glCreateProgram: _glCreateProgram,\n  /** @export */\n  glCreateShader: _glCreateShader,\n  /** @export */\n  glDeleteBuffers: _glDeleteBuffers,\n  /** @export */\n  glDeleteProgram: _glDeleteProgram,\n  /** @export */\n  glDeleteShader: _glDeleteShader,\n  /** @export */\n  glDeleteTextures: _glDeleteTextures,\n  /** @export */\n  glDeleteVertexArraysOES: _glDeleteVertexArraysOES,\n  /** @export */\n  glDetachShader: _glDetachShader,\n  /** @export */\n  glDisable: _glDisable,\n  /** @export */\n  glDrawElements: _glDrawElements,\n  /** @export */\n  glEnable: _glEnable,\n  /** @export */\n  glEnableVertexAttribArray: _glEnableVertexAttribArray,\n  /** @export */\n  glGenBuffers: _glGenBuffers,\n  /** @export */\n  glGenTextures: _glGenTextures,\n  /** @export */\n  glGenVertexArraysOES: _glGenVertexArraysOES,\n  /** @export */\n  glGetAttribLocation: _glGetAttribLocation,\n  /** @export */\n  glGetIntegerv: _glGetIntegerv,\n  /** @export */\n  glGetProgramInfoLog: _glGetProgramInfoLog,\n  /** @export */\n  glGetProgramiv: _glGetProgramiv,\n  /** @export */\n  glGetShaderInfoLog: _glGetShaderInfoLog,\n  /** @export */\n  glGetShaderiv: _glGetShaderiv,\n  /** @export */\n  glGetString: _glGetString,\n  /** @export */\n  glGetUniformLocation: _glGetUniformLocation,\n  /** @export */\n  glIsEnabled: _glIsEnabled,\n  /** @export */\n  glIsProgram: _glIsProgram,\n  /** @export */\n  glLinkProgram: _glLinkProgram,\n  /** @export */\n  glPixelStorei: _glPixelStorei,\n  /** @export */\n  glScissor: _glScissor,\n  /** @export */\n  glShaderSource: _glShaderSource,\n  /** @export */\n  glTexImage2D: _glTexImage2D,\n  /** @export */\n  glTexParameteri: _glTexParameteri,\n  /** @export */\n  glTexSubImage2D: _glTexSubImage2D,\n  /** @export */\n  glUniform1i: _glUniform1i,\n  /** @export */\n  glUniformMatrix4fv: _glUniformMatrix4fv,\n  /** @export */\n  glUseProgram: _glUseProgram,\n  /** @export */\n  glVertexAttribPointer: _glVertexAttribPointer,\n  /** @export */\n  glViewport: _glViewport,\n  /** @export */\n  glfwCreateStandardCursor: _glfwCreateStandardCursor,\n  /** @export */\n  glfwCreateWindow: _glfwCreateWindow,\n  /** @export */\n  glfwDestroyCursor: _glfwDestroyCursor,\n  /** @export */\n  glfwDestroyWindow: _glfwDestroyWindow,\n  /** @export */\n  glfwFocusWindow: _glfwFocusWindow,\n  /** @export */\n  glfwGetClipboardString: _glfwGetClipboardString,\n  /** @export */\n  glfwGetCursorPos: _glfwGetCursorPos,\n  /** @export */\n  glfwGetFramebufferSize: _glfwGetFramebufferSize,\n  /** @export */\n  glfwGetInputMode: _glfwGetInputMode,\n  /** @export */\n  glfwGetJoystickAxes: _glfwGetJoystickAxes,\n  /** @export */\n  glfwGetJoystickButtons: _glfwGetJoystickButtons,\n  /** @export */\n  glfwGetKey: _glfwGetKey,\n  /** @export */\n  glfwGetMonitorPos: _glfwGetMonitorPos,\n  /** @export */\n  glfwGetMonitorWorkarea: _glfwGetMonitorWorkarea,\n  /** @export */\n  glfwGetMonitors: _glfwGetMonitors,\n  /** @export */\n  glfwGetTime: _glfwGetTime,\n  /** @export */\n  glfwGetVideoMode: _glfwGetVideoMode,\n  /** @export */\n  glfwGetWindowAttrib: _glfwGetWindowAttrib,\n  /** @export */\n  glfwGetWindowPos: _glfwGetWindowPos,\n  /** @export */\n  glfwGetWindowSize: _glfwGetWindowSize,\n  /** @export */\n  glfwInit: _glfwInit,\n  /** @export */\n  glfwMakeContextCurrent: _glfwMakeContextCurrent,\n  /** @export */\n  glfwPollEvents: _glfwPollEvents,\n  /** @export */\n  glfwSetCharCallback: _glfwSetCharCallback,\n  /** @export */\n  glfwSetClipboardString: _glfwSetClipboardString,\n  /** @export */\n  glfwSetCursor: _glfwSetCursor,\n  /** @export */\n  glfwSetCursorEnterCallback: _glfwSetCursorEnterCallback,\n  /** @export */\n  glfwSetCursorPos: _glfwSetCursorPos,\n  /** @export */\n  glfwSetCursorPosCallback: _glfwSetCursorPosCallback,\n  /** @export */\n  glfwSetErrorCallback: _glfwSetErrorCallback,\n  /** @export */\n  glfwSetInputMode: _glfwSetInputMode,\n  /** @export */\n  glfwSetKeyCallback: _glfwSetKeyCallback,\n  /** @export */\n  glfwSetMonitorCallback: _glfwSetMonitorCallback,\n  /** @export */\n  glfwSetMouseButtonCallback: _glfwSetMouseButtonCallback,\n  /** @export */\n  glfwSetScrollCallback: _glfwSetScrollCallback,\n  /** @export */\n  glfwSetWindowCloseCallback: _glfwSetWindowCloseCallback,\n  /** @export */\n  glfwSetWindowFocusCallback: _glfwSetWindowFocusCallback,\n  /** @export */\n  glfwSetWindowOpacity: _glfwSetWindowOpacity,\n  /** @export */\n  glfwSetWindowPos: _glfwSetWindowPos,\n  /** @export */\n  glfwSetWindowPosCallback: _glfwSetWindowPosCallback,\n  /** @export */\n  glfwSetWindowSize: _glfwSetWindowSize,\n  /** @export */\n  glfwSetWindowSizeCallback: _glfwSetWindowSizeCallback,\n  /** @export */\n  glfwSetWindowTitle: _glfwSetWindowTitle,\n  /** @export */\n  glfwShowWindow: _glfwShowWindow,\n  /** @export */\n  glfwSwapBuffers: _glfwSwapBuffers,\n  /** @export */\n  glfwSwapInterval: _glfwSwapInterval,\n  /** @export */\n  glfwTerminate: _glfwTerminate,\n  /** @export */\n  glfwWindowHint: _glfwWindowHint\n};\n\n\n// include: postamble.js\n// === Auto-generated postamble setup entry stuff ===\n\nvar calledRun;\n\nfunction callMain(args = []) {\n  assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on Module[\"onRuntimeInitialized\"])');\n  assert(typeof onPreRuns === 'undefined' || onPreRuns.length == 0, 'cannot call main when preRun functions remain to be called');\n\n  var entryFunction = _main;\n\n  args.unshift(thisProgram);\n\n  var argc = args.length;\n  var argv = stackAlloc((argc + 1) * 4);\n  var argv_ptr = argv;\n  args.forEach((arg) => {\n    HEAPU32[((argv_ptr)>>2)] = stringToUTF8OnStack(arg);\n    argv_ptr += 4;\n  });\n  HEAPU32[((argv_ptr)>>2)] = 0;\n\n  try {\n\n    var ret = entryFunction(argc, argv);\n\n    // if we're not running an evented main loop, it's time to exit\n    exitJS(ret, /* implicit = */ true);\n    return ret;\n  } catch (e) {\n    return handleException(e);\n  }\n}\n\nfunction stackCheckInit() {\n  // This is normally called automatically during __wasm_call_ctors but need to\n  // get these values before even running any of the ctors so we call it redundantly\n  // here.\n  _emscripten_stack_init();\n  // TODO(sbc): Move writeStackCookie to native to to avoid this.\n  writeStackCookie();\n}\n\nfunction run(args = arguments_) {\n\n  if (runDependencies > 0) {\n    dependenciesFulfilled = run;\n    return;\n  }\n\n  stackCheckInit();\n\n  preRun();\n\n  // a preRun added a dependency, run will be called later\n  if (runDependencies > 0) {\n    dependenciesFulfilled = run;\n    return;\n  }\n\n  function doRun() {\n    // run may have just been called through dependencies being fulfilled just in this very frame,\n    // or while the async setStatus time below was happening\n    assert(!calledRun);\n    calledRun = true;\n    Module['calledRun'] = true;\n\n    if (ABORT) return;\n\n    initRuntime();\n\n    preMain();\n\n    Module['onRuntimeInitialized']?.();\n    consumedModuleProp('onRuntimeInitialized');\n\n    var noInitialRun = Module['noInitialRun'] || false;\n    if (!noInitialRun) callMain(args);\n\n    postRun();\n  }\n\n  if (Module['setStatus']) {\n    Module['setStatus']('Running...');\n    setTimeout(() => {\n      setTimeout(() => Module['setStatus'](''), 1);\n      doRun();\n    }, 1);\n  } else\n  {\n    doRun();\n  }\n  checkStackCookie();\n}\n\nfunction checkUnflushedContent() {\n  // Compiler settings do not allow exiting the runtime, so flushing\n  // the streams is not possible. but in ASSERTIONS mode we check\n  // if there was something to flush, and if so tell the user they\n  // should request that the runtime be exitable.\n  // Normally we would not even include flush() at all, but in ASSERTIONS\n  // builds we do so just for this check, and here we see if there is any\n  // content to flush, that is, we check if there would have been\n  // something a non-ASSERTIONS build would have not seen.\n  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0\n  // mode (which has its own special function for this; otherwise, all\n  // the code is inside libc)\n  var oldOut = out;\n  var oldErr = err;\n  var has = false;\n  out = err = (x) => {\n    has = true;\n  }\n  try { // it doesn't matter if it fails\n    _fflush(0);\n    // also flush in the JS FS layer\n    ['stdout', 'stderr'].forEach((name) => {\n      var info = FS.analyzePath('/dev/' + name);\n      if (!info) return;\n      var stream = info.object;\n      var rdev = stream.rdev;\n      var tty = TTY.ttys[rdev];\n      if (tty?.output?.length) {\n        has = true;\n      }\n    });\n  } catch(e) {}\n  out = oldOut;\n  err = oldErr;\n  if (has) {\n    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.');\n  }\n}\n\nvar wasmExports;\n\n// With async instantation wasmExports is assigned asynchronously when the\n// instance is received.\ncreateWasm();\n\nrun();\n\n// end include: postamble.js\n\n\n\n//# sourceURL=webpack://webgui/./install/share/gui.js?\n}");

/***/ }),

/***/ "?d872":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

eval("{/* (ignored) */\n\n//# sourceURL=webpack://webgui/fs_(ignored)?\n}");

/***/ }),

/***/ "?df81":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

eval("{/* (ignored) */\n\n//# sourceURL=webpack://webgui/crypto_(ignored)?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./install/share/gui.js");
/******/ 	
/******/ })()
;